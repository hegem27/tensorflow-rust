#![allow(non_snake_case)]
#![allow(missing_docs)]

use crate::eager::Context;
use crate::eager::TensorHandle;
use crate::eager::ToHandle;
use crate::AnyTensor;
use crate::DataType;
use crate::Result;
use crate::Status;
use crate::Tensor;
use crate::TensorType;
use std::ffi::CString;
use std::os::raw::c_void;

use tensorflow_sys as tf;

pub fn abs<T>(ctx: &Context, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Abs").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn accumulate_n_v2<T>(ctx: &Context, inputs: &Vec<T>, shape: &Vec<i64>) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("AccumulateNV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        let mut inputs_handles: Vec<*mut tf::TFE_TensorHandle> = inputs
            .into_iter()
            .map(|t| t.to_handle().unwrap().inner)
            .collect();
        tf::TFE_OpAddInputList(
            op,
            inputs_handles.as_mut_ptr(),
            inputs.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("N").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), inputs.len() as i64);

        let attr_name = CString::new("shape").unwrap();
        tf::TFE_OpSetAttrShape(
            op,
            attr_name.as_ptr(),
            shape.as_ptr(),
            shape.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn accumulator_num_accumulated<T>(ctx: &Context, handle: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("AccumulatorNumAccumulated").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn accumulator_take_gradient<T>(
    ctx: &Context,
    handle: T,
    num_required: T,
    dtype_: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("AccumulatorTakeGradient").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, num_required.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), dtype_.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn acos<T>(ctx: &Context, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Acos").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn acosh<T>(ctx: &Context, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Acosh").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn add<T>(ctx: &Context, x: T, y: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Add").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, y.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn add_many_sparse_to_tensors_map<T>(
    ctx: &Context,
    sparse_indices: T,
    sparse_values: T,
    sparse_shape: T,
    container: &String,
    shared_name: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("AddManySparseToTensorsMap").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, sparse_indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, sparse_values.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, sparse_shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("container").unwrap();
        let container_cstr = container.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            container_cstr.as_ptr() as *mut c_void,
            container.as_bytes().len() + 1,
        );

        let attr_name = CString::new("shared_name").unwrap();
        let shared_name_cstr = shared_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            shared_name_cstr.as_ptr() as *mut c_void,
            shared_name.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn add_n<T>(ctx: &Context, inputs: &Vec<T>) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("AddN").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        let mut inputs_handles: Vec<*mut tf::TFE_TensorHandle> = inputs
            .into_iter()
            .map(|t| t.to_handle().unwrap().inner)
            .collect();
        tf::TFE_OpAddInputList(
            op,
            inputs_handles.as_mut_ptr(),
            inputs.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("N").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), inputs.len() as i64);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn add_sparse_to_tensors_map<T>(
    ctx: &Context,
    sparse_indices: T,
    sparse_values: T,
    sparse_shape: T,
    container: &String,
    shared_name: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("AddSparseToTensorsMap").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, sparse_indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, sparse_values.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, sparse_shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("container").unwrap();
        let container_cstr = container.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            container_cstr.as_ptr() as *mut c_void,
            container.as_bytes().len() + 1,
        );

        let attr_name = CString::new("shared_name").unwrap();
        let shared_name_cstr = shared_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            shared_name_cstr.as_ptr() as *mut c_void,
            shared_name.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn add_v2<T>(ctx: &Context, x: T, y: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("AddV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, y.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn adjust_contrast<T>(
    ctx: &Context,
    images: T,
    contrast_factor: T,
    min_value: T,
    max_value: T,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("AdjustContrast").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, images.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, contrast_factor.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, min_value.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, max_value.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn adjust_contrastv2<T>(ctx: &Context, images: T, contrast_factor: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("AdjustContrastv2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, images.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, contrast_factor.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn adjust_hue<T>(ctx: &Context, images: T, delta: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("AdjustHue").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, images.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, delta.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn adjust_saturation<T>(ctx: &Context, images: T, scale: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("AdjustSaturation").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, images.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, scale.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn all<T>(
    ctx: &Context,
    input: T,
    reduction_indices: T,
    keep_dims: bool,
    Tidx: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("All").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, reduction_indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("keep_dims").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), keep_dims as u8);

        let attr_name = CString::new("Tidx").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tidx.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn all_to_all<T>(
    ctx: &Context,
    input: T,
    group_assignment: T,
    concat_dimension: i64,
    split_dimension: i64,
    split_count: i64,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("AllToAll").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, group_assignment.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("concat_dimension").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), concat_dimension);

        let attr_name = CString::new("split_dimension").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), split_dimension);

        let attr_name = CString::new("split_count").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), split_count);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn angle<T>(ctx: &Context, input: T, Tout: DataType) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Angle").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tout").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tout.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn anonymous_iterator<T>(
    ctx: &Context,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("AnonymousIterator").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn any<T>(
    ctx: &Context,
    input: T,
    reduction_indices: T,
    keep_dims: bool,
    Tidx: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Any").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, reduction_indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("keep_dims").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), keep_dims as u8);

        let attr_name = CString::new("Tidx").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tidx.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn apply_ada_max<T>(
    ctx: &Context,
    var: T,
    m: T,
    v: T,
    beta1_power: T,
    lr: T,
    beta1: T,
    beta2: T,
    epsilon: T,
    grad: T,
    use_locking: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ApplyAdaMax").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, var.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, m.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, v.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, beta1_power.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, lr.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, beta1.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, beta2.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, epsilon.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, grad.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("use_locking").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), use_locking as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn apply_adadelta<T>(
    ctx: &Context,
    var: T,
    accum: T,
    accum_update: T,
    lr: T,
    rho: T,
    epsilon: T,
    grad: T,
    use_locking: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ApplyAdadelta").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, var.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, accum.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, accum_update.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, lr.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, rho.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, epsilon.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, grad.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("use_locking").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), use_locking as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn apply_adagrad<T>(
    ctx: &Context,
    var: T,
    accum: T,
    lr: T,
    grad: T,
    use_locking: bool,
    update_slots: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ApplyAdagrad").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, var.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, accum.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, lr.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, grad.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("use_locking").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), use_locking as u8);

        let attr_name = CString::new("update_slots").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), update_slots as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn apply_adagrad_d_a<T>(
    ctx: &Context,
    var: T,
    gradient_accumulator: T,
    gradient_squared_accumulator: T,
    grad: T,
    lr: T,
    l1: T,
    l2: T,
    global_step: T,
    use_locking: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ApplyAdagradDA").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, var.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, gradient_accumulator.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(
            op,
            gradient_squared_accumulator.to_handle()?.inner,
            status.inner,
        );
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, grad.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, lr.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, l1.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, l2.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, global_step.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("use_locking").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), use_locking as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn apply_adagrad_v2<T>(
    ctx: &Context,
    var: T,
    accum: T,
    lr: T,
    epsilon: T,
    grad: T,
    use_locking: bool,
    update_slots: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ApplyAdagradV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, var.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, accum.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, lr.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, epsilon.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, grad.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("use_locking").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), use_locking as u8);

        let attr_name = CString::new("update_slots").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), update_slots as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn apply_adam<T>(
    ctx: &Context,
    var: T,
    m: T,
    v: T,
    beta1_power: T,
    beta2_power: T,
    lr: T,
    beta1: T,
    beta2: T,
    epsilon: T,
    grad: T,
    use_locking: bool,
    use_nesterov: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ApplyAdam").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, var.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, m.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, v.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, beta1_power.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, beta2_power.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, lr.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, beta1.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, beta2.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, epsilon.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, grad.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("use_locking").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), use_locking as u8);

        let attr_name = CString::new("use_nesterov").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), use_nesterov as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn apply_add_sign<T>(
    ctx: &Context,
    var: T,
    m: T,
    lr: T,
    alpha: T,
    sign_decay: T,
    beta: T,
    grad: T,
    use_locking: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ApplyAddSign").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, var.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, m.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, lr.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, alpha.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, sign_decay.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, beta.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, grad.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("use_locking").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), use_locking as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn apply_centered_r_m_s_prop<T>(
    ctx: &Context,
    var: T,
    mg: T,
    ms: T,
    mom: T,
    lr: T,
    rho: T,
    momentum: T,
    epsilon: T,
    grad: T,
    use_locking: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ApplyCenteredRMSProp").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, var.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, mg.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, ms.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, mom.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, lr.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, rho.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, momentum.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, epsilon.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, grad.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("use_locking").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), use_locking as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn apply_ftrl<T>(
    ctx: &Context,
    var: T,
    accum: T,
    linear: T,
    grad: T,
    lr: T,
    l1: T,
    l2: T,
    lr_power: T,
    use_locking: bool,
    multiply_linear_by_lr: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ApplyFtrl").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, var.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, accum.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, linear.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, grad.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, lr.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, l1.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, l2.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, lr_power.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("use_locking").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), use_locking as u8);

        let attr_name = CString::new("multiply_linear_by_lr").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), multiply_linear_by_lr as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn apply_ftrl_v2<T>(
    ctx: &Context,
    var: T,
    accum: T,
    linear: T,
    grad: T,
    lr: T,
    l1: T,
    l2: T,
    l2_shrinkage: T,
    lr_power: T,
    use_locking: bool,
    multiply_linear_by_lr: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ApplyFtrlV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, var.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, accum.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, linear.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, grad.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, lr.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, l1.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, l2.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, l2_shrinkage.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, lr_power.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("use_locking").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), use_locking as u8);

        let attr_name = CString::new("multiply_linear_by_lr").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), multiply_linear_by_lr as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn apply_gradient_descent<T>(
    ctx: &Context,
    var: T,
    alpha: T,
    delta: T,
    use_locking: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ApplyGradientDescent").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, var.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, alpha.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, delta.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("use_locking").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), use_locking as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn apply_momentum<T>(
    ctx: &Context,
    var: T,
    accum: T,
    lr: T,
    grad: T,
    momentum: T,
    use_locking: bool,
    use_nesterov: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ApplyMomentum").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, var.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, accum.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, lr.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, grad.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, momentum.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("use_locking").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), use_locking as u8);

        let attr_name = CString::new("use_nesterov").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), use_nesterov as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn apply_power_sign<T>(
    ctx: &Context,
    var: T,
    m: T,
    lr: T,
    logbase: T,
    sign_decay: T,
    beta: T,
    grad: T,
    use_locking: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ApplyPowerSign").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, var.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, m.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, lr.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, logbase.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, sign_decay.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, beta.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, grad.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("use_locking").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), use_locking as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn apply_proximal_adagrad<T>(
    ctx: &Context,
    var: T,
    accum: T,
    lr: T,
    l1: T,
    l2: T,
    grad: T,
    use_locking: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ApplyProximalAdagrad").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, var.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, accum.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, lr.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, l1.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, l2.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, grad.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("use_locking").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), use_locking as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn apply_proximal_gradient_descent<T>(
    ctx: &Context,
    var: T,
    alpha: T,
    l1: T,
    l2: T,
    delta: T,
    use_locking: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ApplyProximalGradientDescent").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, var.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, alpha.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, l1.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, l2.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, delta.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("use_locking").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), use_locking as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn apply_r_m_s_prop<T>(
    ctx: &Context,
    var: T,
    ms: T,
    mom: T,
    lr: T,
    rho: T,
    momentum: T,
    epsilon: T,
    grad: T,
    use_locking: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ApplyRMSProp").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, var.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, ms.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, mom.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, lr.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, rho.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, momentum.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, epsilon.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, grad.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("use_locking").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), use_locking as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn approximate_equal<T>(ctx: &Context, x: T, y: T, tolerance: f32) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ApproximateEqual").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, y.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("tolerance").unwrap();
        tf::TFE_OpSetAttrFloat(op, attr_name.as_ptr(), tolerance);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn arg_max<T>(
    ctx: &Context,
    input: T,
    dimension: T,
    Tidx: DataType,
    output_type_: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ArgMax").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, dimension.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tidx").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tidx.to_c());

        let attr_name = CString::new("output_type_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), output_type_.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn arg_min<T>(
    ctx: &Context,
    input: T,
    dimension: T,
    Tidx: DataType,
    output_type_: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ArgMin").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, dimension.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tidx").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tidx.to_c());

        let attr_name = CString::new("output_type_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), output_type_.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn as_string<T>(
    ctx: &Context,
    input: T,
    precision: i64,
    scientific: bool,
    shortest: bool,
    width: i64,
    fill: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("AsString").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("precision").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), precision);

        let attr_name = CString::new("scientific").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), scientific as u8);

        let attr_name = CString::new("shortest").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), shortest as u8);

        let attr_name = CString::new("width").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), width);

        let attr_name = CString::new("fill").unwrap();
        let fill_cstr = fill.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            fill_cstr.as_ptr() as *mut c_void,
            fill.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn asin<T>(ctx: &Context, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Asin").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn asinh<T>(ctx: &Context, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Asinh").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn assert_cardinality_dataset<T>(
    ctx: &Context,
    input_dataset: T,
    cardinality: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("AssertCardinalityDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, cardinality.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn assert_next_dataset<T>(
    ctx: &Context,
    input_dataset: T,
    transformations: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("AssertNextDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, transformations.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn assign<T>(
    ctx: &Context,
    ref_: T,
    value: T,
    validate_shape: bool,
    use_locking: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Assign").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, ref_.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, value.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("validate_shape").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), validate_shape as u8);

        let attr_name = CString::new("use_locking").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), use_locking as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn assign_add<T>(ctx: &Context, ref_: T, value: T, use_locking: bool) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("AssignAdd").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, ref_.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, value.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("use_locking").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), use_locking as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn assign_sub<T>(ctx: &Context, ref_: T, value: T, use_locking: bool) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("AssignSub").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, ref_.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, value.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("use_locking").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), use_locking as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn atan<T>(ctx: &Context, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Atan").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn atan2<T>(ctx: &Context, y: T, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Atan2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, y.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn atanh<T>(ctx: &Context, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Atanh").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn audio_spectrogram<T>(
    ctx: &Context,
    input: T,
    window_size: i64,
    stride: i64,
    magnitude_squared: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("AudioSpectrogram").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("window_size").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), window_size);

        let attr_name = CString::new("stride").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), stride);

        let attr_name = CString::new("magnitude_squared").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), magnitude_squared as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn audio_summary<T>(
    ctx: &Context,
    tag: T,
    tensor: T,
    sample_rate: f32,
    max_outputs: i64,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("AudioSummary").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, tag.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, tensor.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("sample_rate").unwrap();
        tf::TFE_OpSetAttrFloat(op, attr_name.as_ptr(), sample_rate);

        let attr_name = CString::new("max_outputs").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), max_outputs);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn audio_summary_v2<T>(
    ctx: &Context,
    tag: T,
    tensor: T,
    sample_rate: T,
    max_outputs: i64,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("AudioSummaryV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, tag.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, tensor.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, sample_rate.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("max_outputs").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), max_outputs);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn auto_shard_dataset<T>(
    ctx: &Context,
    input_dataset: T,
    num_workers: T,
    index: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
    auto_shard_policy: i64,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("AutoShardDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, num_workers.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, index.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        let attr_name = CString::new("auto_shard_policy").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), auto_shard_policy);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn avg_pool<T>(
    ctx: &Context,
    value: T,
    ksize: &Vec<i64>,
    strides: &Vec<i64>,
    padding: &String,
    data_format: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("AvgPool").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, value.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("ksize").unwrap();
        tf::TFE_OpSetAttrIntList(op, attr_name.as_ptr(), ksize.as_ptr(), ksize.len() as i32);

        let attr_name = CString::new("strides").unwrap();
        tf::TFE_OpSetAttrIntList(
            op,
            attr_name.as_ptr(),
            strides.as_ptr(),
            strides.len() as i32,
        );

        let attr_name = CString::new("padding").unwrap();
        let padding_cstr = padding.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            padding_cstr.as_ptr() as *mut c_void,
            padding.as_bytes().len() + 1,
        );

        let attr_name = CString::new("data_format").unwrap();
        let data_format_cstr = data_format.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            data_format_cstr.as_ptr() as *mut c_void,
            data_format.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn avg_pool3_d<T>(
    ctx: &Context,
    input: T,
    ksize: &Vec<i64>,
    strides: &Vec<i64>,
    padding: &String,
    data_format: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("AvgPool3D").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("ksize").unwrap();
        tf::TFE_OpSetAttrIntList(op, attr_name.as_ptr(), ksize.as_ptr(), ksize.len() as i32);

        let attr_name = CString::new("strides").unwrap();
        tf::TFE_OpSetAttrIntList(
            op,
            attr_name.as_ptr(),
            strides.as_ptr(),
            strides.len() as i32,
        );

        let attr_name = CString::new("padding").unwrap();
        let padding_cstr = padding.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            padding_cstr.as_ptr() as *mut c_void,
            padding.as_bytes().len() + 1,
        );

        let attr_name = CString::new("data_format").unwrap();
        let data_format_cstr = data_format.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            data_format_cstr.as_ptr() as *mut c_void,
            data_format.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn avg_pool3_d_grad<T>(
    ctx: &Context,
    orig_input_shape: T,
    grad: T,
    ksize: &Vec<i64>,
    strides: &Vec<i64>,
    padding: &String,
    data_format: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("AvgPool3DGrad").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, orig_input_shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, grad.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("ksize").unwrap();
        tf::TFE_OpSetAttrIntList(op, attr_name.as_ptr(), ksize.as_ptr(), ksize.len() as i32);

        let attr_name = CString::new("strides").unwrap();
        tf::TFE_OpSetAttrIntList(
            op,
            attr_name.as_ptr(),
            strides.as_ptr(),
            strides.len() as i32,
        );

        let attr_name = CString::new("padding").unwrap();
        let padding_cstr = padding.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            padding_cstr.as_ptr() as *mut c_void,
            padding.as_bytes().len() + 1,
        );

        let attr_name = CString::new("data_format").unwrap();
        let data_format_cstr = data_format.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            data_format_cstr.as_ptr() as *mut c_void,
            data_format.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn avg_pool_grad<T>(
    ctx: &Context,
    orig_input_shape: T,
    grad: T,
    ksize: &Vec<i64>,
    strides: &Vec<i64>,
    padding: &String,
    data_format: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("AvgPoolGrad").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, orig_input_shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, grad.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("ksize").unwrap();
        tf::TFE_OpSetAttrIntList(op, attr_name.as_ptr(), ksize.as_ptr(), ksize.len() as i32);

        let attr_name = CString::new("strides").unwrap();
        tf::TFE_OpSetAttrIntList(
            op,
            attr_name.as_ptr(),
            strides.as_ptr(),
            strides.len() as i32,
        );

        let attr_name = CString::new("padding").unwrap();
        let padding_cstr = padding.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            padding_cstr.as_ptr() as *mut c_void,
            padding.as_bytes().len() + 1,
        );

        let attr_name = CString::new("data_format").unwrap();
        let data_format_cstr = data_format.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            data_format_cstr.as_ptr() as *mut c_void,
            data_format.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn banded_triangular_solve<T>(
    ctx: &Context,
    matrix: T,
    rhs: T,
    lower: bool,
    adjoint: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("BandedTriangularSolve").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, matrix.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, rhs.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("lower").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), lower as u8);

        let attr_name = CString::new("adjoint").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), adjoint as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn barrier<T>(
    ctx: &Context,
    component_type_s: &Vec<DataType>,
    shapes: &Vec<Vec<i64>>,
    capacity: i64,
    container: &String,
    shared_name: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Barrier").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("component_type_s").unwrap();
        let component_type_s: Vec<tf::TF_DataType> =
            component_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            component_type_s.as_ptr(),
            component_type_s.len() as i32,
        );

        let mut shapes_values: Vec<*const i64> = shapes.into_iter().map(|v| v.as_ptr()).collect();
        let shapes_ndims: Vec<i32> = shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            shapes_values.as_mut_ptr(),
            shapes_ndims.as_ptr(),
            shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        let attr_name = CString::new("capacity").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), capacity);

        let attr_name = CString::new("container").unwrap();
        let container_cstr = container.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            container_cstr.as_ptr() as *mut c_void,
            container.as_bytes().len() + 1,
        );

        let attr_name = CString::new("shared_name").unwrap();
        let shared_name_cstr = shared_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            shared_name_cstr.as_ptr() as *mut c_void,
            shared_name.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn barrier_incomplete_size<T>(ctx: &Context, handle: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("BarrierIncompleteSize").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn barrier_ready_size<T>(ctx: &Context, handle: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("BarrierReadySize").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn batch_cholesky<T>(ctx: &Context, input: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("BatchCholesky").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn batch_cholesky_grad<T>(ctx: &Context, l: T, grad: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("BatchCholeskyGrad").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, l.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, grad.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn batch_dataset<T>(
    ctx: &Context,
    input_dataset: T,
    batch_size: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("BatchDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, batch_size.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn batch_dataset_v2<T>(
    ctx: &Context,
    input_dataset: T,
    batch_size: T,
    drop_remainder: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
    parallel_copy: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("BatchDatasetV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, batch_size.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, drop_remainder.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        let attr_name = CString::new("parallel_copy").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), parallel_copy as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn batch_f_f_t<T>(ctx: &Context, input: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("BatchFFT").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn batch_f_f_t2_d<T>(ctx: &Context, input: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("BatchFFT2D").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn batch_f_f_t3_d<T>(ctx: &Context, input: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("BatchFFT3D").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn batch_i_f_f_t<T>(ctx: &Context, input: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("BatchIFFT").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn batch_i_f_f_t2_d<T>(ctx: &Context, input: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("BatchIFFT2D").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn batch_i_f_f_t3_d<T>(ctx: &Context, input: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("BatchIFFT3D").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn batch_mat_mul<T>(ctx: &Context, x: T, y: T, adj_x: bool, adj_y: bool) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("BatchMatMul").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, y.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("adj_x").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), adj_x as u8);

        let attr_name = CString::new("adj_y").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), adj_y as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn batch_mat_mul_v2<T>(
    ctx: &Context,
    x: T,
    y: T,
    adj_x: bool,
    adj_y: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("BatchMatMulV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, y.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("adj_x").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), adj_x as u8);

        let attr_name = CString::new("adj_y").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), adj_y as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn batch_matrix_band_part<T>(
    ctx: &Context,
    input: T,
    num_lower: T,
    num_upper: T,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("BatchMatrixBandPart").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, num_lower.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, num_upper.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn batch_matrix_determinant<T>(ctx: &Context, input: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("BatchMatrixDeterminant").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn batch_matrix_diag<T>(ctx: &Context, diagonal: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("BatchMatrixDiag").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, diagonal.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn batch_matrix_diag_part<T>(ctx: &Context, input: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("BatchMatrixDiagPart").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn batch_matrix_inverse<T>(ctx: &Context, input: T, adjoint: bool) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("BatchMatrixInverse").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("adjoint").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), adjoint as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn batch_matrix_set_diag<T>(ctx: &Context, input: T, diagonal: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("BatchMatrixSetDiag").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, diagonal.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn batch_matrix_solve<T>(
    ctx: &Context,
    matrix: T,
    rhs: T,
    adjoint: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("BatchMatrixSolve").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, matrix.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, rhs.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("adjoint").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), adjoint as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn batch_matrix_solve_ls<T>(
    ctx: &Context,
    matrix: T,
    rhs: T,
    l2_regularizer: T,
    fast: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("BatchMatrixSolveLs").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, matrix.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, rhs.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, l2_regularizer.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("fast").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), fast as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn batch_matrix_triangular_solve<T>(
    ctx: &Context,
    matrix: T,
    rhs: T,
    lower: bool,
    adjoint: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("BatchMatrixTriangularSolve").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, matrix.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, rhs.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("lower").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), lower as u8);

        let attr_name = CString::new("adjoint").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), adjoint as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn batch_norm_with_global_normalization<T>(
    ctx: &Context,
    t: T,
    m: T,
    v: T,
    beta: T,
    gamma: T,
    variance_epsilon: f32,
    scale_after_normalization: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("BatchNormWithGlobalNormalization").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, t.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, m.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, v.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, beta.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, gamma.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("variance_epsilon").unwrap();
        tf::TFE_OpSetAttrFloat(op, attr_name.as_ptr(), variance_epsilon);

        let attr_name = CString::new("scale_after_normalization").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), scale_after_normalization as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn batch_self_adjoint_eig<T>(ctx: &Context, input: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("BatchSelfAdjointEig").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn batch_to_space<T>(
    ctx: &Context,
    input: T,
    crops: T,
    block_size: i64,
    Tidx: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("BatchToSpace").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, crops.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("block_size").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), block_size);

        let attr_name = CString::new("Tidx").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tidx.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn batch_to_space_n_d<T>(
    ctx: &Context,
    input: T,
    block_shape: T,
    crops: T,
    Tblock_shape: DataType,
    Tcrops: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("BatchToSpaceND").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, block_shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, crops.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tblock_shape").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tblock_shape.to_c());

        let attr_name = CString::new("Tcrops").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tcrops.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn bessel_i0<T>(ctx: &Context, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("BesselI0").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn bessel_i0e<T>(ctx: &Context, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("BesselI0e").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn bessel_i1<T>(ctx: &Context, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("BesselI1").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn bessel_i1e<T>(ctx: &Context, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("BesselI1e").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn bessel_j0<T>(ctx: &Context, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("BesselJ0").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn bessel_j1<T>(ctx: &Context, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("BesselJ1").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn bessel_k0<T>(ctx: &Context, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("BesselK0").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn bessel_k0e<T>(ctx: &Context, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("BesselK0e").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn bessel_k1<T>(ctx: &Context, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("BesselK1").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn bessel_k1e<T>(ctx: &Context, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("BesselK1e").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn bessel_y0<T>(ctx: &Context, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("BesselY0").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn bessel_y1<T>(ctx: &Context, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("BesselY1").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn betainc<T>(ctx: &Context, a: T, b: T, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Betainc").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, a.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, b.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn bias_add<T>(ctx: &Context, value: T, bias: T, data_format: &String) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("BiasAdd").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, value.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, bias.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("data_format").unwrap();
        let data_format_cstr = data_format.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            data_format_cstr.as_ptr() as *mut c_void,
            data_format.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn bias_add_grad<T>(
    ctx: &Context,
    out_backprop: T,
    data_format: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("BiasAddGrad").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, out_backprop.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("data_format").unwrap();
        let data_format_cstr = data_format.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            data_format_cstr.as_ptr() as *mut c_void,
            data_format.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn bias_add_v1<T>(ctx: &Context, value: T, bias: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("BiasAddV1").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, value.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, bias.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn bincount<T>(ctx: &Context, arr: T, size: T, weights: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Bincount").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, arr.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, size.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, weights.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn bitcast<T>(ctx: &Context, input: T, type_: DataType) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Bitcast").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("type_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), type_.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn bitwise_and<T>(ctx: &Context, x: T, y: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("BitwiseAnd").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, y.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn bitwise_or<T>(ctx: &Context, x: T, y: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("BitwiseOr").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, y.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn bitwise_xor<T>(ctx: &Context, x: T, y: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("BitwiseXor").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, y.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn boosted_trees_aggregate_stats<T>(
    ctx: &Context,
    node_ids: T,
    gradients: T,
    hessians: T,
    feature: T,
    max_splits: i64,
    num_buckets: i64,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("BoostedTreesAggregateStats").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, node_ids.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, gradients.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, hessians.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, feature.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("max_splits").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), max_splits);

        let attr_name = CString::new("num_buckets").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), num_buckets);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn boosted_trees_bucketize<T>(
    ctx: &Context,
    float_values: &Vec<T>,
    bucket_boundaries: &Vec<T>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("BoostedTreesBucketize").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        let mut float_values_handles: Vec<*mut tf::TFE_TensorHandle> = float_values
            .into_iter()
            .map(|t| t.to_handle().unwrap().inner)
            .collect();
        tf::TFE_OpAddInputList(
            op,
            float_values_handles.as_mut_ptr(),
            float_values.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        let mut bucket_boundaries_handles: Vec<*mut tf::TFE_TensorHandle> = bucket_boundaries
            .into_iter()
            .map(|t| t.to_handle().unwrap().inner)
            .collect();
        tf::TFE_OpAddInputList(
            op,
            bucket_boundaries_handles.as_mut_ptr(),
            bucket_boundaries.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("num_features").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), float_values.len() as i64);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn boosted_trees_center_bias<T>(
    ctx: &Context,
    tree_ensemble_handle: T,
    mean_gradients: T,
    mean_hessians: T,
    l1: T,
    l2: T,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("BoostedTreesCenterBias").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, tree_ensemble_handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, mean_gradients.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, mean_hessians.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, l1.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, l2.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn boosted_trees_ensemble_resource_handle_op<T>(
    ctx: &Context,
    container: &String,
    shared_name: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("BoostedTreesEnsembleResourceHandleOp").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("container").unwrap();
        let container_cstr = container.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            container_cstr.as_ptr() as *mut c_void,
            container.as_bytes().len() + 1,
        );

        let attr_name = CString::new("shared_name").unwrap();
        let shared_name_cstr = shared_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            shared_name_cstr.as_ptr() as *mut c_void,
            shared_name.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn boosted_trees_example_debug_outputs<T>(
    ctx: &Context,
    tree_ensemble_handle: T,
    bucketized_features: &Vec<T>,
    logits_dimension: i64,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("BoostedTreesExampleDebugOutputs").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, tree_ensemble_handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        let mut bucketized_features_handles: Vec<*mut tf::TFE_TensorHandle> = bucketized_features
            .into_iter()
            .map(|t| t.to_handle().unwrap().inner)
            .collect();
        tf::TFE_OpAddInputList(
            op,
            bucketized_features_handles.as_mut_ptr(),
            bucketized_features.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("num_bucketized_features").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), bucketized_features.len() as i64);

        let attr_name = CString::new("logits_dimension").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), logits_dimension);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn boosted_trees_flush_quantile_summaries<T>(
    ctx: &Context,
    quantile_stream_resource_handle: T,
    num_features: i64,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("BoostedTreesFlushQuantileSummaries").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(
            op,
            quantile_stream_resource_handle.to_handle()?.inner,
            status.inner,
        );
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("num_features").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), num_features);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn boosted_trees_make_quantile_summaries<T>(
    ctx: &Context,
    float_values: &Vec<T>,
    example_weights: T,
    epsilon: T,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("BoostedTreesMakeQuantileSummaries").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        let mut float_values_handles: Vec<*mut tf::TFE_TensorHandle> = float_values
            .into_iter()
            .map(|t| t.to_handle().unwrap().inner)
            .collect();
        tf::TFE_OpAddInputList(
            op,
            float_values_handles.as_mut_ptr(),
            float_values.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, example_weights.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, epsilon.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("num_features").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), float_values.len() as i64);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn boosted_trees_make_stats_summary<T>(
    ctx: &Context,
    node_ids: T,
    gradients: T,
    hessians: T,
    bucketized_features_list: &Vec<T>,
    max_splits: i64,
    num_buckets: i64,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("BoostedTreesMakeStatsSummary").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, node_ids.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, gradients.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, hessians.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        let mut bucketized_features_list_handles: Vec<*mut tf::TFE_TensorHandle> =
            bucketized_features_list
                .into_iter()
                .map(|t| t.to_handle().unwrap().inner)
                .collect();
        tf::TFE_OpAddInputList(
            op,
            bucketized_features_list_handles.as_mut_ptr(),
            bucketized_features_list.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("max_splits").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), max_splits);

        let attr_name = CString::new("num_buckets").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), num_buckets);

        let attr_name = CString::new("num_features").unwrap();
        tf::TFE_OpSetAttrInt(
            op,
            attr_name.as_ptr(),
            bucketized_features_list.len() as i64,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn boosted_trees_predict<T>(
    ctx: &Context,
    tree_ensemble_handle: T,
    bucketized_features: &Vec<T>,
    logits_dimension: i64,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("BoostedTreesPredict").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, tree_ensemble_handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        let mut bucketized_features_handles: Vec<*mut tf::TFE_TensorHandle> = bucketized_features
            .into_iter()
            .map(|t| t.to_handle().unwrap().inner)
            .collect();
        tf::TFE_OpAddInputList(
            op,
            bucketized_features_handles.as_mut_ptr(),
            bucketized_features.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("num_bucketized_features").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), bucketized_features.len() as i64);

        let attr_name = CString::new("logits_dimension").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), logits_dimension);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn boosted_trees_quantile_stream_resource_get_bucket_boundaries<T>(
    ctx: &Context,
    quantile_stream_resource_handle: T,
    num_features: i64,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name =
            CString::new("BoostedTreesQuantileStreamResourceGetBucketBoundaries").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(
            op,
            quantile_stream_resource_handle.to_handle()?.inner,
            status.inner,
        );
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("num_features").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), num_features);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn boosted_trees_quantile_stream_resource_handle_op<T>(
    ctx: &Context,
    container: &String,
    shared_name: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("BoostedTreesQuantileStreamResourceHandleOp").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("container").unwrap();
        let container_cstr = container.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            container_cstr.as_ptr() as *mut c_void,
            container.as_bytes().len() + 1,
        );

        let attr_name = CString::new("shared_name").unwrap();
        let shared_name_cstr = shared_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            shared_name_cstr.as_ptr() as *mut c_void,
            shared_name.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn broadcast_args<T>(ctx: &Context, s0: T, s1: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("BroadcastArgs").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, s0.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, s1.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn broadcast_to<T>(ctx: &Context, input: T, shape: T, Tidx: DataType) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("BroadcastTo").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tidx").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tidx.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn bucketize<T>(ctx: &Context, input: T, boundaries: &Vec<f32>) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Bucketize").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("boundaries").unwrap();
        tf::TFE_OpSetAttrFloatList(
            op,
            attr_name.as_ptr(),
            boundaries.as_ptr(),
            boundaries.len() as i32,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn bytes_produced_stats_dataset<T>(
    ctx: &Context,
    input_dataset: T,
    tag: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("BytesProducedStatsDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, tag.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn c_s_r_sparse_matrix_to_dense<T>(
    ctx: &Context,
    sparse_input: T,
    type_: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("CSRSparseMatrixToDense").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, sparse_input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("type_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), type_.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn c_s_v_dataset<T>(
    ctx: &Context,
    filenames: T,
    compression_type: T,
    buffer_size: T,
    header: T,
    field_delim: T,
    use_quote_delim: T,
    na_value: T,
    select_cols: T,
    record_defaults: &Vec<T>,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("CSVDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, filenames.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, compression_type.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, buffer_size.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, header.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, field_delim.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, use_quote_delim.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, na_value.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, select_cols.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        let mut record_defaults_handles: Vec<*mut tf::TFE_TensorHandle> = record_defaults
            .into_iter()
            .map(|t| t.to_handle().unwrap().inner)
            .collect();
        tf::TFE_OpAddInputList(
            op,
            record_defaults_handles.as_mut_ptr(),
            record_defaults.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn cache_dataset<T>(
    ctx: &Context,
    input_dataset: T,
    filename: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("CacheDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, filename.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn cache_dataset_v2<T>(
    ctx: &Context,
    input_dataset: T,
    filename: T,
    cache: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("CacheDatasetV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, filename.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, cache.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn cast<T>(
    ctx: &Context,
    x: T,
    SrcT: DataType,
    DstT: DataType,
    Truncate: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Cast").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("SrcT").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), SrcT.to_c());

        let attr_name = CString::new("DstT").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), DstT.to_c());

        let attr_name = CString::new("Truncate").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), Truncate as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn ceil<T>(ctx: &Context, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Ceil").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn check_numerics<T>(ctx: &Context, tensor: T, message: &String) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("CheckNumerics").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, tensor.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("message").unwrap();
        let message_cstr = message.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            message_cstr.as_ptr() as *mut c_void,
            message.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn check_numerics_v2<T>(ctx: &Context, tensor: T, message: &String) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("CheckNumericsV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, tensor.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("message").unwrap();
        let message_cstr = message.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            message_cstr.as_ptr() as *mut c_void,
            message.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn cholesky<T>(ctx: &Context, input: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Cholesky").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn cholesky_grad<T>(ctx: &Context, l: T, grad: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("CholeskyGrad").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, l.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, grad.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn choose_fastest_dataset<T>(
    ctx: &Context,
    input_datasets: &Vec<T>,
    num_experiments: i64,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ChooseFastestDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        let mut input_datasets_handles: Vec<*mut tf::TFE_TensorHandle> = input_datasets
            .into_iter()
            .map(|t| t.to_handle().unwrap().inner)
            .collect();
        tf::TFE_OpAddInputList(
            op,
            input_datasets_handles.as_mut_ptr(),
            input_datasets.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("N").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), input_datasets.len() as i64);

        let attr_name = CString::new("num_experiments").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), num_experiments);

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn clip_by_value<T>(
    ctx: &Context,
    t: T,
    clip_value_min: T,
    clip_value_max: T,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ClipByValue").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, t.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, clip_value_min.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, clip_value_max.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn collective_bcast_recv<T>(
    ctx: &Context,
    group_size: i64,
    group_key: i64,
    instance_key: i64,
    shape: &Vec<i64>,
    communication_hint: &String,
    timeout_seconds: f32,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("CollectiveBcastRecv").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("group_size").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), group_size);

        let attr_name = CString::new("group_key").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), group_key);

        let attr_name = CString::new("instance_key").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), instance_key);

        let attr_name = CString::new("shape").unwrap();
        tf::TFE_OpSetAttrShape(
            op,
            attr_name.as_ptr(),
            shape.as_ptr(),
            shape.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        let attr_name = CString::new("communication_hint").unwrap();
        let communication_hint_cstr = communication_hint.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            communication_hint_cstr.as_ptr() as *mut c_void,
            communication_hint.as_bytes().len() + 1,
        );

        let attr_name = CString::new("timeout_seconds").unwrap();
        tf::TFE_OpSetAttrFloat(op, attr_name.as_ptr(), timeout_seconds);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn collective_bcast_send<T>(
    ctx: &Context,
    input: T,
    group_size: i64,
    group_key: i64,
    instance_key: i64,
    shape: &Vec<i64>,
    communication_hint: &String,
    timeout_seconds: f32,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("CollectiveBcastSend").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("group_size").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), group_size);

        let attr_name = CString::new("group_key").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), group_key);

        let attr_name = CString::new("instance_key").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), instance_key);

        let attr_name = CString::new("shape").unwrap();
        tf::TFE_OpSetAttrShape(
            op,
            attr_name.as_ptr(),
            shape.as_ptr(),
            shape.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        let attr_name = CString::new("communication_hint").unwrap();
        let communication_hint_cstr = communication_hint.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            communication_hint_cstr.as_ptr() as *mut c_void,
            communication_hint.as_bytes().len() + 1,
        );

        let attr_name = CString::new("timeout_seconds").unwrap();
        tf::TFE_OpSetAttrFloat(op, attr_name.as_ptr(), timeout_seconds);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn collective_gather<T>(
    ctx: &Context,
    input: T,
    group_size: i64,
    group_key: i64,
    instance_key: i64,
    shape: &Vec<i64>,
    communication_hint: &String,
    timeout_seconds: f32,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("CollectiveGather").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("group_size").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), group_size);

        let attr_name = CString::new("group_key").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), group_key);

        let attr_name = CString::new("instance_key").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), instance_key);

        let attr_name = CString::new("shape").unwrap();
        tf::TFE_OpSetAttrShape(
            op,
            attr_name.as_ptr(),
            shape.as_ptr(),
            shape.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        let attr_name = CString::new("communication_hint").unwrap();
        let communication_hint_cstr = communication_hint.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            communication_hint_cstr.as_ptr() as *mut c_void,
            communication_hint.as_bytes().len() + 1,
        );

        let attr_name = CString::new("timeout_seconds").unwrap();
        tf::TFE_OpSetAttrFloat(op, attr_name.as_ptr(), timeout_seconds);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn collective_permute<T>(
    ctx: &Context,
    input: T,
    source_target_pairs: T,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("CollectivePermute").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, source_target_pairs.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn collective_reduce<T>(
    ctx: &Context,
    input: T,
    group_size: i64,
    group_key: i64,
    instance_key: i64,
    merge_op: &String,
    final_op: &String,
    subdiv_offsets: &Vec<i64>,
    wait_for: &Vec<i64>,
    communication_hint: &String,
    timeout_seconds: f32,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("CollectiveReduce").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("group_size").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), group_size);

        let attr_name = CString::new("group_key").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), group_key);

        let attr_name = CString::new("instance_key").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), instance_key);

        let attr_name = CString::new("merge_op").unwrap();
        let merge_op_cstr = merge_op.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            merge_op_cstr.as_ptr() as *mut c_void,
            merge_op.as_bytes().len() + 1,
        );

        let attr_name = CString::new("final_op").unwrap();
        let final_op_cstr = final_op.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            final_op_cstr.as_ptr() as *mut c_void,
            final_op.as_bytes().len() + 1,
        );

        let attr_name = CString::new("subdiv_offsets").unwrap();
        tf::TFE_OpSetAttrIntList(
            op,
            attr_name.as_ptr(),
            subdiv_offsets.as_ptr(),
            subdiv_offsets.len() as i32,
        );

        let attr_name = CString::new("wait_for").unwrap();
        tf::TFE_OpSetAttrIntList(
            op,
            attr_name.as_ptr(),
            wait_for.as_ptr(),
            wait_for.len() as i32,
        );

        let attr_name = CString::new("communication_hint").unwrap();
        let communication_hint_cstr = communication_hint.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            communication_hint_cstr.as_ptr() as *mut c_void,
            communication_hint.as_bytes().len() + 1,
        );

        let attr_name = CString::new("timeout_seconds").unwrap();
        tf::TFE_OpSetAttrFloat(op, attr_name.as_ptr(), timeout_seconds);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn complex<T>(ctx: &Context, real: T, imag: T, Tout: DataType) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Complex").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, real.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, imag.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tout").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tout.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn complex_abs<T>(ctx: &Context, x: T, Tout: DataType) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ComplexAbs").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tout").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tout.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn compress_element<T>(
    ctx: &Context,
    components: &Vec<T>,
    input_type_s: &Vec<DataType>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("CompressElement").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        let mut components_handles: Vec<*mut tf::TFE_TensorHandle> = components
            .into_iter()
            .map(|t| t.to_handle().unwrap().inner)
            .collect();
        tf::TFE_OpAddInputList(
            op,
            components_handles.as_mut_ptr(),
            components.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("input_type_s").unwrap();
        let input_type_s: Vec<tf::TF_DataType> =
            input_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            input_type_s.as_ptr(),
            input_type_s.len() as i32,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn concat<T>(ctx: &Context, concat_dim: T, values: &Vec<T>) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Concat").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, concat_dim.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        let mut values_handles: Vec<*mut tf::TFE_TensorHandle> = values
            .into_iter()
            .map(|t| t.to_handle().unwrap().inner)
            .collect();
        tf::TFE_OpAddInputList(
            op,
            values_handles.as_mut_ptr(),
            values.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("N").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), values.len() as i64);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn concat_offset<T>(ctx: &Context, concat_dim: T, shape: &Vec<T>) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ConcatOffset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, concat_dim.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        let mut shape_handles: Vec<*mut tf::TFE_TensorHandle> = shape
            .into_iter()
            .map(|t| t.to_handle().unwrap().inner)
            .collect();
        tf::TFE_OpAddInputList(
            op,
            shape_handles.as_mut_ptr(),
            shape.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("N").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), shape.len() as i64);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn concat_v2<T>(ctx: &Context, values: &Vec<T>, axis: T, Tidx: DataType) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ConcatV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        let mut values_handles: Vec<*mut tf::TFE_TensorHandle> = values
            .into_iter()
            .map(|t| t.to_handle().unwrap().inner)
            .collect();
        tf::TFE_OpAddInputList(
            op,
            values_handles.as_mut_ptr(),
            values.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, axis.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("N").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), values.len() as i64);

        let attr_name = CString::new("Tidx").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tidx.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn concatenate_dataset<T>(
    ctx: &Context,
    input_dataset: T,
    another_dataset: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ConcatenateDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, another_dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn conditional_accumulator<T>(
    ctx: &Context,
    dtype_: DataType,
    shape: &Vec<i64>,
    container: &String,
    shared_name: &String,
    reduction_type_: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ConditionalAccumulator").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), dtype_.to_c());

        let attr_name = CString::new("shape").unwrap();
        tf::TFE_OpSetAttrShape(
            op,
            attr_name.as_ptr(),
            shape.as_ptr(),
            shape.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        let attr_name = CString::new("container").unwrap();
        let container_cstr = container.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            container_cstr.as_ptr() as *mut c_void,
            container.as_bytes().len() + 1,
        );

        let attr_name = CString::new("shared_name").unwrap();
        let shared_name_cstr = shared_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            shared_name_cstr.as_ptr() as *mut c_void,
            shared_name.as_bytes().len() + 1,
        );

        let attr_name = CString::new("reduction_type_").unwrap();
        let reduction_type__cstr = reduction_type_.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            reduction_type__cstr.as_ptr() as *mut c_void,
            reduction_type_.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn configure_distributed_t_p_u<T>(
    ctx: &Context,
    embedding_config: &String,
    tpu_embedding_config: &String,
    is_global_init: bool,
    enable_whole_mesh_compilations: bool,
    compilation_failure_closes_chips: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ConfigureDistributedTPU").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("embedding_config").unwrap();
        let embedding_config_cstr = embedding_config.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            embedding_config_cstr.as_ptr() as *mut c_void,
            embedding_config.as_bytes().len() + 1,
        );

        let attr_name = CString::new("tpu_embedding_config").unwrap();
        let tpu_embedding_config_cstr = tpu_embedding_config.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            tpu_embedding_config_cstr.as_ptr() as *mut c_void,
            tpu_embedding_config.as_bytes().len() + 1,
        );

        let attr_name = CString::new("is_global_init").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), is_global_init as u8);

        let attr_name = CString::new("enable_whole_mesh_compilations").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), enable_whole_mesh_compilations as u8);

        let attr_name = CString::new("compilation_failure_closes_chips").unwrap();
        tf::TFE_OpSetAttrBool(
            op,
            attr_name.as_ptr(),
            compilation_failure_closes_chips as u8,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn conj<T>(ctx: &Context, input: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Conj").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn conjugate_transpose<T>(ctx: &Context, x: T, perm: T, Tperm: DataType) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ConjugateTranspose").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, perm.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tperm").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tperm.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn const_tensor<T, D>(
    ctx: &Context,
    value: &Tensor<D>,
    dtype_: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
    D: TensorType,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Const").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("value").unwrap();
        tf::TFE_OpSetAttrTensor(op, attr_name.as_ptr(), value.inner().unwrap(), status.inner);
        // status_check(context::get_status());

        let attr_name = CString::new("dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), dtype_.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn conv2_d<T>(
    ctx: &Context,
    input: T,
    filter: T,
    strides: &Vec<i64>,
    padding: &String,
    explicit_paddings: &Vec<i64>,
    dilations: &Vec<i64>,
    use_cudnn_on_gpu: bool,
    data_format: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Conv2D").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, filter.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("strides").unwrap();
        tf::TFE_OpSetAttrIntList(
            op,
            attr_name.as_ptr(),
            strides.as_ptr(),
            strides.len() as i32,
        );

        let attr_name = CString::new("padding").unwrap();
        let padding_cstr = padding.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            padding_cstr.as_ptr() as *mut c_void,
            padding.as_bytes().len() + 1,
        );

        let attr_name = CString::new("explicit_paddings").unwrap();
        tf::TFE_OpSetAttrIntList(
            op,
            attr_name.as_ptr(),
            explicit_paddings.as_ptr(),
            explicit_paddings.len() as i32,
        );

        let attr_name = CString::new("dilations").unwrap();
        tf::TFE_OpSetAttrIntList(
            op,
            attr_name.as_ptr(),
            dilations.as_ptr(),
            dilations.len() as i32,
        );

        let attr_name = CString::new("use_cudnn_on_gpu").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), use_cudnn_on_gpu as u8);

        let attr_name = CString::new("data_format").unwrap();
        let data_format_cstr = data_format.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            data_format_cstr.as_ptr() as *mut c_void,
            data_format.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn conv2_d_backprop_filter<T>(
    ctx: &Context,
    input: T,
    filter_sizes: T,
    out_backprop: T,
    strides: &Vec<i64>,
    padding: &String,
    explicit_paddings: &Vec<i64>,
    dilations: &Vec<i64>,
    use_cudnn_on_gpu: bool,
    data_format: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Conv2DBackpropFilter").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, filter_sizes.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, out_backprop.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("strides").unwrap();
        tf::TFE_OpSetAttrIntList(
            op,
            attr_name.as_ptr(),
            strides.as_ptr(),
            strides.len() as i32,
        );

        let attr_name = CString::new("padding").unwrap();
        let padding_cstr = padding.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            padding_cstr.as_ptr() as *mut c_void,
            padding.as_bytes().len() + 1,
        );

        let attr_name = CString::new("explicit_paddings").unwrap();
        tf::TFE_OpSetAttrIntList(
            op,
            attr_name.as_ptr(),
            explicit_paddings.as_ptr(),
            explicit_paddings.len() as i32,
        );

        let attr_name = CString::new("dilations").unwrap();
        tf::TFE_OpSetAttrIntList(
            op,
            attr_name.as_ptr(),
            dilations.as_ptr(),
            dilations.len() as i32,
        );

        let attr_name = CString::new("use_cudnn_on_gpu").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), use_cudnn_on_gpu as u8);

        let attr_name = CString::new("data_format").unwrap();
        let data_format_cstr = data_format.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            data_format_cstr.as_ptr() as *mut c_void,
            data_format.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn conv2_d_backprop_input<T>(
    ctx: &Context,
    input_sizes: T,
    filter: T,
    out_backprop: T,
    strides: &Vec<i64>,
    padding: &String,
    explicit_paddings: &Vec<i64>,
    dilations: &Vec<i64>,
    use_cudnn_on_gpu: bool,
    data_format: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Conv2DBackpropInput").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_sizes.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, filter.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, out_backprop.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("strides").unwrap();
        tf::TFE_OpSetAttrIntList(
            op,
            attr_name.as_ptr(),
            strides.as_ptr(),
            strides.len() as i32,
        );

        let attr_name = CString::new("padding").unwrap();
        let padding_cstr = padding.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            padding_cstr.as_ptr() as *mut c_void,
            padding.as_bytes().len() + 1,
        );

        let attr_name = CString::new("explicit_paddings").unwrap();
        tf::TFE_OpSetAttrIntList(
            op,
            attr_name.as_ptr(),
            explicit_paddings.as_ptr(),
            explicit_paddings.len() as i32,
        );

        let attr_name = CString::new("dilations").unwrap();
        tf::TFE_OpSetAttrIntList(
            op,
            attr_name.as_ptr(),
            dilations.as_ptr(),
            dilations.len() as i32,
        );

        let attr_name = CString::new("use_cudnn_on_gpu").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), use_cudnn_on_gpu as u8);

        let attr_name = CString::new("data_format").unwrap();
        let data_format_cstr = data_format.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            data_format_cstr.as_ptr() as *mut c_void,
            data_format.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn conv3_d<T>(
    ctx: &Context,
    input: T,
    filter: T,
    strides: &Vec<i64>,
    padding: &String,
    dilations: &Vec<i64>,
    data_format: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Conv3D").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, filter.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("strides").unwrap();
        tf::TFE_OpSetAttrIntList(
            op,
            attr_name.as_ptr(),
            strides.as_ptr(),
            strides.len() as i32,
        );

        let attr_name = CString::new("padding").unwrap();
        let padding_cstr = padding.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            padding_cstr.as_ptr() as *mut c_void,
            padding.as_bytes().len() + 1,
        );

        let attr_name = CString::new("dilations").unwrap();
        tf::TFE_OpSetAttrIntList(
            op,
            attr_name.as_ptr(),
            dilations.as_ptr(),
            dilations.len() as i32,
        );

        let attr_name = CString::new("data_format").unwrap();
        let data_format_cstr = data_format.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            data_format_cstr.as_ptr() as *mut c_void,
            data_format.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn conv3_d_backprop_filter<T>(
    ctx: &Context,
    input: T,
    filter: T,
    out_backprop: T,
    strides: &Vec<i64>,
    padding: &String,
    dilations: &Vec<i64>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Conv3DBackpropFilter").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, filter.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, out_backprop.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("strides").unwrap();
        tf::TFE_OpSetAttrIntList(
            op,
            attr_name.as_ptr(),
            strides.as_ptr(),
            strides.len() as i32,
        );

        let attr_name = CString::new("padding").unwrap();
        let padding_cstr = padding.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            padding_cstr.as_ptr() as *mut c_void,
            padding.as_bytes().len() + 1,
        );

        let attr_name = CString::new("dilations").unwrap();
        tf::TFE_OpSetAttrIntList(
            op,
            attr_name.as_ptr(),
            dilations.as_ptr(),
            dilations.len() as i32,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn conv3_d_backprop_filter_v2<T>(
    ctx: &Context,
    input: T,
    filter_sizes: T,
    out_backprop: T,
    strides: &Vec<i64>,
    padding: &String,
    dilations: &Vec<i64>,
    data_format: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Conv3DBackpropFilterV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, filter_sizes.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, out_backprop.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("strides").unwrap();
        tf::TFE_OpSetAttrIntList(
            op,
            attr_name.as_ptr(),
            strides.as_ptr(),
            strides.len() as i32,
        );

        let attr_name = CString::new("padding").unwrap();
        let padding_cstr = padding.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            padding_cstr.as_ptr() as *mut c_void,
            padding.as_bytes().len() + 1,
        );

        let attr_name = CString::new("dilations").unwrap();
        tf::TFE_OpSetAttrIntList(
            op,
            attr_name.as_ptr(),
            dilations.as_ptr(),
            dilations.len() as i32,
        );

        let attr_name = CString::new("data_format").unwrap();
        let data_format_cstr = data_format.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            data_format_cstr.as_ptr() as *mut c_void,
            data_format.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn conv3_d_backprop_input<T>(
    ctx: &Context,
    input: T,
    filter: T,
    out_backprop: T,
    strides: &Vec<i64>,
    padding: &String,
    dilations: &Vec<i64>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Conv3DBackpropInput").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, filter.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, out_backprop.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("strides").unwrap();
        tf::TFE_OpSetAttrIntList(
            op,
            attr_name.as_ptr(),
            strides.as_ptr(),
            strides.len() as i32,
        );

        let attr_name = CString::new("padding").unwrap();
        let padding_cstr = padding.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            padding_cstr.as_ptr() as *mut c_void,
            padding.as_bytes().len() + 1,
        );

        let attr_name = CString::new("dilations").unwrap();
        tf::TFE_OpSetAttrIntList(
            op,
            attr_name.as_ptr(),
            dilations.as_ptr(),
            dilations.len() as i32,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn conv3_d_backprop_input_v2<T>(
    ctx: &Context,
    input_sizes: T,
    filter: T,
    out_backprop: T,
    strides: &Vec<i64>,
    padding: &String,
    dilations: &Vec<i64>,
    data_format: &String,
    Tshape: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Conv3DBackpropInputV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_sizes.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, filter.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, out_backprop.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("strides").unwrap();
        tf::TFE_OpSetAttrIntList(
            op,
            attr_name.as_ptr(),
            strides.as_ptr(),
            strides.len() as i32,
        );

        let attr_name = CString::new("padding").unwrap();
        let padding_cstr = padding.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            padding_cstr.as_ptr() as *mut c_void,
            padding.as_bytes().len() + 1,
        );

        let attr_name = CString::new("dilations").unwrap();
        tf::TFE_OpSetAttrIntList(
            op,
            attr_name.as_ptr(),
            dilations.as_ptr(),
            dilations.len() as i32,
        );

        let attr_name = CString::new("data_format").unwrap();
        let data_format_cstr = data_format.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            data_format_cstr.as_ptr() as *mut c_void,
            data_format.as_bytes().len() + 1,
        );

        let attr_name = CString::new("Tshape").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tshape.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn copy<T>(
    ctx: &Context,
    input: T,
    debug_ops_spec: &Vec<String>,
    tensor_name: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Copy").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let debug_ops_spec_cstr: Vec<CString> = debug_ops_spec
            .into_iter()
            .map(|v| CString::new(v.as_bytes()).unwrap())
            .collect();
        let debug_ops_spec_ptr: Vec<*const c_void> = debug_ops_spec_cstr
            .as_slice()
            .into_iter()
            .map(|v| v.as_ptr() as *const c_void)
            .collect();
        let debug_ops_spec_sizes: Vec<usize> = debug_ops_spec_cstr
            .as_slice()
            .into_iter()
            .map(|v| v.as_bytes().len())
            .collect();
        let attr_name = CString::new("debug_ops_spec").unwrap();
        tf::TFE_OpSetAttrStringList(
            op,
            attr_name.as_ptr(),
            debug_ops_spec_ptr.as_ptr(),
            debug_ops_spec_sizes.as_ptr(),
            debug_ops_spec.len() as i32,
        );

        let attr_name = CString::new("tensor_name").unwrap();
        let tensor_name_cstr = tensor_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            tensor_name_cstr.as_ptr() as *mut c_void,
            tensor_name.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn copy_host<T>(
    ctx: &Context,
    input: T,
    debug_ops_spec: &Vec<String>,
    tensor_name: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("CopyHost").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let debug_ops_spec_cstr: Vec<CString> = debug_ops_spec
            .into_iter()
            .map(|v| CString::new(v.as_bytes()).unwrap())
            .collect();
        let debug_ops_spec_ptr: Vec<*const c_void> = debug_ops_spec_cstr
            .as_slice()
            .into_iter()
            .map(|v| v.as_ptr() as *const c_void)
            .collect();
        let debug_ops_spec_sizes: Vec<usize> = debug_ops_spec_cstr
            .as_slice()
            .into_iter()
            .map(|v| v.as_bytes().len())
            .collect();
        let attr_name = CString::new("debug_ops_spec").unwrap();
        tf::TFE_OpSetAttrStringList(
            op,
            attr_name.as_ptr(),
            debug_ops_spec_ptr.as_ptr(),
            debug_ops_spec_sizes.as_ptr(),
            debug_ops_spec.len() as i32,
        );

        let attr_name = CString::new("tensor_name").unwrap();
        let tensor_name_cstr = tensor_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            tensor_name_cstr.as_ptr() as *mut c_void,
            tensor_name.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn cos<T>(ctx: &Context, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Cos").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn cosh<T>(ctx: &Context, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Cosh").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn count_up_to<T>(ctx: &Context, ref_: T, limit: i64) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("CountUpTo").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, ref_.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("limit").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), limit);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn crop_and_resize<T>(
    ctx: &Context,
    image: T,
    boxes: T,
    box_ind: T,
    crop_size: T,
    method: &String,
    extrapolation_value: f32,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("CropAndResize").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, image.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, boxes.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, box_ind.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, crop_size.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("method").unwrap();
        let method_cstr = method.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            method_cstr.as_ptr() as *mut c_void,
            method.as_bytes().len() + 1,
        );

        let attr_name = CString::new("extrapolation_value").unwrap();
        tf::TFE_OpSetAttrFloat(op, attr_name.as_ptr(), extrapolation_value);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn crop_and_resize_grad_boxes<T>(
    ctx: &Context,
    grads: T,
    image: T,
    boxes: T,
    box_ind: T,
    method: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("CropAndResizeGradBoxes").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, grads.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, image.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, boxes.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, box_ind.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("method").unwrap();
        let method_cstr = method.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            method_cstr.as_ptr() as *mut c_void,
            method.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn crop_and_resize_grad_image<T>(
    ctx: &Context,
    grads: T,
    boxes: T,
    box_ind: T,
    image_size: T,
    method: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("CropAndResizeGradImage").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, grads.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, boxes.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, box_ind.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, image_size.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("method").unwrap();
        let method_cstr = method.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            method_cstr.as_ptr() as *mut c_void,
            method.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn cross<T>(ctx: &Context, a: T, b: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Cross").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, a.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, b.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn cross_replica_sum<T>(ctx: &Context, input: T, group_assignment: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("CrossReplicaSum").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, group_assignment.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn cudnn_r_n_n_canonical_to_params<T>(
    ctx: &Context,
    num_layers: T,
    num_units: T,
    input_size: T,
    weights: &Vec<T>,
    biases: &Vec<T>,
    rnn_mode: &String,
    input_mode: &String,
    direction: &String,
    dropout: f32,
    seed: i64,
    seed2: i64,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("CudnnRNNCanonicalToParams").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, num_layers.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, num_units.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, input_size.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        let mut weights_handles: Vec<*mut tf::TFE_TensorHandle> = weights
            .into_iter()
            .map(|t| t.to_handle().unwrap().inner)
            .collect();
        tf::TFE_OpAddInputList(
            op,
            weights_handles.as_mut_ptr(),
            weights.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        let mut biases_handles: Vec<*mut tf::TFE_TensorHandle> = biases
            .into_iter()
            .map(|t| t.to_handle().unwrap().inner)
            .collect();
        tf::TFE_OpAddInputList(
            op,
            biases_handles.as_mut_ptr(),
            biases.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("num_params").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), weights.len() as i64);

        let attr_name = CString::new("rnn_mode").unwrap();
        let rnn_mode_cstr = rnn_mode.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            rnn_mode_cstr.as_ptr() as *mut c_void,
            rnn_mode.as_bytes().len() + 1,
        );

        let attr_name = CString::new("input_mode").unwrap();
        let input_mode_cstr = input_mode.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            input_mode_cstr.as_ptr() as *mut c_void,
            input_mode.as_bytes().len() + 1,
        );

        let attr_name = CString::new("direction").unwrap();
        let direction_cstr = direction.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            direction_cstr.as_ptr() as *mut c_void,
            direction.as_bytes().len() + 1,
        );

        let attr_name = CString::new("dropout").unwrap();
        tf::TFE_OpSetAttrFloat(op, attr_name.as_ptr(), dropout);

        let attr_name = CString::new("seed").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), seed);

        let attr_name = CString::new("seed2").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), seed2);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn cudnn_r_n_n_canonical_to_params_v2<T>(
    ctx: &Context,
    num_layers: T,
    num_units: T,
    input_size: T,
    weights: &Vec<T>,
    biases: &Vec<T>,
    rnn_mode: &String,
    input_mode: &String,
    direction: &String,
    dropout: f32,
    seed: i64,
    seed2: i64,
    num_proj: i64,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("CudnnRNNCanonicalToParamsV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, num_layers.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, num_units.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, input_size.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        let mut weights_handles: Vec<*mut tf::TFE_TensorHandle> = weights
            .into_iter()
            .map(|t| t.to_handle().unwrap().inner)
            .collect();
        tf::TFE_OpAddInputList(
            op,
            weights_handles.as_mut_ptr(),
            weights.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        let mut biases_handles: Vec<*mut tf::TFE_TensorHandle> = biases
            .into_iter()
            .map(|t| t.to_handle().unwrap().inner)
            .collect();
        tf::TFE_OpAddInputList(
            op,
            biases_handles.as_mut_ptr(),
            biases.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("num_params_weights").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), weights.len() as i64);

        let attr_name = CString::new("num_params_biases").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), biases.len() as i64);

        let attr_name = CString::new("rnn_mode").unwrap();
        let rnn_mode_cstr = rnn_mode.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            rnn_mode_cstr.as_ptr() as *mut c_void,
            rnn_mode.as_bytes().len() + 1,
        );

        let attr_name = CString::new("input_mode").unwrap();
        let input_mode_cstr = input_mode.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            input_mode_cstr.as_ptr() as *mut c_void,
            input_mode.as_bytes().len() + 1,
        );

        let attr_name = CString::new("direction").unwrap();
        let direction_cstr = direction.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            direction_cstr.as_ptr() as *mut c_void,
            direction.as_bytes().len() + 1,
        );

        let attr_name = CString::new("dropout").unwrap();
        tf::TFE_OpSetAttrFloat(op, attr_name.as_ptr(), dropout);

        let attr_name = CString::new("seed").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), seed);

        let attr_name = CString::new("seed2").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), seed2);

        let attr_name = CString::new("num_proj").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), num_proj);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn cudnn_r_n_n_params_size<T>(
    ctx: &Context,
    num_layers: T,
    num_units: T,
    input_size: T,
    S: DataType,
    rnn_mode: &String,
    input_mode: &String,
    direction: &String,
    dropout: f32,
    seed: i64,
    seed2: i64,
    num_proj: i64,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("CudnnRNNParamsSize").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, num_layers.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, num_units.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, input_size.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("S").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), S.to_c());

        let attr_name = CString::new("rnn_mode").unwrap();
        let rnn_mode_cstr = rnn_mode.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            rnn_mode_cstr.as_ptr() as *mut c_void,
            rnn_mode.as_bytes().len() + 1,
        );

        let attr_name = CString::new("input_mode").unwrap();
        let input_mode_cstr = input_mode.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            input_mode_cstr.as_ptr() as *mut c_void,
            input_mode.as_bytes().len() + 1,
        );

        let attr_name = CString::new("direction").unwrap();
        let direction_cstr = direction.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            direction_cstr.as_ptr() as *mut c_void,
            direction.as_bytes().len() + 1,
        );

        let attr_name = CString::new("dropout").unwrap();
        tf::TFE_OpSetAttrFloat(op, attr_name.as_ptr(), dropout);

        let attr_name = CString::new("seed").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), seed);

        let attr_name = CString::new("seed2").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), seed2);

        let attr_name = CString::new("num_proj").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), num_proj);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn cumprod<T>(
    ctx: &Context,
    x: T,
    axis: T,
    exclusive: bool,
    reverse: bool,
    Tidx: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Cumprod").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, axis.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("exclusive").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), exclusive as u8);

        let attr_name = CString::new("reverse").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), reverse as u8);

        let attr_name = CString::new("Tidx").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tidx.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn cumsum<T>(
    ctx: &Context,
    x: T,
    axis: T,
    exclusive: bool,
    reverse: bool,
    Tidx: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Cumsum").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, axis.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("exclusive").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), exclusive as u8);

        let attr_name = CString::new("reverse").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), reverse as u8);

        let attr_name = CString::new("Tidx").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tidx.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn cumulative_logsumexp<T>(
    ctx: &Context,
    x: T,
    axis: T,
    exclusive: bool,
    reverse: bool,
    Tidx: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("CumulativeLogsumexp").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, axis.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("exclusive").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), exclusive as u8);

        let attr_name = CString::new("reverse").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), reverse as u8);

        let attr_name = CString::new("Tidx").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tidx.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn data_format_dim_map<T>(
    ctx: &Context,
    x: T,
    src_format: &String,
    dst_format: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("DataFormatDimMap").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("src_format").unwrap();
        let src_format_cstr = src_format.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            src_format_cstr.as_ptr() as *mut c_void,
            src_format.as_bytes().len() + 1,
        );

        let attr_name = CString::new("dst_format").unwrap();
        let dst_format_cstr = dst_format.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            dst_format_cstr.as_ptr() as *mut c_void,
            dst_format.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn data_format_vec_permute<T>(
    ctx: &Context,
    x: T,
    src_format: &String,
    dst_format: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("DataFormatVecPermute").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("src_format").unwrap();
        let src_format_cstr = src_format.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            src_format_cstr.as_ptr() as *mut c_void,
            src_format.as_bytes().len() + 1,
        );

        let attr_name = CString::new("dst_format").unwrap();
        let dst_format_cstr = dst_format.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            dst_format_cstr.as_ptr() as *mut c_void,
            dst_format.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn data_service_dataset<T>(
    ctx: &Context,
    dataset_id: T,
    processing_mode: T,
    address: T,
    protocol: T,
    job_name: T,
    max_outstanding_requests: T,
    iteration_counter: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
    task_refresh_interval_hint_ms: i64,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("DataServiceDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, dataset_id.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, processing_mode.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, address.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, protocol.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, job_name.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(
            op,
            max_outstanding_requests.to_handle()?.inner,
            status.inner,
        );
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, iteration_counter.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        let attr_name = CString::new("task_refresh_interval_hint_ms").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), task_refresh_interval_hint_ms);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn dataset_cardinality<T>(ctx: &Context, input_dataset: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("DatasetCardinality").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn dataset_from_graph<T>(ctx: &Context, graph_def: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("DatasetFromGraph").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, graph_def.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn dataset_to_graph<T>(
    ctx: &Context,
    input_dataset: T,
    stateful_whitelist: &Vec<String>,
    allow_stateful: bool,
    strip_device_assignment: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("DatasetToGraph").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let stateful_whitelist_cstr: Vec<CString> = stateful_whitelist
            .into_iter()
            .map(|v| CString::new(v.as_bytes()).unwrap())
            .collect();
        let stateful_whitelist_ptr: Vec<*const c_void> = stateful_whitelist_cstr
            .as_slice()
            .into_iter()
            .map(|v| v.as_ptr() as *const c_void)
            .collect();
        let stateful_whitelist_sizes: Vec<usize> = stateful_whitelist_cstr
            .as_slice()
            .into_iter()
            .map(|v| v.as_bytes().len())
            .collect();
        let attr_name = CString::new("stateful_whitelist").unwrap();
        tf::TFE_OpSetAttrStringList(
            op,
            attr_name.as_ptr(),
            stateful_whitelist_ptr.as_ptr(),
            stateful_whitelist_sizes.as_ptr(),
            stateful_whitelist.len() as i32,
        );

        let attr_name = CString::new("allow_stateful").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), allow_stateful as u8);

        let attr_name = CString::new("strip_device_assignment").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), strip_device_assignment as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn dataset_to_graph_v2<T>(
    ctx: &Context,
    input_dataset: T,
    external_state_policy: i64,
    strip_device_assignment: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("DatasetToGraphV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("external_state_policy").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), external_state_policy);

        let attr_name = CString::new("strip_device_assignment").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), strip_device_assignment as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn dataset_to_single_element<T>(
    ctx: &Context,
    dataset: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("DatasetToSingleElement").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn dawsn<T>(ctx: &Context, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Dawsn").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn debug_gradient_identity<T>(ctx: &Context, input: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("DebugGradientIdentity").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn debug_gradient_ref_identity<T>(ctx: &Context, input: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("DebugGradientRefIdentity").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn debug_identity<T>(
    ctx: &Context,
    input: T,
    debug_urls: &Vec<String>,
    device_name: &String,
    tensor_name: &String,
    gated_grpc: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("DebugIdentity").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let debug_urls_cstr: Vec<CString> = debug_urls
            .into_iter()
            .map(|v| CString::new(v.as_bytes()).unwrap())
            .collect();
        let debug_urls_ptr: Vec<*const c_void> = debug_urls_cstr
            .as_slice()
            .into_iter()
            .map(|v| v.as_ptr() as *const c_void)
            .collect();
        let debug_urls_sizes: Vec<usize> = debug_urls_cstr
            .as_slice()
            .into_iter()
            .map(|v| v.as_bytes().len())
            .collect();
        let attr_name = CString::new("debug_urls").unwrap();
        tf::TFE_OpSetAttrStringList(
            op,
            attr_name.as_ptr(),
            debug_urls_ptr.as_ptr(),
            debug_urls_sizes.as_ptr(),
            debug_urls.len() as i32,
        );

        let attr_name = CString::new("device_name").unwrap();
        let device_name_cstr = device_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            device_name_cstr.as_ptr() as *mut c_void,
            device_name.as_bytes().len() + 1,
        );

        let attr_name = CString::new("tensor_name").unwrap();
        let tensor_name_cstr = tensor_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            tensor_name_cstr.as_ptr() as *mut c_void,
            tensor_name.as_bytes().len() + 1,
        );

        let attr_name = CString::new("gated_grpc").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), gated_grpc as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn debug_identity_v2<T>(
    ctx: &Context,
    input: T,
    debug_urls: &Vec<String>,
    tfdbg_context_id: &String,
    op_name: &String,
    output_slot: i64,
    tensor_debug_mode: i64,
    circular_buffer_size: i64,
    tfdbg_run_id: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("DebugIdentityV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let debug_urls_cstr: Vec<CString> = debug_urls
            .into_iter()
            .map(|v| CString::new(v.as_bytes()).unwrap())
            .collect();
        let debug_urls_ptr: Vec<*const c_void> = debug_urls_cstr
            .as_slice()
            .into_iter()
            .map(|v| v.as_ptr() as *const c_void)
            .collect();
        let debug_urls_sizes: Vec<usize> = debug_urls_cstr
            .as_slice()
            .into_iter()
            .map(|v| v.as_bytes().len())
            .collect();
        let attr_name = CString::new("debug_urls").unwrap();
        tf::TFE_OpSetAttrStringList(
            op,
            attr_name.as_ptr(),
            debug_urls_ptr.as_ptr(),
            debug_urls_sizes.as_ptr(),
            debug_urls.len() as i32,
        );

        let attr_name = CString::new("tfdbg_context_id").unwrap();
        let tfdbg_context_id_cstr = tfdbg_context_id.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            tfdbg_context_id_cstr.as_ptr() as *mut c_void,
            tfdbg_context_id.as_bytes().len() + 1,
        );

        let attr_name = CString::new("op_name").unwrap();
        let op_name_cstr = op_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            op_name_cstr.as_ptr() as *mut c_void,
            op_name.as_bytes().len() + 1,
        );

        let attr_name = CString::new("output_slot").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), output_slot);

        let attr_name = CString::new("tensor_debug_mode").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), tensor_debug_mode);

        let attr_name = CString::new("circular_buffer_size").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), circular_buffer_size);

        let attr_name = CString::new("tfdbg_run_id").unwrap();
        let tfdbg_run_id_cstr = tfdbg_run_id.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            tfdbg_run_id_cstr.as_ptr() as *mut c_void,
            tfdbg_run_id.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn debug_nan_count<T>(
    ctx: &Context,
    input: T,
    debug_urls: &Vec<String>,
    device_name: &String,
    tensor_name: &String,
    gated_grpc: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("DebugNanCount").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let debug_urls_cstr: Vec<CString> = debug_urls
            .into_iter()
            .map(|v| CString::new(v.as_bytes()).unwrap())
            .collect();
        let debug_urls_ptr: Vec<*const c_void> = debug_urls_cstr
            .as_slice()
            .into_iter()
            .map(|v| v.as_ptr() as *const c_void)
            .collect();
        let debug_urls_sizes: Vec<usize> = debug_urls_cstr
            .as_slice()
            .into_iter()
            .map(|v| v.as_bytes().len())
            .collect();
        let attr_name = CString::new("debug_urls").unwrap();
        tf::TFE_OpSetAttrStringList(
            op,
            attr_name.as_ptr(),
            debug_urls_ptr.as_ptr(),
            debug_urls_sizes.as_ptr(),
            debug_urls.len() as i32,
        );

        let attr_name = CString::new("device_name").unwrap();
        let device_name_cstr = device_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            device_name_cstr.as_ptr() as *mut c_void,
            device_name.as_bytes().len() + 1,
        );

        let attr_name = CString::new("tensor_name").unwrap();
        let tensor_name_cstr = tensor_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            tensor_name_cstr.as_ptr() as *mut c_void,
            tensor_name.as_bytes().len() + 1,
        );

        let attr_name = CString::new("gated_grpc").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), gated_grpc as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn debug_numeric_summary<T>(
    ctx: &Context,
    input: T,
    debug_urls: &Vec<String>,
    device_name: &String,
    tensor_name: &String,
    lower_bound: f32,
    upper_bound: f32,
    mute_if_healthy: bool,
    gated_grpc: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("DebugNumericSummary").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let debug_urls_cstr: Vec<CString> = debug_urls
            .into_iter()
            .map(|v| CString::new(v.as_bytes()).unwrap())
            .collect();
        let debug_urls_ptr: Vec<*const c_void> = debug_urls_cstr
            .as_slice()
            .into_iter()
            .map(|v| v.as_ptr() as *const c_void)
            .collect();
        let debug_urls_sizes: Vec<usize> = debug_urls_cstr
            .as_slice()
            .into_iter()
            .map(|v| v.as_bytes().len())
            .collect();
        let attr_name = CString::new("debug_urls").unwrap();
        tf::TFE_OpSetAttrStringList(
            op,
            attr_name.as_ptr(),
            debug_urls_ptr.as_ptr(),
            debug_urls_sizes.as_ptr(),
            debug_urls.len() as i32,
        );

        let attr_name = CString::new("device_name").unwrap();
        let device_name_cstr = device_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            device_name_cstr.as_ptr() as *mut c_void,
            device_name.as_bytes().len() + 1,
        );

        let attr_name = CString::new("tensor_name").unwrap();
        let tensor_name_cstr = tensor_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            tensor_name_cstr.as_ptr() as *mut c_void,
            tensor_name.as_bytes().len() + 1,
        );

        let attr_name = CString::new("lower_bound").unwrap();
        tf::TFE_OpSetAttrFloat(op, attr_name.as_ptr(), lower_bound);

        let attr_name = CString::new("upper_bound").unwrap();
        tf::TFE_OpSetAttrFloat(op, attr_name.as_ptr(), upper_bound);

        let attr_name = CString::new("mute_if_healthy").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), mute_if_healthy as u8);

        let attr_name = CString::new("gated_grpc").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), gated_grpc as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn debug_numeric_summary_v2<T>(
    ctx: &Context,
    input: T,
    output_dtype_: DataType,
    tensor_debug_mode: i64,
    tensor_id: i64,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("DebugNumericSummaryV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), output_dtype_.to_c());

        let attr_name = CString::new("tensor_debug_mode").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), tensor_debug_mode);

        let attr_name = CString::new("tensor_id").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), tensor_id);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn decode_and_crop_jpeg<T>(
    ctx: &Context,
    contents: T,
    crop_window: T,
    channels: i64,
    ratio: i64,
    fancy_upscaling: bool,
    try_recover_truncated: bool,
    acceptable_fraction: f32,
    dct_method: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("DecodeAndCropJpeg").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, contents.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, crop_window.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("channels").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), channels);

        let attr_name = CString::new("ratio").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), ratio);

        let attr_name = CString::new("fancy_upscaling").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), fancy_upscaling as u8);

        let attr_name = CString::new("try_recover_truncated").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), try_recover_truncated as u8);

        let attr_name = CString::new("acceptable_fraction").unwrap();
        tf::TFE_OpSetAttrFloat(op, attr_name.as_ptr(), acceptable_fraction);

        let attr_name = CString::new("dct_method").unwrap();
        let dct_method_cstr = dct_method.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            dct_method_cstr.as_ptr() as *mut c_void,
            dct_method.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn decode_base64<T>(ctx: &Context, input: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("DecodeBase64").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn decode_bmp<T>(ctx: &Context, contents: T, channels: i64) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("DecodeBmp").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, contents.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("channels").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), channels);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn decode_c_s_v<T>(
    ctx: &Context,
    records: T,
    record_defaults: &Vec<T>,
    OUT_TYPE: &Vec<DataType>,
    select_cols: &Vec<i64>,
    field_delim: &String,
    use_quote_delim: bool,
    na_value: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("DecodeCSV").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, records.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        let mut record_defaults_handles: Vec<*mut tf::TFE_TensorHandle> = record_defaults
            .into_iter()
            .map(|t| t.to_handle().unwrap().inner)
            .collect();
        tf::TFE_OpAddInputList(
            op,
            record_defaults_handles.as_mut_ptr(),
            record_defaults.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("OUT_TYPE").unwrap();
        let OUT_TYPE: Vec<tf::TF_DataType> = OUT_TYPE.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            OUT_TYPE.as_ptr(),
            OUT_TYPE.len() as i32,
        );

        let attr_name = CString::new("select_cols").unwrap();
        tf::TFE_OpSetAttrIntList(
            op,
            attr_name.as_ptr(),
            select_cols.as_ptr(),
            select_cols.len() as i32,
        );

        let attr_name = CString::new("field_delim").unwrap();
        let field_delim_cstr = field_delim.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            field_delim_cstr.as_ptr() as *mut c_void,
            field_delim.as_bytes().len() + 1,
        );

        let attr_name = CString::new("use_quote_delim").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), use_quote_delim as u8);

        let attr_name = CString::new("na_value").unwrap();
        let na_value_cstr = na_value.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            na_value_cstr.as_ptr() as *mut c_void,
            na_value.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn decode_compressed<T>(
    ctx: &Context,
    bytes: T,
    compression_type_: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("DecodeCompressed").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, bytes.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("compression_type_").unwrap();
        let compression_type__cstr = compression_type_.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            compression_type__cstr.as_ptr() as *mut c_void,
            compression_type_.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn decode_gif<T>(ctx: &Context, contents: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("DecodeGif").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, contents.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn decode_image<T>(
    ctx: &Context,
    contents: T,
    channels: i64,
    dtype_: DataType,
    expand_animations: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("DecodeImage").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, contents.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("channels").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), channels);

        let attr_name = CString::new("dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), dtype_.to_c());

        let attr_name = CString::new("expand_animations").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), expand_animations as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn decode_j_s_o_n_example<T>(ctx: &Context, json_examples: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("DecodeJSONExample").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, json_examples.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn decode_jpeg<T>(
    ctx: &Context,
    contents: T,
    channels: i64,
    ratio: i64,
    fancy_upscaling: bool,
    try_recover_truncated: bool,
    acceptable_fraction: f32,
    dct_method: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("DecodeJpeg").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, contents.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("channels").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), channels);

        let attr_name = CString::new("ratio").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), ratio);

        let attr_name = CString::new("fancy_upscaling").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), fancy_upscaling as u8);

        let attr_name = CString::new("try_recover_truncated").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), try_recover_truncated as u8);

        let attr_name = CString::new("acceptable_fraction").unwrap();
        tf::TFE_OpSetAttrFloat(op, attr_name.as_ptr(), acceptable_fraction);

        let attr_name = CString::new("dct_method").unwrap();
        let dct_method_cstr = dct_method.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            dct_method_cstr.as_ptr() as *mut c_void,
            dct_method.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn decode_padded_raw<T>(
    ctx: &Context,
    input_bytes: T,
    fixed_length: T,
    out_type_: DataType,
    little_endian: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("DecodePaddedRaw").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_bytes.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, fixed_length.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("out_type_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), out_type_.to_c());

        let attr_name = CString::new("little_endian").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), little_endian as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn decode_png<T>(
    ctx: &Context,
    contents: T,
    channels: i64,
    dtype_: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("DecodePng").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, contents.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("channels").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), channels);

        let attr_name = CString::new("dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), dtype_.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn decode_raw<T>(
    ctx: &Context,
    bytes: T,
    out_type_: DataType,
    little_endian: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("DecodeRaw").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, bytes.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("out_type_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), out_type_.to_c());

        let attr_name = CString::new("little_endian").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), little_endian as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn deep_copy<T>(ctx: &Context, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("DeepCopy").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn dense_bincount<T>(
    ctx: &Context,
    input: T,
    size: T,
    weights: T,
    Tidx: DataType,
    binary_output: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("DenseBincount").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, size.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, weights.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tidx").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tidx.to_c());

        let attr_name = CString::new("binary_output").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), binary_output as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn dense_to_c_s_r_sparse_matrix<T>(
    ctx: &Context,
    dense_input: T,
    indices: T,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("DenseToCSRSparseMatrix").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, dense_input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn dense_to_sparse_batch_dataset<T>(
    ctx: &Context,
    input_dataset: T,
    batch_size: T,
    row_shape: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("DenseToSparseBatchDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, batch_size.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, row_shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn depth_to_space<T>(
    ctx: &Context,
    input: T,
    block_size: i64,
    data_format: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("DepthToSpace").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("block_size").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), block_size);

        let attr_name = CString::new("data_format").unwrap();
        let data_format_cstr = data_format.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            data_format_cstr.as_ptr() as *mut c_void,
            data_format.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn depthwise_conv2d_native<T>(
    ctx: &Context,
    input: T,
    filter: T,
    strides: &Vec<i64>,
    padding: &String,
    explicit_paddings: &Vec<i64>,
    dilations: &Vec<i64>,
    data_format: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("DepthwiseConv2dNative").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, filter.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("strides").unwrap();
        tf::TFE_OpSetAttrIntList(
            op,
            attr_name.as_ptr(),
            strides.as_ptr(),
            strides.len() as i32,
        );

        let attr_name = CString::new("padding").unwrap();
        let padding_cstr = padding.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            padding_cstr.as_ptr() as *mut c_void,
            padding.as_bytes().len() + 1,
        );

        let attr_name = CString::new("explicit_paddings").unwrap();
        tf::TFE_OpSetAttrIntList(
            op,
            attr_name.as_ptr(),
            explicit_paddings.as_ptr(),
            explicit_paddings.len() as i32,
        );

        let attr_name = CString::new("dilations").unwrap();
        tf::TFE_OpSetAttrIntList(
            op,
            attr_name.as_ptr(),
            dilations.as_ptr(),
            dilations.len() as i32,
        );

        let attr_name = CString::new("data_format").unwrap();
        let data_format_cstr = data_format.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            data_format_cstr.as_ptr() as *mut c_void,
            data_format.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn depthwise_conv2d_native_backprop_filter<T>(
    ctx: &Context,
    input: T,
    filter_sizes: T,
    out_backprop: T,
    strides: &Vec<i64>,
    padding: &String,
    explicit_paddings: &Vec<i64>,
    dilations: &Vec<i64>,
    data_format: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("DepthwiseConv2dNativeBackpropFilter").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, filter_sizes.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, out_backprop.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("strides").unwrap();
        tf::TFE_OpSetAttrIntList(
            op,
            attr_name.as_ptr(),
            strides.as_ptr(),
            strides.len() as i32,
        );

        let attr_name = CString::new("padding").unwrap();
        let padding_cstr = padding.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            padding_cstr.as_ptr() as *mut c_void,
            padding.as_bytes().len() + 1,
        );

        let attr_name = CString::new("explicit_paddings").unwrap();
        tf::TFE_OpSetAttrIntList(
            op,
            attr_name.as_ptr(),
            explicit_paddings.as_ptr(),
            explicit_paddings.len() as i32,
        );

        let attr_name = CString::new("dilations").unwrap();
        tf::TFE_OpSetAttrIntList(
            op,
            attr_name.as_ptr(),
            dilations.as_ptr(),
            dilations.len() as i32,
        );

        let attr_name = CString::new("data_format").unwrap();
        let data_format_cstr = data_format.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            data_format_cstr.as_ptr() as *mut c_void,
            data_format.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn depthwise_conv2d_native_backprop_input<T>(
    ctx: &Context,
    input_sizes: T,
    filter: T,
    out_backprop: T,
    strides: &Vec<i64>,
    padding: &String,
    explicit_paddings: &Vec<i64>,
    dilations: &Vec<i64>,
    data_format: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("DepthwiseConv2dNativeBackpropInput").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_sizes.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, filter.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, out_backprop.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("strides").unwrap();
        tf::TFE_OpSetAttrIntList(
            op,
            attr_name.as_ptr(),
            strides.as_ptr(),
            strides.len() as i32,
        );

        let attr_name = CString::new("padding").unwrap();
        let padding_cstr = padding.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            padding_cstr.as_ptr() as *mut c_void,
            padding.as_bytes().len() + 1,
        );

        let attr_name = CString::new("explicit_paddings").unwrap();
        tf::TFE_OpSetAttrIntList(
            op,
            attr_name.as_ptr(),
            explicit_paddings.as_ptr(),
            explicit_paddings.len() as i32,
        );

        let attr_name = CString::new("dilations").unwrap();
        tf::TFE_OpSetAttrIntList(
            op,
            attr_name.as_ptr(),
            dilations.as_ptr(),
            dilations.len() as i32,
        );

        let attr_name = CString::new("data_format").unwrap();
        let data_format_cstr = data_format.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            data_format_cstr.as_ptr() as *mut c_void,
            data_format.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn dequantize<T>(
    ctx: &Context,
    input: T,
    min_range: T,
    max_range: T,
    mode: &String,
    narrow_range: bool,
    axis: i64,
    dtype_: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Dequantize").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, min_range.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, max_range.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("mode").unwrap();
        let mode_cstr = mode.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            mode_cstr.as_ptr() as *mut c_void,
            mode.as_bytes().len() + 1,
        );

        let attr_name = CString::new("narrow_range").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), narrow_range as u8);

        let attr_name = CString::new("axis").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), axis);

        let attr_name = CString::new("dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), dtype_.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn destroy_temporary_variable<T>(
    ctx: &Context,
    ref_: T,
    var_name: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("DestroyTemporaryVariable").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, ref_.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("var_name").unwrap();
        let var_name_cstr = var_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            var_name_cstr.as_ptr() as *mut c_void,
            var_name.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn device_index<T>(ctx: &Context, device_names: &Vec<String>) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("DeviceIndex").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let device_names_cstr: Vec<CString> = device_names
            .into_iter()
            .map(|v| CString::new(v.as_bytes()).unwrap())
            .collect();
        let device_names_ptr: Vec<*const c_void> = device_names_cstr
            .as_slice()
            .into_iter()
            .map(|v| v.as_ptr() as *const c_void)
            .collect();
        let device_names_sizes: Vec<usize> = device_names_cstr
            .as_slice()
            .into_iter()
            .map(|v| v.as_bytes().len())
            .collect();
        let attr_name = CString::new("device_names").unwrap();
        tf::TFE_OpSetAttrStringList(
            op,
            attr_name.as_ptr(),
            device_names_ptr.as_ptr(),
            device_names_sizes.as_ptr(),
            device_names.len() as i32,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn diag<T>(ctx: &Context, diagonal: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Diag").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, diagonal.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn diag_part<T>(ctx: &Context, input: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("DiagPart").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn digamma<T>(ctx: &Context, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Digamma").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn dilation2_d<T>(
    ctx: &Context,
    input: T,
    filter: T,
    strides: &Vec<i64>,
    rates: &Vec<i64>,
    padding: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Dilation2D").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, filter.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("strides").unwrap();
        tf::TFE_OpSetAttrIntList(
            op,
            attr_name.as_ptr(),
            strides.as_ptr(),
            strides.len() as i32,
        );

        let attr_name = CString::new("rates").unwrap();
        tf::TFE_OpSetAttrIntList(op, attr_name.as_ptr(), rates.as_ptr(), rates.len() as i32);

        let attr_name = CString::new("padding").unwrap();
        let padding_cstr = padding.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            padding_cstr.as_ptr() as *mut c_void,
            padding.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn dilation2_d_backprop_filter<T>(
    ctx: &Context,
    input: T,
    filter: T,
    out_backprop: T,
    strides: &Vec<i64>,
    rates: &Vec<i64>,
    padding: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Dilation2DBackpropFilter").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, filter.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, out_backprop.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("strides").unwrap();
        tf::TFE_OpSetAttrIntList(
            op,
            attr_name.as_ptr(),
            strides.as_ptr(),
            strides.len() as i32,
        );

        let attr_name = CString::new("rates").unwrap();
        tf::TFE_OpSetAttrIntList(op, attr_name.as_ptr(), rates.as_ptr(), rates.len() as i32);

        let attr_name = CString::new("padding").unwrap();
        let padding_cstr = padding.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            padding_cstr.as_ptr() as *mut c_void,
            padding.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn dilation2_d_backprop_input<T>(
    ctx: &Context,
    input: T,
    filter: T,
    out_backprop: T,
    strides: &Vec<i64>,
    rates: &Vec<i64>,
    padding: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Dilation2DBackpropInput").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, filter.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, out_backprop.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("strides").unwrap();
        tf::TFE_OpSetAttrIntList(
            op,
            attr_name.as_ptr(),
            strides.as_ptr(),
            strides.len() as i32,
        );

        let attr_name = CString::new("rates").unwrap();
        tf::TFE_OpSetAttrIntList(op, attr_name.as_ptr(), rates.as_ptr(), rates.len() as i32);

        let attr_name = CString::new("padding").unwrap();
        let padding_cstr = padding.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            padding_cstr.as_ptr() as *mut c_void,
            padding.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn directed_interleave_dataset<T>(
    ctx: &Context,
    selector_input_dataset: T,
    data_input_datasets: &Vec<T>,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("DirectedInterleaveDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, selector_input_dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        let mut data_input_datasets_handles: Vec<*mut tf::TFE_TensorHandle> = data_input_datasets
            .into_iter()
            .map(|t| t.to_handle().unwrap().inner)
            .collect();
        tf::TFE_OpAddInputList(
            op,
            data_input_datasets_handles.as_mut_ptr(),
            data_input_datasets.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        let attr_name = CString::new("N").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), data_input_datasets.len() as i64);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn div<T>(ctx: &Context, x: T, y: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Div").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, y.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn div_no_nan<T>(ctx: &Context, x: T, y: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("DivNoNan").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, y.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn draw_bounding_boxes<T>(ctx: &Context, images: T, boxes: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("DrawBoundingBoxes").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, images.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, boxes.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn draw_bounding_boxes_v2<T>(
    ctx: &Context,
    images: T,
    boxes: T,
    colors: T,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("DrawBoundingBoxesV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, images.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, boxes.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, colors.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn dummy_iteration_counter<T>(ctx: &Context) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("DummyIterationCounter").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn dummy_memory_cache<T>(ctx: &Context) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("DummyMemoryCache").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn dummy_seed_generator<T>(ctx: &Context) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("DummySeedGenerator").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn dynamic_partition<T>(
    ctx: &Context,
    data: T,
    partitions: T,
    num_partitions: i64,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("DynamicPartition").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, data.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, partitions.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("num_partitions").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), num_partitions);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn dynamic_stitch<T>(ctx: &Context, indices: &Vec<T>, data: &Vec<T>) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("DynamicStitch").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        let mut indices_handles: Vec<*mut tf::TFE_TensorHandle> = indices
            .into_iter()
            .map(|t| t.to_handle().unwrap().inner)
            .collect();
        tf::TFE_OpAddInputList(
            op,
            indices_handles.as_mut_ptr(),
            indices.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        let mut data_handles: Vec<*mut tf::TFE_TensorHandle> = data
            .into_iter()
            .map(|t| t.to_handle().unwrap().inner)
            .collect();
        tf::TFE_OpAddInputList(
            op,
            data_handles.as_mut_ptr(),
            data.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("N").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), indices.len() as i64);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn eager_py_func<T>(
    ctx: &Context,
    input: &Vec<T>,
    token: &String,
    Tin: &Vec<DataType>,
    Tout: &Vec<DataType>,
    is_async: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("EagerPyFunc").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        let mut input_handles: Vec<*mut tf::TFE_TensorHandle> = input
            .into_iter()
            .map(|t| t.to_handle().unwrap().inner)
            .collect();
        tf::TFE_OpAddInputList(
            op,
            input_handles.as_mut_ptr(),
            input.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("token").unwrap();
        let token_cstr = token.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            token_cstr.as_ptr() as *mut c_void,
            token.as_bytes().len() + 1,
        );

        let attr_name = CString::new("Tin").unwrap();
        let Tin: Vec<tf::TF_DataType> = Tin.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(op, attr_name.as_ptr(), Tin.as_ptr(), Tin.len() as i32);

        let attr_name = CString::new("Tout").unwrap();
        let Tout: Vec<tf::TF_DataType> = Tout.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(op, attr_name.as_ptr(), Tout.as_ptr(), Tout.len() as i32);

        let attr_name = CString::new("is_async").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), is_async as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn edit_distance<T>(
    ctx: &Context,
    hypothesis_indices: T,
    hypothesis_values: T,
    hypothesis_shape: T,
    truth_indices: T,
    truth_values: T,
    truth_shape: T,
    normalize: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("EditDistance").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, hypothesis_indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, hypothesis_values.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, hypothesis_shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, truth_indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, truth_values.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, truth_shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("normalize").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), normalize as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn einsum<T>(ctx: &Context, inputs: &Vec<T>, equation: &String) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Einsum").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        let mut inputs_handles: Vec<*mut tf::TFE_TensorHandle> = inputs
            .into_iter()
            .map(|t| t.to_handle().unwrap().inner)
            .collect();
        tf::TFE_OpAddInputList(
            op,
            inputs_handles.as_mut_ptr(),
            inputs.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("equation").unwrap();
        let equation_cstr = equation.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            equation_cstr.as_ptr() as *mut c_void,
            equation.as_bytes().len() + 1,
        );

        let attr_name = CString::new("N").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), inputs.len() as i64);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn elu<T>(ctx: &Context, features: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Elu").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, features.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn elu_grad<T>(ctx: &Context, gradients: T, outputs: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("EluGrad").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, gradients.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, outputs.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn empty<T>(ctx: &Context, shape: T, dtype_: DataType, init: bool) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Empty").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), dtype_.to_c());

        let attr_name = CString::new("init").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), init as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn empty_tensor_list<T>(
    ctx: &Context,
    element_shape: T,
    max_num_elements: T,
    element_dtype_: DataType,
    shape_type_: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("EmptyTensorList").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, element_shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, max_num_elements.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("element_dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), element_dtype_.to_c());

        let attr_name = CString::new("shape_type_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), shape_type_.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn encode_base64<T>(ctx: &Context, input: T, pad: bool) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("EncodeBase64").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("pad").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), pad as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn encode_jpeg<T>(
    ctx: &Context,
    image: T,
    format: &String,
    quality: i64,
    progressive: bool,
    optimize_size: bool,
    chroma_downsampling: bool,
    density_unit: &String,
    x_density: i64,
    y_density: i64,
    xmp_metadata: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("EncodeJpeg").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, image.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("format").unwrap();
        let format_cstr = format.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            format_cstr.as_ptr() as *mut c_void,
            format.as_bytes().len() + 1,
        );

        let attr_name = CString::new("quality").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), quality);

        let attr_name = CString::new("progressive").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), progressive as u8);

        let attr_name = CString::new("optimize_size").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), optimize_size as u8);

        let attr_name = CString::new("chroma_downsampling").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), chroma_downsampling as u8);

        let attr_name = CString::new("density_unit").unwrap();
        let density_unit_cstr = density_unit.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            density_unit_cstr.as_ptr() as *mut c_void,
            density_unit.as_bytes().len() + 1,
        );

        let attr_name = CString::new("x_density").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), x_density);

        let attr_name = CString::new("y_density").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), y_density);

        let attr_name = CString::new("xmp_metadata").unwrap();
        let xmp_metadata_cstr = xmp_metadata.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            xmp_metadata_cstr.as_ptr() as *mut c_void,
            xmp_metadata.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn encode_jpeg_variable_quality<T>(ctx: &Context, images: T, quality: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("EncodeJpegVariableQuality").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, images.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, quality.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn encode_png<T>(ctx: &Context, image: T, compression: i64) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("EncodePng").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, image.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("compression").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), compression);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn encode_proto<T>(
    ctx: &Context,
    sizes: T,
    values: &Vec<T>,
    field_names: &Vec<String>,
    message_type_: &String,
    Tinput_type_s: &Vec<DataType>,
    descriptor_source: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("EncodeProto").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, sizes.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        let mut values_handles: Vec<*mut tf::TFE_TensorHandle> = values
            .into_iter()
            .map(|t| t.to_handle().unwrap().inner)
            .collect();
        tf::TFE_OpAddInputList(
            op,
            values_handles.as_mut_ptr(),
            values.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Attributes

        let field_names_cstr: Vec<CString> = field_names
            .into_iter()
            .map(|v| CString::new(v.as_bytes()).unwrap())
            .collect();
        let field_names_ptr: Vec<*const c_void> = field_names_cstr
            .as_slice()
            .into_iter()
            .map(|v| v.as_ptr() as *const c_void)
            .collect();
        let field_names_sizes: Vec<usize> = field_names_cstr
            .as_slice()
            .into_iter()
            .map(|v| v.as_bytes().len())
            .collect();
        let attr_name = CString::new("field_names").unwrap();
        tf::TFE_OpSetAttrStringList(
            op,
            attr_name.as_ptr(),
            field_names_ptr.as_ptr(),
            field_names_sizes.as_ptr(),
            field_names.len() as i32,
        );

        let attr_name = CString::new("message_type_").unwrap();
        let message_type__cstr = message_type_.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            message_type__cstr.as_ptr() as *mut c_void,
            message_type_.as_bytes().len() + 1,
        );

        let attr_name = CString::new("Tinput_type_s").unwrap();
        let Tinput_type_s: Vec<tf::TF_DataType> =
            Tinput_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            Tinput_type_s.as_ptr(),
            Tinput_type_s.len() as i32,
        );

        let attr_name = CString::new("descriptor_source").unwrap();
        let descriptor_source_cstr = descriptor_source.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            descriptor_source_cstr.as_ptr() as *mut c_void,
            descriptor_source.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn encode_wav<T>(ctx: &Context, audio: T, sample_rate: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("EncodeWav").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, audio.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, sample_rate.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn ensure_shape<T>(ctx: &Context, input: T, shape: &Vec<i64>) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("EnsureShape").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("shape").unwrap();
        tf::TFE_OpSetAttrShape(
            op,
            attr_name.as_ptr(),
            shape.as_ptr(),
            shape.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn enter<T>(
    ctx: &Context,
    data: T,
    frame_name: &String,
    is_constant: bool,
    parallel_iterations: i64,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Enter").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, data.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("frame_name").unwrap();
        let frame_name_cstr = frame_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            frame_name_cstr.as_ptr() as *mut c_void,
            frame_name.as_bytes().len() + 1,
        );

        let attr_name = CString::new("is_constant").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), is_constant as u8);

        let attr_name = CString::new("parallel_iterations").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), parallel_iterations);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn equal<T>(ctx: &Context, x: T, y: T, incompatible_shape_error: bool) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Equal").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, y.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("incompatible_shape_error").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), incompatible_shape_error as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn erf<T>(ctx: &Context, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Erf").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn erfc<T>(ctx: &Context, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Erfc").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn erfinv<T>(ctx: &Context, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Erfinv").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn euclidean_norm<T>(
    ctx: &Context,
    input: T,
    reduction_indices: T,
    keep_dims: bool,
    Tidx: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("EuclideanNorm").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, reduction_indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("keep_dims").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), keep_dims as u8);

        let attr_name = CString::new("Tidx").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tidx.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn exit<T>(ctx: &Context, data: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Exit").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, data.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn exp<T>(ctx: &Context, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Exp").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn expand_dims<T>(ctx: &Context, input: T, dim: T, Tdim: DataType) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ExpandDims").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, dim.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tdim").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tdim.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn experimental_assert_next_dataset<T>(
    ctx: &Context,
    input_dataset: T,
    transformations: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ExperimentalAssertNextDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, transformations.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn experimental_auto_shard_dataset<T>(
    ctx: &Context,
    input_dataset: T,
    num_workers: T,
    index: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
    auto_shard_policy: i64,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ExperimentalAutoShardDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, num_workers.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, index.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        let attr_name = CString::new("auto_shard_policy").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), auto_shard_policy);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn experimental_bytes_produced_stats_dataset<T>(
    ctx: &Context,
    input_dataset: T,
    tag: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ExperimentalBytesProducedStatsDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, tag.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn experimental_c_s_v_dataset<T>(
    ctx: &Context,
    filenames: T,
    compression_type: T,
    buffer_size: T,
    header: T,
    field_delim: T,
    use_quote_delim: T,
    na_value: T,
    select_cols: T,
    record_defaults: &Vec<T>,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ExperimentalCSVDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, filenames.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, compression_type.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, buffer_size.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, header.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, field_delim.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, use_quote_delim.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, na_value.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, select_cols.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        let mut record_defaults_handles: Vec<*mut tf::TFE_TensorHandle> = record_defaults
            .into_iter()
            .map(|t| t.to_handle().unwrap().inner)
            .collect();
        tf::TFE_OpAddInputList(
            op,
            record_defaults_handles.as_mut_ptr(),
            record_defaults.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn experimental_choose_fastest_dataset<T>(
    ctx: &Context,
    input_datasets: &Vec<T>,
    num_experiments: i64,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ExperimentalChooseFastestDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        let mut input_datasets_handles: Vec<*mut tf::TFE_TensorHandle> = input_datasets
            .into_iter()
            .map(|t| t.to_handle().unwrap().inner)
            .collect();
        tf::TFE_OpAddInputList(
            op,
            input_datasets_handles.as_mut_ptr(),
            input_datasets.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("N").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), input_datasets.len() as i64);

        let attr_name = CString::new("num_experiments").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), num_experiments);

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn experimental_dataset_cardinality<T>(ctx: &Context, input_dataset: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ExperimentalDatasetCardinality").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn experimental_dense_to_sparse_batch_dataset<T>(
    ctx: &Context,
    input_dataset: T,
    batch_size: T,
    row_shape: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ExperimentalDenseToSparseBatchDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, batch_size.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, row_shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn experimental_directed_interleave_dataset<T>(
    ctx: &Context,
    selector_input_dataset: T,
    data_input_datasets: &Vec<T>,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ExperimentalDirectedInterleaveDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, selector_input_dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        let mut data_input_datasets_handles: Vec<*mut tf::TFE_TensorHandle> = data_input_datasets
            .into_iter()
            .map(|t| t.to_handle().unwrap().inner)
            .collect();
        tf::TFE_OpAddInputList(
            op,
            data_input_datasets_handles.as_mut_ptr(),
            data_input_datasets.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        let attr_name = CString::new("N").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), data_input_datasets.len() as i64);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn experimental_ignore_errors_dataset<T>(
    ctx: &Context,
    input_dataset: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ExperimentalIgnoreErrorsDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn experimental_iterator_get_device<T>(ctx: &Context, resource: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ExperimentalIteratorGetDevice").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, resource.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn experimental_l_m_d_b_dataset<T>(
    ctx: &Context,
    filenames: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ExperimentalLMDBDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, filenames.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn experimental_latency_stats_dataset<T>(
    ctx: &Context,
    input_dataset: T,
    tag: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ExperimentalLatencyStatsDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, tag.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn experimental_matching_files_dataset<T>(ctx: &Context, patterns: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ExperimentalMatchingFilesDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, patterns.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn experimental_max_intra_op_parallelism_dataset<T>(
    ctx: &Context,
    input_dataset: T,
    max_intra_op_parallelism: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ExperimentalMaxIntraOpParallelismDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(
            op,
            max_intra_op_parallelism.to_handle()?.inner,
            status.inner,
        );
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn experimental_non_serializable_dataset<T>(
    ctx: &Context,
    input_dataset: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ExperimentalNonSerializableDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn experimental_parse_example_dataset<T>(
    ctx: &Context,
    input_dataset: T,
    num_parallel_calls: T,
    dense_defaults: &Vec<T>,
    sparse_keys: &Vec<String>,
    dense_keys: &Vec<String>,
    sparse_type_s: &Vec<DataType>,
    Tdense: &Vec<DataType>,
    dense_shapes: &Vec<Vec<i64>>,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
    sloppy: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ExperimentalParseExampleDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, num_parallel_calls.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        let mut dense_defaults_handles: Vec<*mut tf::TFE_TensorHandle> = dense_defaults
            .into_iter()
            .map(|t| t.to_handle().unwrap().inner)
            .collect();
        tf::TFE_OpAddInputList(
            op,
            dense_defaults_handles.as_mut_ptr(),
            dense_defaults.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Attributes

        let sparse_keys_cstr: Vec<CString> = sparse_keys
            .into_iter()
            .map(|v| CString::new(v.as_bytes()).unwrap())
            .collect();
        let sparse_keys_ptr: Vec<*const c_void> = sparse_keys_cstr
            .as_slice()
            .into_iter()
            .map(|v| v.as_ptr() as *const c_void)
            .collect();
        let sparse_keys_sizes: Vec<usize> = sparse_keys_cstr
            .as_slice()
            .into_iter()
            .map(|v| v.as_bytes().len())
            .collect();
        let attr_name = CString::new("sparse_keys").unwrap();
        tf::TFE_OpSetAttrStringList(
            op,
            attr_name.as_ptr(),
            sparse_keys_ptr.as_ptr(),
            sparse_keys_sizes.as_ptr(),
            sparse_keys.len() as i32,
        );

        let dense_keys_cstr: Vec<CString> = dense_keys
            .into_iter()
            .map(|v| CString::new(v.as_bytes()).unwrap())
            .collect();
        let dense_keys_ptr: Vec<*const c_void> = dense_keys_cstr
            .as_slice()
            .into_iter()
            .map(|v| v.as_ptr() as *const c_void)
            .collect();
        let dense_keys_sizes: Vec<usize> = dense_keys_cstr
            .as_slice()
            .into_iter()
            .map(|v| v.as_bytes().len())
            .collect();
        let attr_name = CString::new("dense_keys").unwrap();
        tf::TFE_OpSetAttrStringList(
            op,
            attr_name.as_ptr(),
            dense_keys_ptr.as_ptr(),
            dense_keys_sizes.as_ptr(),
            dense_keys.len() as i32,
        );

        let attr_name = CString::new("sparse_type_s").unwrap();
        let sparse_type_s: Vec<tf::TF_DataType> =
            sparse_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            sparse_type_s.as_ptr(),
            sparse_type_s.len() as i32,
        );

        let attr_name = CString::new("Tdense").unwrap();
        let Tdense: Vec<tf::TF_DataType> = Tdense.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(op, attr_name.as_ptr(), Tdense.as_ptr(), Tdense.len() as i32);

        let mut dense_shapes_values: Vec<*const i64> =
            dense_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let dense_shapes_ndims: Vec<i32> =
            dense_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("dense_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            dense_shapes_values.as_mut_ptr(),
            dense_shapes_ndims.as_ptr(),
            dense_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        let attr_name = CString::new("sloppy").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), sloppy as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn experimental_private_thread_pool_dataset<T>(
    ctx: &Context,
    input_dataset: T,
    num_threads: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ExperimentalPrivateThreadPoolDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, num_threads.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn experimental_random_dataset<T>(
    ctx: &Context,
    seed: T,
    seed2: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ExperimentalRandomDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, seed.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, seed2.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn experimental_rebatch_dataset<T>(
    ctx: &Context,
    input_dataset: T,
    num_replicas: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
    use_fallback: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ExperimentalRebatchDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, num_replicas.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        let attr_name = CString::new("use_fallback").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), use_fallback as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn experimental_set_stats_aggregator_dataset<T>(
    ctx: &Context,
    input_dataset: T,
    stats_aggregator: T,
    tag: T,
    counter_pref_ix: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ExperimentalSetStatsAggregatorDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, stats_aggregator.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, tag.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, counter_pref_ix.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn experimental_sleep_dataset<T>(
    ctx: &Context,
    input_dataset: T,
    sleep_microseconds: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ExperimentalSleepDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, sleep_microseconds.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn experimental_sliding_window_dataset<T>(
    ctx: &Context,
    input_dataset: T,
    window_size: T,
    window_shift: T,
    window_stride: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ExperimentalSlidingWindowDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, window_size.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, window_shift.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, window_stride.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn experimental_sql_dataset<T>(
    ctx: &Context,
    driver_name: T,
    data_source_name: T,
    query: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ExperimentalSqlDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, driver_name.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, data_source_name.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, query.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn experimental_stats_aggregator_handle<T>(
    ctx: &Context,
    container: &String,
    shared_name: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ExperimentalStatsAggregatorHandle").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("container").unwrap();
        let container_cstr = container.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            container_cstr.as_ptr() as *mut c_void,
            container.as_bytes().len() + 1,
        );

        let attr_name = CString::new("shared_name").unwrap();
        let shared_name_cstr = shared_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            shared_name_cstr.as_ptr() as *mut c_void,
            shared_name.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn experimental_stats_aggregator_summary<T>(ctx: &Context, iterator: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ExperimentalStatsAggregatorSummary").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, iterator.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn experimental_thread_pool_dataset<T>(
    ctx: &Context,
    input_dataset: T,
    thread_pool: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ExperimentalThreadPoolDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, thread_pool.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn experimental_thread_pool_handle<T>(
    ctx: &Context,
    num_threads: i64,
    display_name: &String,
    max_intra_op_parallelism: i64,
    container: &String,
    shared_name: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ExperimentalThreadPoolHandle").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("num_threads").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), num_threads);

        let attr_name = CString::new("display_name").unwrap();
        let display_name_cstr = display_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            display_name_cstr.as_ptr() as *mut c_void,
            display_name.as_bytes().len() + 1,
        );

        let attr_name = CString::new("max_intra_op_parallelism").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), max_intra_op_parallelism);

        let attr_name = CString::new("container").unwrap();
        let container_cstr = container.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            container_cstr.as_ptr() as *mut c_void,
            container.as_bytes().len() + 1,
        );

        let attr_name = CString::new("shared_name").unwrap();
        let shared_name_cstr = shared_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            shared_name_cstr.as_ptr() as *mut c_void,
            shared_name.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn experimental_unbatch_dataset<T>(
    ctx: &Context,
    input_dataset: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ExperimentalUnbatchDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn experimental_unique_dataset<T>(
    ctx: &Context,
    input_dataset: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ExperimentalUniqueDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn expint<T>(ctx: &Context, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Expint").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn expm1<T>(ctx: &Context, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Expm1").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn extract_glimpse<T>(
    ctx: &Context,
    input: T,
    size: T,
    offsets: T,
    centered: bool,
    normalized: bool,
    uniform_noise: bool,
    noise: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ExtractGlimpse").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, size.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, offsets.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("centered").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), centered as u8);

        let attr_name = CString::new("normalized").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), normalized as u8);

        let attr_name = CString::new("uniform_noise").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), uniform_noise as u8);

        let attr_name = CString::new("noise").unwrap();
        let noise_cstr = noise.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            noise_cstr.as_ptr() as *mut c_void,
            noise.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn extract_glimpse_v2<T>(
    ctx: &Context,
    input: T,
    size: T,
    offsets: T,
    centered: bool,
    normalized: bool,
    uniform_noise: bool,
    noise: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ExtractGlimpseV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, size.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, offsets.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("centered").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), centered as u8);

        let attr_name = CString::new("normalized").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), normalized as u8);

        let attr_name = CString::new("uniform_noise").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), uniform_noise as u8);

        let attr_name = CString::new("noise").unwrap();
        let noise_cstr = noise.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            noise_cstr.as_ptr() as *mut c_void,
            noise.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn extract_image_patches<T>(
    ctx: &Context,
    images: T,
    ksizes: &Vec<i64>,
    strides: &Vec<i64>,
    rates: &Vec<i64>,
    padding: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ExtractImagePatches").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, images.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("ksizes").unwrap();
        tf::TFE_OpSetAttrIntList(op, attr_name.as_ptr(), ksizes.as_ptr(), ksizes.len() as i32);

        let attr_name = CString::new("strides").unwrap();
        tf::TFE_OpSetAttrIntList(
            op,
            attr_name.as_ptr(),
            strides.as_ptr(),
            strides.len() as i32,
        );

        let attr_name = CString::new("rates").unwrap();
        tf::TFE_OpSetAttrIntList(op, attr_name.as_ptr(), rates.as_ptr(), rates.len() as i32);

        let attr_name = CString::new("padding").unwrap();
        let padding_cstr = padding.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            padding_cstr.as_ptr() as *mut c_void,
            padding.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn extract_jpeg_shape<T>(
    ctx: &Context,
    contents: T,
    output_type_: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ExtractJpegShape").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, contents.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), output_type_.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn extract_volume_patches<T>(
    ctx: &Context,
    input: T,
    ksizes: &Vec<i64>,
    strides: &Vec<i64>,
    padding: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ExtractVolumePatches").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("ksizes").unwrap();
        tf::TFE_OpSetAttrIntList(op, attr_name.as_ptr(), ksizes.as_ptr(), ksizes.len() as i32);

        let attr_name = CString::new("strides").unwrap();
        tf::TFE_OpSetAttrIntList(
            op,
            attr_name.as_ptr(),
            strides.as_ptr(),
            strides.len() as i32,
        );

        let attr_name = CString::new("padding").unwrap();
        let padding_cstr = padding.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            padding_cstr.as_ptr() as *mut c_void,
            padding.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn f_f_t<T>(ctx: &Context, input: T, Tcomplex: DataType) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("FFT").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tcomplex").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tcomplex.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn f_f_t2_d<T>(ctx: &Context, input: T, Tcomplex: DataType) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("FFT2D").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tcomplex").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tcomplex.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn f_f_t3_d<T>(ctx: &Context, input: T, Tcomplex: DataType) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("FFT3D").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tcomplex").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tcomplex.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn f_i_f_o_queue<T>(
    ctx: &Context,
    component_type_s: &Vec<DataType>,
    shapes: &Vec<Vec<i64>>,
    capacity: i64,
    container: &String,
    shared_name: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("FIFOQueue").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("component_type_s").unwrap();
        let component_type_s: Vec<tf::TF_DataType> =
            component_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            component_type_s.as_ptr(),
            component_type_s.len() as i32,
        );

        let mut shapes_values: Vec<*const i64> = shapes.into_iter().map(|v| v.as_ptr()).collect();
        let shapes_ndims: Vec<i32> = shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            shapes_values.as_mut_ptr(),
            shapes_ndims.as_ptr(),
            shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        let attr_name = CString::new("capacity").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), capacity);

        let attr_name = CString::new("container").unwrap();
        let container_cstr = container.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            container_cstr.as_ptr() as *mut c_void,
            container.as_bytes().len() + 1,
        );

        let attr_name = CString::new("shared_name").unwrap();
        let shared_name_cstr = shared_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            shared_name_cstr.as_ptr() as *mut c_void,
            shared_name.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn f_i_f_o_queue_v2<T>(
    ctx: &Context,
    component_type_s: &Vec<DataType>,
    shapes: &Vec<Vec<i64>>,
    capacity: i64,
    container: &String,
    shared_name: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("FIFOQueueV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("component_type_s").unwrap();
        let component_type_s: Vec<tf::TF_DataType> =
            component_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            component_type_s.as_ptr(),
            component_type_s.len() as i32,
        );

        let mut shapes_values: Vec<*const i64> = shapes.into_iter().map(|v| v.as_ptr()).collect();
        let shapes_ndims: Vec<i32> = shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            shapes_values.as_mut_ptr(),
            shapes_ndims.as_ptr(),
            shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        let attr_name = CString::new("capacity").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), capacity);

        let attr_name = CString::new("container").unwrap();
        let container_cstr = container.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            container_cstr.as_ptr() as *mut c_void,
            container.as_bytes().len() + 1,
        );

        let attr_name = CString::new("shared_name").unwrap();
        let shared_name_cstr = shared_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            shared_name_cstr.as_ptr() as *mut c_void,
            shared_name.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn fact<T>(ctx: &Context) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Fact").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn fake_param<T>(ctx: &Context, dtype_: DataType, shape: &Vec<i64>) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("FakeParam").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), dtype_.to_c());

        let attr_name = CString::new("shape").unwrap();
        tf::TFE_OpSetAttrShape(
            op,
            attr_name.as_ptr(),
            shape.as_ptr(),
            shape.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn fake_quant_with_min_max_args<T>(
    ctx: &Context,
    inputs: T,
    min: f32,
    max: f32,
    num_bits: i64,
    narrow_range: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("FakeQuantWithMinMaxArgs").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, inputs.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("min").unwrap();
        tf::TFE_OpSetAttrFloat(op, attr_name.as_ptr(), min);

        let attr_name = CString::new("max").unwrap();
        tf::TFE_OpSetAttrFloat(op, attr_name.as_ptr(), max);

        let attr_name = CString::new("num_bits").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), num_bits);

        let attr_name = CString::new("narrow_range").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), narrow_range as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn fake_quant_with_min_max_args_gradient<T>(
    ctx: &Context,
    gradients: T,
    inputs: T,
    min: f32,
    max: f32,
    num_bits: i64,
    narrow_range: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("FakeQuantWithMinMaxArgsGradient").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, gradients.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, inputs.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("min").unwrap();
        tf::TFE_OpSetAttrFloat(op, attr_name.as_ptr(), min);

        let attr_name = CString::new("max").unwrap();
        tf::TFE_OpSetAttrFloat(op, attr_name.as_ptr(), max);

        let attr_name = CString::new("num_bits").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), num_bits);

        let attr_name = CString::new("narrow_range").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), narrow_range as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn fake_quant_with_min_max_vars<T>(
    ctx: &Context,
    inputs: T,
    min: T,
    max: T,
    num_bits: i64,
    narrow_range: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("FakeQuantWithMinMaxVars").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, inputs.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, min.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, max.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("num_bits").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), num_bits);

        let attr_name = CString::new("narrow_range").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), narrow_range as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn fake_quant_with_min_max_vars_per_channel<T>(
    ctx: &Context,
    inputs: T,
    min: T,
    max: T,
    num_bits: i64,
    narrow_range: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("FakeQuantWithMinMaxVarsPerChannel").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, inputs.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, min.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, max.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("num_bits").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), num_bits);

        let attr_name = CString::new("narrow_range").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), narrow_range as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn fake_queue<T>(ctx: &Context, resource: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("FakeQueue").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, resource.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn fill<T>(ctx: &Context, dims: T, value: T, index_type_: DataType) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Fill").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, dims.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, value.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("index_type_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), index_type_.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn filter_by_last_component_dataset<T>(
    ctx: &Context,
    input_dataset: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("FilterByLastComponentDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn fingerprint<T>(ctx: &Context, data: T, method: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Fingerprint").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, data.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, method.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn fixed_length_record_dataset<T>(
    ctx: &Context,
    filenames: T,
    header_bytes: T,
    record_bytes: T,
    footer_bytes: T,
    buffer_size: T,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("FixedLengthRecordDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, filenames.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, header_bytes.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, record_bytes.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, footer_bytes.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, buffer_size.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn fixed_length_record_dataset_v2<T>(
    ctx: &Context,
    filenames: T,
    header_bytes: T,
    record_bytes: T,
    footer_bytes: T,
    buffer_size: T,
    compression_type: T,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("FixedLengthRecordDatasetV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, filenames.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, header_bytes.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, record_bytes.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, footer_bytes.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, buffer_size.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, compression_type.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn fixed_length_record_reader<T>(
    ctx: &Context,
    record_bytes: i64,
    header_bytes: i64,
    footer_bytes: i64,
    hop_bytes: i64,
    container: &String,
    shared_name: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("FixedLengthRecordReader").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("record_bytes").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), record_bytes);

        let attr_name = CString::new("header_bytes").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), header_bytes);

        let attr_name = CString::new("footer_bytes").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), footer_bytes);

        let attr_name = CString::new("hop_bytes").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), hop_bytes);

        let attr_name = CString::new("container").unwrap();
        let container_cstr = container.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            container_cstr.as_ptr() as *mut c_void,
            container.as_bytes().len() + 1,
        );

        let attr_name = CString::new("shared_name").unwrap();
        let shared_name_cstr = shared_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            shared_name_cstr.as_ptr() as *mut c_void,
            shared_name.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn fixed_length_record_reader_v2<T>(
    ctx: &Context,
    record_bytes: i64,
    header_bytes: i64,
    footer_bytes: i64,
    hop_bytes: i64,
    container: &String,
    shared_name: &String,
    encoding: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("FixedLengthRecordReaderV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("record_bytes").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), record_bytes);

        let attr_name = CString::new("header_bytes").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), header_bytes);

        let attr_name = CString::new("footer_bytes").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), footer_bytes);

        let attr_name = CString::new("hop_bytes").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), hop_bytes);

        let attr_name = CString::new("container").unwrap();
        let container_cstr = container.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            container_cstr.as_ptr() as *mut c_void,
            container.as_bytes().len() + 1,
        );

        let attr_name = CString::new("shared_name").unwrap();
        let shared_name_cstr = shared_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            shared_name_cstr.as_ptr() as *mut c_void,
            shared_name.as_bytes().len() + 1,
        );

        let attr_name = CString::new("encoding").unwrap();
        let encoding_cstr = encoding.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            encoding_cstr.as_ptr() as *mut c_void,
            encoding.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn floor<T>(ctx: &Context, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Floor").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn floor_div<T>(ctx: &Context, x: T, y: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("FloorDiv").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, y.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn floor_mod_<T>(ctx: &Context, x: T, y: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("FloorMod").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, y.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn fractional_avg_pool_grad<T>(
    ctx: &Context,
    orig_input_tensor_shape: T,
    out_backprop: T,
    row_pooling_sequence: T,
    col_pooling_sequence: T,
    overlapping: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("FractionalAvgPoolGrad").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, orig_input_tensor_shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, out_backprop.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, row_pooling_sequence.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, col_pooling_sequence.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("overlapping").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), overlapping as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn fractional_max_pool_grad<T>(
    ctx: &Context,
    orig_input: T,
    orig_output: T,
    out_backprop: T,
    row_pooling_sequence: T,
    col_pooling_sequence: T,
    overlapping: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("FractionalMaxPoolGrad").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, orig_input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, orig_output.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, out_backprop.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, row_pooling_sequence.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, col_pooling_sequence.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("overlapping").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), overlapping as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn fresnel_cos<T>(ctx: &Context, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("FresnelCos").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn fresnel_sin<T>(ctx: &Context, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("FresnelSin").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn fused_pad_conv2_d<T>(
    ctx: &Context,
    input: T,
    paddings: T,
    filter: T,
    mode: &String,
    strides: &Vec<i64>,
    padding: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("FusedPadConv2D").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, paddings.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, filter.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("mode").unwrap();
        let mode_cstr = mode.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            mode_cstr.as_ptr() as *mut c_void,
            mode.as_bytes().len() + 1,
        );

        let attr_name = CString::new("strides").unwrap();
        tf::TFE_OpSetAttrIntList(
            op,
            attr_name.as_ptr(),
            strides.as_ptr(),
            strides.len() as i32,
        );

        let attr_name = CString::new("padding").unwrap();
        let padding_cstr = padding.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            padding_cstr.as_ptr() as *mut c_void,
            padding.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn fused_resize_and_pad_conv2_d<T>(
    ctx: &Context,
    input: T,
    size: T,
    paddings: T,
    filter: T,
    mode: &String,
    strides: &Vec<i64>,
    padding: &String,
    resize_align_corners: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("FusedResizeAndPadConv2D").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, size.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, paddings.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, filter.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("mode").unwrap();
        let mode_cstr = mode.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            mode_cstr.as_ptr() as *mut c_void,
            mode.as_bytes().len() + 1,
        );

        let attr_name = CString::new("strides").unwrap();
        tf::TFE_OpSetAttrIntList(
            op,
            attr_name.as_ptr(),
            strides.as_ptr(),
            strides.len() as i32,
        );

        let attr_name = CString::new("padding").unwrap();
        let padding_cstr = padding.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            padding_cstr.as_ptr() as *mut c_void,
            padding.as_bytes().len() + 1,
        );

        let attr_name = CString::new("resize_align_corners").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), resize_align_corners as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn gather<T>(
    ctx: &Context,
    params: T,
    indices: T,
    Tparams: DataType,
    Tindices: DataType,
    validate_indices: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Gather").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, params.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tparams").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tparams.to_c());

        let attr_name = CString::new("Tindices").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tindices.to_c());

        let attr_name = CString::new("validate_indices").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), validate_indices as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn gather_nd<T>(
    ctx: &Context,
    params: T,
    indices: T,
    Tparams: DataType,
    Tindices: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("GatherNd").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, params.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tparams").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tparams.to_c());

        let attr_name = CString::new("Tindices").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tindices.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn gather_v2<T>(
    ctx: &Context,
    params: T,
    indices: T,
    axis: T,
    Tparams: DataType,
    Tindices: DataType,
    Taxis: DataType,
    batch_dims: i64,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("GatherV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, params.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, axis.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tparams").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tparams.to_c());

        let attr_name = CString::new("Tindices").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tindices.to_c());

        let attr_name = CString::new("Taxis").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Taxis.to_c());

        let attr_name = CString::new("batch_dims").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), batch_dims);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn get_session_handle<T>(ctx: &Context, value: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("GetSessionHandle").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, value.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn get_session_handle_v2<T>(ctx: &Context, value: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("GetSessionHandleV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, value.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn get_session_tensor<T>(ctx: &Context, handle: T, dtype_: DataType) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("GetSessionTensor").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), dtype_.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn greater<T>(ctx: &Context, x: T, y: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Greater").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, y.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn greater_equal<T>(ctx: &Context, x: T, y: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("GreaterEqual").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, y.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn guarantee_const_tensor<T>(ctx: &Context, input: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("GuaranteeConst").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn h_s_v_to_r_g_b<T>(ctx: &Context, images: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("HSVToRGB").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, images.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn hash_table<T>(
    ctx: &Context,
    key_dtype_: DataType,
    value_dtype_: DataType,
    container: &String,
    shared_name: &String,
    use_node_name_sharing: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("HashTable").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("key_dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), key_dtype_.to_c());

        let attr_name = CString::new("value_dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), value_dtype_.to_c());

        let attr_name = CString::new("container").unwrap();
        let container_cstr = container.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            container_cstr.as_ptr() as *mut c_void,
            container.as_bytes().len() + 1,
        );

        let attr_name = CString::new("shared_name").unwrap();
        let shared_name_cstr = shared_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            shared_name_cstr.as_ptr() as *mut c_void,
            shared_name.as_bytes().len() + 1,
        );

        let attr_name = CString::new("use_node_name_sharing").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), use_node_name_sharing as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn hash_table_v2<T>(
    ctx: &Context,
    key_dtype_: DataType,
    value_dtype_: DataType,
    container: &String,
    shared_name: &String,
    use_node_name_sharing: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("HashTableV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("key_dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), key_dtype_.to_c());

        let attr_name = CString::new("value_dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), value_dtype_.to_c());

        let attr_name = CString::new("container").unwrap();
        let container_cstr = container.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            container_cstr.as_ptr() as *mut c_void,
            container.as_bytes().len() + 1,
        );

        let attr_name = CString::new("shared_name").unwrap();
        let shared_name_cstr = shared_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            shared_name_cstr.as_ptr() as *mut c_void,
            shared_name.as_bytes().len() + 1,
        );

        let attr_name = CString::new("use_node_name_sharing").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), use_node_name_sharing as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn histogram_fixed_width<T>(
    ctx: &Context,
    values: T,
    value_range: T,
    nbins: T,
    dtype_: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("HistogramFixedWidth").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, values.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, value_range.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, nbins.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), dtype_.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn histogram_summary<T>(ctx: &Context, tag: T, values: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("HistogramSummary").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, tag.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, values.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn i_f_f_t<T>(ctx: &Context, input: T, Tcomplex: DataType) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("IFFT").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tcomplex").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tcomplex.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn i_f_f_t2_d<T>(ctx: &Context, input: T, Tcomplex: DataType) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("IFFT2D").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tcomplex").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tcomplex.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn i_f_f_t3_d<T>(ctx: &Context, input: T, Tcomplex: DataType) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("IFFT3D").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tcomplex").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tcomplex.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn i_r_f_f_t<T>(
    ctx: &Context,
    input: T,
    fft_length: T,
    Treal: DataType,
    Tcomplex: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("IRFFT").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, fft_length.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Treal").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Treal.to_c());

        let attr_name = CString::new("Tcomplex").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tcomplex.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn i_r_f_f_t2_d<T>(
    ctx: &Context,
    input: T,
    fft_length: T,
    Treal: DataType,
    Tcomplex: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("IRFFT2D").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, fft_length.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Treal").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Treal.to_c());

        let attr_name = CString::new("Tcomplex").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tcomplex.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn i_r_f_f_t3_d<T>(
    ctx: &Context,
    input: T,
    fft_length: T,
    Treal: DataType,
    Tcomplex: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("IRFFT3D").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, fft_length.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Treal").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Treal.to_c());

        let attr_name = CString::new("Tcomplex").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tcomplex.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn identity<T>(ctx: &Context, input: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Identity").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn identity_n<T>(ctx: &Context, input: &Vec<T>) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("IdentityN").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        let mut input_handles: Vec<*mut tf::TFE_TensorHandle> = input
            .into_iter()
            .map(|t| t.to_handle().unwrap().inner)
            .collect();
        tf::TFE_OpAddInputList(
            op,
            input_handles.as_mut_ptr(),
            input.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn identity_reader<T>(
    ctx: &Context,
    container: &String,
    shared_name: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("IdentityReader").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("container").unwrap();
        let container_cstr = container.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            container_cstr.as_ptr() as *mut c_void,
            container.as_bytes().len() + 1,
        );

        let attr_name = CString::new("shared_name").unwrap();
        let shared_name_cstr = shared_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            shared_name_cstr.as_ptr() as *mut c_void,
            shared_name.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn identity_reader_v2<T>(
    ctx: &Context,
    container: &String,
    shared_name: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("IdentityReaderV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("container").unwrap();
        let container_cstr = container.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            container_cstr.as_ptr() as *mut c_void,
            container.as_bytes().len() + 1,
        );

        let attr_name = CString::new("shared_name").unwrap();
        let shared_name_cstr = shared_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            shared_name_cstr.as_ptr() as *mut c_void,
            shared_name.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn igamma<T>(ctx: &Context, a: T, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Igamma").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, a.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn igamma_grad_a<T>(ctx: &Context, a: T, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("IgammaGradA").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, a.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn igammac<T>(ctx: &Context, a: T, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Igammac").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, a.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn ignore_errors_dataset<T>(
    ctx: &Context,
    input_dataset: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("IgnoreErrorsDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn imag<T>(ctx: &Context, input: T, Tout: DataType) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Imag").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tout").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tout.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn image_projective_transform_v2<T>(
    ctx: &Context,
    images: T,
    transforms: T,
    output_shape: T,
    dtype_: DataType,
    interpolation: &String,
    fill_mode: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ImageProjectiveTransformV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, images.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, transforms.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, output_shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), dtype_.to_c());

        let attr_name = CString::new("interpolation").unwrap();
        let interpolation_cstr = interpolation.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            interpolation_cstr.as_ptr() as *mut c_void,
            interpolation.as_bytes().len() + 1,
        );

        let attr_name = CString::new("fill_mode").unwrap();
        let fill_mode_cstr = fill_mode.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            fill_mode_cstr.as_ptr() as *mut c_void,
            fill_mode.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn image_summary<T, D>(
    ctx: &Context,
    tag: T,
    tensor: T,
    bad_color: &Tensor<D>,
    max_images: i64,
) -> Result<TensorHandle>
where
    T: ToHandle,
    D: TensorType,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ImageSummary").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, tag.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, tensor.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("bad_color").unwrap();
        tf::TFE_OpSetAttrTensor(
            op,
            attr_name.as_ptr(),
            bad_color.inner().unwrap(),
            status.inner,
        );
        // status_check(context::get_status());

        let attr_name = CString::new("max_images").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), max_images);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn immutable_const_tensor<T>(
    ctx: &Context,
    dtype_: DataType,
    shape: &Vec<i64>,
    memory_region_name: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ImmutableConst").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), dtype_.to_c());

        let attr_name = CString::new("shape").unwrap();
        tf::TFE_OpSetAttrShape(
            op,
            attr_name.as_ptr(),
            shape.as_ptr(),
            shape.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        let attr_name = CString::new("memory_region_name").unwrap();
        let memory_region_name_cstr = memory_region_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            memory_region_name_cstr.as_ptr() as *mut c_void,
            memory_region_name.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn in_top_k<T>(ctx: &Context, predictions: T, targets: T, k: i64) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("InTopK").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, predictions.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, targets.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("k").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), k);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn in_top_k_v2<T>(ctx: &Context, predictions: T, targets: T, k: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("InTopKV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, predictions.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, targets.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, k.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn infeed_dequeue<T>(ctx: &Context, dtype_: DataType, shape: &Vec<i64>) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("InfeedDequeue").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), dtype_.to_c());

        let attr_name = CString::new("shape").unwrap();
        tf::TFE_OpSetAttrShape(
            op,
            attr_name.as_ptr(),
            shape.as_ptr(),
            shape.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn infeed_dequeue_tuple<T>(
    ctx: &Context,
    dtype_s: &Vec<DataType>,
    shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("InfeedDequeueTuple").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("dtype_s").unwrap();
        let dtype_s: Vec<tf::TF_DataType> = dtype_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            dtype_s.as_ptr(),
            dtype_s.len() as i32,
        );

        let mut shapes_values: Vec<*const i64> = shapes.into_iter().map(|v| v.as_ptr()).collect();
        let shapes_ndims: Vec<i32> = shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            shapes_values.as_mut_ptr(),
            shapes_ndims.as_ptr(),
            shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn inplace_add<T>(ctx: &Context, x: T, i: T, v: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("InplaceAdd").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, i.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, v.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn inplace_sub<T>(ctx: &Context, x: T, i: T, v: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("InplaceSub").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, i.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, v.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn inplace_update<T>(ctx: &Context, x: T, i: T, v: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("InplaceUpdate").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, i.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, v.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn inv<T>(ctx: &Context, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Inv").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn inv_grad<T>(ctx: &Context, y: T, dy: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("InvGrad").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, y.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, dy.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn invert<T>(ctx: &Context, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Invert").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn invert_permutation<T>(ctx: &Context, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("InvertPermutation").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn is_boosted_trees_ensemble_initialized<T>(
    ctx: &Context,
    tree_ensemble_handle: T,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("IsBoostedTreesEnsembleInitialized").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, tree_ensemble_handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn is_boosted_trees_quantile_stream_resource_initialized<T>(
    ctx: &Context,
    quantile_stream_resource_handle: T,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("IsBoostedTreesQuantileStreamResourceInitialized").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(
            op,
            quantile_stream_resource_handle.to_handle()?.inner,
            status.inner,
        );
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn is_finite<T>(ctx: &Context, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("IsFinite").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn is_inf<T>(ctx: &Context, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("IsInf").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn is_nan<T>(ctx: &Context, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("IsNan").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn is_variable_initialized<T>(ctx: &Context, ref_: T, dtype_: DataType) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("IsVariableInitialized").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, ref_.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), dtype_.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn iterator<T>(
    ctx: &Context,
    shared_name: &String,
    container: &String,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Iterator").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("shared_name").unwrap();
        let shared_name_cstr = shared_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            shared_name_cstr.as_ptr() as *mut c_void,
            shared_name.as_bytes().len() + 1,
        );

        let attr_name = CString::new("container").unwrap();
        let container_cstr = container.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            container_cstr.as_ptr() as *mut c_void,
            container.as_bytes().len() + 1,
        );

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn iterator_from_string_handle<T>(
    ctx: &Context,
    string_handle: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("IteratorFromStringHandle").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, string_handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn iterator_from_string_handle_v2<T>(
    ctx: &Context,
    string_handle: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("IteratorFromStringHandleV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, string_handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn iterator_get_device<T>(ctx: &Context, resource: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("IteratorGetDevice").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, resource.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn iterator_get_next<T>(
    ctx: &Context,
    iterator: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("IteratorGetNext").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, iterator.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn iterator_get_next_as_optional<T>(
    ctx: &Context,
    iterator: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("IteratorGetNextAsOptional").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, iterator.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn iterator_get_next_sync<T>(
    ctx: &Context,
    iterator: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("IteratorGetNextSync").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, iterator.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn iterator_to_string_handle<T>(ctx: &Context, resource_handle: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("IteratorToStringHandle").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, resource_handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn iterator_v2<T>(
    ctx: &Context,
    shared_name: &String,
    container: &String,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("IteratorV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("shared_name").unwrap();
        let shared_name_cstr = shared_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            shared_name_cstr.as_ptr() as *mut c_void,
            shared_name.as_bytes().len() + 1,
        );

        let attr_name = CString::new("container").unwrap();
        let container_cstr = container.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            container_cstr.as_ptr() as *mut c_void,
            container.as_bytes().len() + 1,
        );

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn l2_loss<T>(ctx: &Context, t: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("L2Loss").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, t.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn l_m_d_b_dataset<T>(
    ctx: &Context,
    filenames: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("LMDBDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, filenames.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn l_m_d_b_reader<T>(
    ctx: &Context,
    container: &String,
    shared_name: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("LMDBReader").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("container").unwrap();
        let container_cstr = container.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            container_cstr.as_ptr() as *mut c_void,
            container.as_bytes().len() + 1,
        );

        let attr_name = CString::new("shared_name").unwrap();
        let shared_name_cstr = shared_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            shared_name_cstr.as_ptr() as *mut c_void,
            shared_name.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn l_r_n<T>(
    ctx: &Context,
    input: T,
    depth_radius: i64,
    bias: f32,
    alpha: f32,
    beta: f32,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("LRN").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("depth_radius").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), depth_radius);

        let attr_name = CString::new("bias").unwrap();
        tf::TFE_OpSetAttrFloat(op, attr_name.as_ptr(), bias);

        let attr_name = CString::new("alpha").unwrap();
        tf::TFE_OpSetAttrFloat(op, attr_name.as_ptr(), alpha);

        let attr_name = CString::new("beta").unwrap();
        tf::TFE_OpSetAttrFloat(op, attr_name.as_ptr(), beta);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn l_r_n_grad<T>(
    ctx: &Context,
    input_grads: T,
    input_image: T,
    output_image: T,
    depth_radius: i64,
    bias: f32,
    alpha: f32,
    beta: f32,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("LRNGrad").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_grads.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, input_image.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, output_image.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("depth_radius").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), depth_radius);

        let attr_name = CString::new("bias").unwrap();
        tf::TFE_OpSetAttrFloat(op, attr_name.as_ptr(), bias);

        let attr_name = CString::new("alpha").unwrap();
        tf::TFE_OpSetAttrFloat(op, attr_name.as_ptr(), alpha);

        let attr_name = CString::new("beta").unwrap();
        tf::TFE_OpSetAttrFloat(op, attr_name.as_ptr(), beta);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn latency_stats_dataset<T>(
    ctx: &Context,
    input_dataset: T,
    tag: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("LatencyStatsDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, tag.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn leaky_relu<T>(ctx: &Context, features: T, alpha: f32) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("LeakyRelu").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, features.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("alpha").unwrap();
        tf::TFE_OpSetAttrFloat(op, attr_name.as_ptr(), alpha);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn leaky_relu_grad<T>(
    ctx: &Context,
    gradients: T,
    features: T,
    alpha: f32,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("LeakyReluGrad").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, gradients.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, features.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("alpha").unwrap();
        tf::TFE_OpSetAttrFloat(op, attr_name.as_ptr(), alpha);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn left_shift<T>(ctx: &Context, x: T, y: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("LeftShift").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, y.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn less<T>(ctx: &Context, x: T, y: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Less").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, y.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn less_equal<T>(ctx: &Context, x: T, y: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("LessEqual").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, y.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn lgamma<T>(ctx: &Context, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Lgamma").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn lin_space<T>(
    ctx: &Context,
    start: T,
    stop: T,
    num: T,
    Tidx: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("LinSpace").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, start.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, stop.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, num.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tidx").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tidx.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn load_and_remap_matrix<T>(
    ctx: &Context,
    ckpt_path: T,
    old_tensor_name: T,
    row_remapping: T,
    col_remapping: T,
    initializing_values: T,
    num_rows: i64,
    num_cols: i64,
    max_rows_in_memory: i64,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("LoadAndRemapMatrix").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, ckpt_path.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, old_tensor_name.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, row_remapping.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, col_remapping.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, initializing_values.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("num_rows").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), num_rows);

        let attr_name = CString::new("num_cols").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), num_cols);

        let attr_name = CString::new("max_rows_in_memory").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), max_rows_in_memory);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn log<T>(ctx: &Context, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Log").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn log1p<T>(ctx: &Context, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Log1p").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn log_softmax<T>(ctx: &Context, logits: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("LogSoftmax").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, logits.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn logical_and<T>(ctx: &Context, x: T, y: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("LogicalAnd").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, y.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn logical_not<T>(ctx: &Context, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("LogicalNot").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn logical_or<T>(ctx: &Context, x: T, y: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("LogicalOr").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, y.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn lookup_table_find<T>(
    ctx: &Context,
    table_handle: T,
    keys: T,
    default_value: T,
    Tin: DataType,
    Tout: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("LookupTableFind").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, table_handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, keys.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, default_value.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tin").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tin.to_c());

        let attr_name = CString::new("Tout").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tout.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn lookup_table_find_v2<T>(
    ctx: &Context,
    table_handle: T,
    keys: T,
    default_value: T,
    Tin: DataType,
    Tout: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("LookupTableFindV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, table_handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, keys.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, default_value.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tin").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tin.to_c());

        let attr_name = CString::new("Tout").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tout.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn lookup_table_size<T>(ctx: &Context, table_handle: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("LookupTableSize").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, table_handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn lookup_table_size_v2<T>(ctx: &Context, table_handle: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("LookupTableSizeV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, table_handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn loop_cond<T>(ctx: &Context, input: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("LoopCond").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn lower_bound<T>(
    ctx: &Context,
    sorted_inputs: T,
    values: T,
    out_type_: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("LowerBound").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, sorted_inputs.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, values.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("out_type_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), out_type_.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn map_incomplete_size<T>(
    ctx: &Context,
    dtype_s: &Vec<DataType>,
    capacity: i64,
    memory_limit: i64,
    container: &String,
    shared_name: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("MapIncompleteSize").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("dtype_s").unwrap();
        let dtype_s: Vec<tf::TF_DataType> = dtype_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            dtype_s.as_ptr(),
            dtype_s.len() as i32,
        );

        let attr_name = CString::new("capacity").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), capacity);

        let attr_name = CString::new("memory_limit").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), memory_limit);

        let attr_name = CString::new("container").unwrap();
        let container_cstr = container.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            container_cstr.as_ptr() as *mut c_void,
            container.as_bytes().len() + 1,
        );

        let attr_name = CString::new("shared_name").unwrap();
        let shared_name_cstr = shared_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            shared_name_cstr.as_ptr() as *mut c_void,
            shared_name.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn map_peek<T>(
    ctx: &Context,
    key: T,
    indices: T,
    dtype_s: &Vec<DataType>,
    capacity: i64,
    memory_limit: i64,
    container: &String,
    shared_name: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("MapPeek").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, key.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("dtype_s").unwrap();
        let dtype_s: Vec<tf::TF_DataType> = dtype_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            dtype_s.as_ptr(),
            dtype_s.len() as i32,
        );

        let attr_name = CString::new("capacity").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), capacity);

        let attr_name = CString::new("memory_limit").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), memory_limit);

        let attr_name = CString::new("container").unwrap();
        let container_cstr = container.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            container_cstr.as_ptr() as *mut c_void,
            container.as_bytes().len() + 1,
        );

        let attr_name = CString::new("shared_name").unwrap();
        let shared_name_cstr = shared_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            shared_name_cstr.as_ptr() as *mut c_void,
            shared_name.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn map_size<T>(
    ctx: &Context,
    dtype_s: &Vec<DataType>,
    capacity: i64,
    memory_limit: i64,
    container: &String,
    shared_name: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("MapSize").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("dtype_s").unwrap();
        let dtype_s: Vec<tf::TF_DataType> = dtype_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            dtype_s.as_ptr(),
            dtype_s.len() as i32,
        );

        let attr_name = CString::new("capacity").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), capacity);

        let attr_name = CString::new("memory_limit").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), memory_limit);

        let attr_name = CString::new("container").unwrap();
        let container_cstr = container.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            container_cstr.as_ptr() as *mut c_void,
            container.as_bytes().len() + 1,
        );

        let attr_name = CString::new("shared_name").unwrap();
        let shared_name_cstr = shared_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            shared_name_cstr.as_ptr() as *mut c_void,
            shared_name.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn map_unstage<T>(
    ctx: &Context,
    key: T,
    indices: T,
    dtype_s: &Vec<DataType>,
    capacity: i64,
    memory_limit: i64,
    container: &String,
    shared_name: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("MapUnstage").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, key.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("dtype_s").unwrap();
        let dtype_s: Vec<tf::TF_DataType> = dtype_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            dtype_s.as_ptr(),
            dtype_s.len() as i32,
        );

        let attr_name = CString::new("capacity").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), capacity);

        let attr_name = CString::new("memory_limit").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), memory_limit);

        let attr_name = CString::new("container").unwrap();
        let container_cstr = container.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            container_cstr.as_ptr() as *mut c_void,
            container.as_bytes().len() + 1,
        );

        let attr_name = CString::new("shared_name").unwrap();
        let shared_name_cstr = shared_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            shared_name_cstr.as_ptr() as *mut c_void,
            shared_name.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn mat_mul<T>(
    ctx: &Context,
    a: T,
    b: T,
    transpose_a: bool,
    transpose_b: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("MatMul").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, a.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, b.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("transpose_a").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), transpose_a as u8);

        let attr_name = CString::new("transpose_b").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), transpose_b as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn matching_files<T>(ctx: &Context, pattern: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("MatchingFiles").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, pattern.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn matching_files_dataset<T>(ctx: &Context, patterns: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("MatchingFilesDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, patterns.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn matrix_band_part<T>(
    ctx: &Context,
    input: T,
    num_lower: T,
    num_upper: T,
    Tindex: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("MatrixBandPart").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, num_lower.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, num_upper.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tindex").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tindex.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn matrix_determinant<T>(ctx: &Context, input: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("MatrixDeterminant").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn matrix_diag<T>(ctx: &Context, diagonal: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("MatrixDiag").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, diagonal.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn matrix_diag_part<T>(ctx: &Context, input: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("MatrixDiagPart").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn matrix_diag_part_v2<T>(
    ctx: &Context,
    input: T,
    k: T,
    padding_value: T,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("MatrixDiagPartV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, k.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, padding_value.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn matrix_diag_part_v3<T>(
    ctx: &Context,
    input: T,
    k: T,
    padding_value: T,
    align: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("MatrixDiagPartV3").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, k.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, padding_value.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("align").unwrap();
        let align_cstr = align.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            align_cstr.as_ptr() as *mut c_void,
            align.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn matrix_diag_v2<T>(
    ctx: &Context,
    diagonal: T,
    k: T,
    num_rows: T,
    num_cols: T,
    padding_value: T,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("MatrixDiagV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, diagonal.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, k.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, num_rows.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, num_cols.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, padding_value.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn matrix_diag_v3<T>(
    ctx: &Context,
    diagonal: T,
    k: T,
    num_rows: T,
    num_cols: T,
    padding_value: T,
    align: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("MatrixDiagV3").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, diagonal.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, k.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, num_rows.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, num_cols.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, padding_value.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("align").unwrap();
        let align_cstr = align.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            align_cstr.as_ptr() as *mut c_void,
            align.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn matrix_exponential<T>(ctx: &Context, input: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("MatrixExponential").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn matrix_inverse<T>(ctx: &Context, input: T, adjoint: bool) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("MatrixInverse").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("adjoint").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), adjoint as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn matrix_logarithm<T>(ctx: &Context, input: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("MatrixLogarithm").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn matrix_set_diag<T>(ctx: &Context, input: T, diagonal: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("MatrixSetDiag").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, diagonal.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn matrix_set_diag_v2<T>(ctx: &Context, input: T, diagonal: T, k: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("MatrixSetDiagV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, diagonal.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, k.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn matrix_set_diag_v3<T>(
    ctx: &Context,
    input: T,
    diagonal: T,
    k: T,
    align: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("MatrixSetDiagV3").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, diagonal.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, k.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("align").unwrap();
        let align_cstr = align.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            align_cstr.as_ptr() as *mut c_void,
            align.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn matrix_solve<T>(ctx: &Context, matrix: T, rhs: T, adjoint: bool) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("MatrixSolve").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, matrix.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, rhs.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("adjoint").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), adjoint as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn matrix_solve_ls<T>(
    ctx: &Context,
    matrix: T,
    rhs: T,
    l2_regularizer: T,
    fast: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("MatrixSolveLs").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, matrix.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, rhs.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, l2_regularizer.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("fast").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), fast as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn matrix_square_root<T>(ctx: &Context, input: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("MatrixSquareRoot").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn matrix_triangular_solve<T>(
    ctx: &Context,
    matrix: T,
    rhs: T,
    lower: bool,
    adjoint: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("MatrixTriangularSolve").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, matrix.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, rhs.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("lower").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), lower as u8);

        let attr_name = CString::new("adjoint").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), adjoint as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn max<T>(
    ctx: &Context,
    input: T,
    reduction_indices: T,
    keep_dims: bool,
    Tidx: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Max").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, reduction_indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("keep_dims").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), keep_dims as u8);

        let attr_name = CString::new("Tidx").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tidx.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn max_intra_op_parallelism_dataset<T>(
    ctx: &Context,
    input_dataset: T,
    max_intra_op_parallelism: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("MaxIntraOpParallelismDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(
            op,
            max_intra_op_parallelism.to_handle()?.inner,
            status.inner,
        );
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn max_pool<T>(
    ctx: &Context,
    input: T,
    ksize: &Vec<i64>,
    strides: &Vec<i64>,
    padding: &String,
    data_format: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("MaxPool").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("ksize").unwrap();
        tf::TFE_OpSetAttrIntList(op, attr_name.as_ptr(), ksize.as_ptr(), ksize.len() as i32);

        let attr_name = CString::new("strides").unwrap();
        tf::TFE_OpSetAttrIntList(
            op,
            attr_name.as_ptr(),
            strides.as_ptr(),
            strides.len() as i32,
        );

        let attr_name = CString::new("padding").unwrap();
        let padding_cstr = padding.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            padding_cstr.as_ptr() as *mut c_void,
            padding.as_bytes().len() + 1,
        );

        let attr_name = CString::new("data_format").unwrap();
        let data_format_cstr = data_format.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            data_format_cstr.as_ptr() as *mut c_void,
            data_format.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn max_pool3_d<T>(
    ctx: &Context,
    input: T,
    ksize: &Vec<i64>,
    strides: &Vec<i64>,
    padding: &String,
    data_format: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("MaxPool3D").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("ksize").unwrap();
        tf::TFE_OpSetAttrIntList(op, attr_name.as_ptr(), ksize.as_ptr(), ksize.len() as i32);

        let attr_name = CString::new("strides").unwrap();
        tf::TFE_OpSetAttrIntList(
            op,
            attr_name.as_ptr(),
            strides.as_ptr(),
            strides.len() as i32,
        );

        let attr_name = CString::new("padding").unwrap();
        let padding_cstr = padding.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            padding_cstr.as_ptr() as *mut c_void,
            padding.as_bytes().len() + 1,
        );

        let attr_name = CString::new("data_format").unwrap();
        let data_format_cstr = data_format.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            data_format_cstr.as_ptr() as *mut c_void,
            data_format.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn max_pool3_d_grad<T>(
    ctx: &Context,
    orig_input: T,
    orig_output: T,
    grad: T,
    ksize: &Vec<i64>,
    strides: &Vec<i64>,
    padding: &String,
    data_format: &String,
    TInput: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("MaxPool3DGrad").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, orig_input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, orig_output.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, grad.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("ksize").unwrap();
        tf::TFE_OpSetAttrIntList(op, attr_name.as_ptr(), ksize.as_ptr(), ksize.len() as i32);

        let attr_name = CString::new("strides").unwrap();
        tf::TFE_OpSetAttrIntList(
            op,
            attr_name.as_ptr(),
            strides.as_ptr(),
            strides.len() as i32,
        );

        let attr_name = CString::new("padding").unwrap();
        let padding_cstr = padding.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            padding_cstr.as_ptr() as *mut c_void,
            padding.as_bytes().len() + 1,
        );

        let attr_name = CString::new("data_format").unwrap();
        let data_format_cstr = data_format.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            data_format_cstr.as_ptr() as *mut c_void,
            data_format.as_bytes().len() + 1,
        );

        let attr_name = CString::new("TInput").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), TInput.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn max_pool3_d_grad_grad<T>(
    ctx: &Context,
    orig_input: T,
    orig_output: T,
    grad: T,
    ksize: &Vec<i64>,
    strides: &Vec<i64>,
    padding: &String,
    data_format: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("MaxPool3DGradGrad").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, orig_input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, orig_output.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, grad.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("ksize").unwrap();
        tf::TFE_OpSetAttrIntList(op, attr_name.as_ptr(), ksize.as_ptr(), ksize.len() as i32);

        let attr_name = CString::new("strides").unwrap();
        tf::TFE_OpSetAttrIntList(
            op,
            attr_name.as_ptr(),
            strides.as_ptr(),
            strides.len() as i32,
        );

        let attr_name = CString::new("padding").unwrap();
        let padding_cstr = padding.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            padding_cstr.as_ptr() as *mut c_void,
            padding.as_bytes().len() + 1,
        );

        let attr_name = CString::new("data_format").unwrap();
        let data_format_cstr = data_format.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            data_format_cstr.as_ptr() as *mut c_void,
            data_format.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn max_pool_grad<T>(
    ctx: &Context,
    orig_input: T,
    orig_output: T,
    grad: T,
    ksize: &Vec<i64>,
    strides: &Vec<i64>,
    padding: &String,
    data_format: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("MaxPoolGrad").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, orig_input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, orig_output.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, grad.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("ksize").unwrap();
        tf::TFE_OpSetAttrIntList(op, attr_name.as_ptr(), ksize.as_ptr(), ksize.len() as i32);

        let attr_name = CString::new("strides").unwrap();
        tf::TFE_OpSetAttrIntList(
            op,
            attr_name.as_ptr(),
            strides.as_ptr(),
            strides.len() as i32,
        );

        let attr_name = CString::new("padding").unwrap();
        let padding_cstr = padding.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            padding_cstr.as_ptr() as *mut c_void,
            padding.as_bytes().len() + 1,
        );

        let attr_name = CString::new("data_format").unwrap();
        let data_format_cstr = data_format.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            data_format_cstr.as_ptr() as *mut c_void,
            data_format.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn max_pool_grad_grad<T>(
    ctx: &Context,
    orig_input: T,
    orig_output: T,
    grad: T,
    ksize: &Vec<i64>,
    strides: &Vec<i64>,
    padding: &String,
    data_format: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("MaxPoolGradGrad").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, orig_input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, orig_output.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, grad.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("ksize").unwrap();
        tf::TFE_OpSetAttrIntList(op, attr_name.as_ptr(), ksize.as_ptr(), ksize.len() as i32);

        let attr_name = CString::new("strides").unwrap();
        tf::TFE_OpSetAttrIntList(
            op,
            attr_name.as_ptr(),
            strides.as_ptr(),
            strides.len() as i32,
        );

        let attr_name = CString::new("padding").unwrap();
        let padding_cstr = padding.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            padding_cstr.as_ptr() as *mut c_void,
            padding.as_bytes().len() + 1,
        );

        let attr_name = CString::new("data_format").unwrap();
        let data_format_cstr = data_format.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            data_format_cstr.as_ptr() as *mut c_void,
            data_format.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn max_pool_grad_grad_v2<T>(
    ctx: &Context,
    orig_input: T,
    orig_output: T,
    grad: T,
    ksize: T,
    strides: T,
    padding: &String,
    data_format: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("MaxPoolGradGradV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, orig_input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, orig_output.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, grad.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, ksize.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, strides.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("padding").unwrap();
        let padding_cstr = padding.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            padding_cstr.as_ptr() as *mut c_void,
            padding.as_bytes().len() + 1,
        );

        let attr_name = CString::new("data_format").unwrap();
        let data_format_cstr = data_format.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            data_format_cstr.as_ptr() as *mut c_void,
            data_format.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn max_pool_grad_grad_with_argmax<T>(
    ctx: &Context,
    input: T,
    grad: T,
    argmax: T,
    ksize: &Vec<i64>,
    strides: &Vec<i64>,
    padding: &String,
    Targmax: DataType,
    include_batch_in_index: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("MaxPoolGradGradWithArgmax").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, grad.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, argmax.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("ksize").unwrap();
        tf::TFE_OpSetAttrIntList(op, attr_name.as_ptr(), ksize.as_ptr(), ksize.len() as i32);

        let attr_name = CString::new("strides").unwrap();
        tf::TFE_OpSetAttrIntList(
            op,
            attr_name.as_ptr(),
            strides.as_ptr(),
            strides.len() as i32,
        );

        let attr_name = CString::new("padding").unwrap();
        let padding_cstr = padding.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            padding_cstr.as_ptr() as *mut c_void,
            padding.as_bytes().len() + 1,
        );

        let attr_name = CString::new("Targmax").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Targmax.to_c());

        let attr_name = CString::new("include_batch_in_index").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), include_batch_in_index as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn max_pool_grad_v2<T>(
    ctx: &Context,
    orig_input: T,
    orig_output: T,
    grad: T,
    ksize: T,
    strides: T,
    padding: &String,
    data_format: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("MaxPoolGradV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, orig_input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, orig_output.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, grad.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, ksize.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, strides.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("padding").unwrap();
        let padding_cstr = padding.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            padding_cstr.as_ptr() as *mut c_void,
            padding.as_bytes().len() + 1,
        );

        let attr_name = CString::new("data_format").unwrap();
        let data_format_cstr = data_format.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            data_format_cstr.as_ptr() as *mut c_void,
            data_format.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn max_pool_grad_with_argmax<T>(
    ctx: &Context,
    input: T,
    grad: T,
    argmax: T,
    ksize: &Vec<i64>,
    strides: &Vec<i64>,
    padding: &String,
    Targmax: DataType,
    include_batch_in_index: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("MaxPoolGradWithArgmax").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, grad.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, argmax.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("ksize").unwrap();
        tf::TFE_OpSetAttrIntList(op, attr_name.as_ptr(), ksize.as_ptr(), ksize.len() as i32);

        let attr_name = CString::new("strides").unwrap();
        tf::TFE_OpSetAttrIntList(
            op,
            attr_name.as_ptr(),
            strides.as_ptr(),
            strides.len() as i32,
        );

        let attr_name = CString::new("padding").unwrap();
        let padding_cstr = padding.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            padding_cstr.as_ptr() as *mut c_void,
            padding.as_bytes().len() + 1,
        );

        let attr_name = CString::new("Targmax").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Targmax.to_c());

        let attr_name = CString::new("include_batch_in_index").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), include_batch_in_index as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn max_pool_v2<T>(
    ctx: &Context,
    input: T,
    ksize: T,
    strides: T,
    padding: &String,
    data_format: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("MaxPoolV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, ksize.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, strides.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("padding").unwrap();
        let padding_cstr = padding.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            padding_cstr.as_ptr() as *mut c_void,
            padding.as_bytes().len() + 1,
        );

        let attr_name = CString::new("data_format").unwrap();
        let data_format_cstr = data_format.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            data_format_cstr.as_ptr() as *mut c_void,
            data_format.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn maximum<T>(ctx: &Context, x: T, y: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Maximum").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, y.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn mean<T>(
    ctx: &Context,
    input: T,
    reduction_indices: T,
    keep_dims: bool,
    Tidx: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Mean").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, reduction_indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("keep_dims").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), keep_dims as u8);

        let attr_name = CString::new("Tidx").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tidx.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn merge_summary<T>(ctx: &Context, inputs: &Vec<T>) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("MergeSummary").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        let mut inputs_handles: Vec<*mut tf::TFE_TensorHandle> = inputs
            .into_iter()
            .map(|t| t.to_handle().unwrap().inner)
            .collect();
        tf::TFE_OpAddInputList(
            op,
            inputs_handles.as_mut_ptr(),
            inputs.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("N").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), inputs.len() as i64);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn mfcc<T>(
    ctx: &Context,
    spectrogram: T,
    sample_rate: T,
    upper_frequency_limit: f32,
    lower_frequency_limit: f32,
    filterbank_channel_count: i64,
    dct_coefficient_count: i64,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Mfcc").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, spectrogram.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, sample_rate.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("upper_frequency_limit").unwrap();
        tf::TFE_OpSetAttrFloat(op, attr_name.as_ptr(), upper_frequency_limit);

        let attr_name = CString::new("lower_frequency_limit").unwrap();
        tf::TFE_OpSetAttrFloat(op, attr_name.as_ptr(), lower_frequency_limit);

        let attr_name = CString::new("filterbank_channel_count").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), filterbank_channel_count);

        let attr_name = CString::new("dct_coefficient_count").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), dct_coefficient_count);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn min<T>(
    ctx: &Context,
    input: T,
    reduction_indices: T,
    keep_dims: bool,
    Tidx: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Min").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, reduction_indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("keep_dims").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), keep_dims as u8);

        let attr_name = CString::new("Tidx").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tidx.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn minimum<T>(ctx: &Context, x: T, y: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Minimum").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, y.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn mirror_pad<T>(
    ctx: &Context,
    input: T,
    paddings: T,
    mode: &String,
    Tpaddings: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("MirrorPad").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, paddings.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("mode").unwrap();
        let mode_cstr = mode.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            mode_cstr.as_ptr() as *mut c_void,
            mode.as_bytes().len() + 1,
        );

        let attr_name = CString::new("Tpaddings").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tpaddings.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn mirror_pad_grad<T>(
    ctx: &Context,
    input: T,
    paddings: T,
    mode: &String,
    Tpaddings: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("MirrorPadGrad").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, paddings.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("mode").unwrap();
        let mode_cstr = mode.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            mode_cstr.as_ptr() as *mut c_void,
            mode.as_bytes().len() + 1,
        );

        let attr_name = CString::new("Tpaddings").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tpaddings.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn mod_<T>(ctx: &Context, x: T, y: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Mod").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, y.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn mod_el_dataset<T>(
    ctx: &Context,
    input_dataset: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
    algorithm: i64,
    cpu_budget: i64,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ModelDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        let attr_name = CString::new("algorithm").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), algorithm);

        let attr_name = CString::new("cpu_budget").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), cpu_budget);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn mul<T>(ctx: &Context, x: T, y: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Mul").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, y.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn mul_no_nan<T>(ctx: &Context, x: T, y: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("MulNoNan").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, y.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn multi_device_iterator<T>(
    ctx: &Context,
    devices: &Vec<String>,
    shared_name: &String,
    container: &String,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("MultiDeviceIterator").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let devices_cstr: Vec<CString> = devices
            .into_iter()
            .map(|v| CString::new(v.as_bytes()).unwrap())
            .collect();
        let devices_ptr: Vec<*const c_void> = devices_cstr
            .as_slice()
            .into_iter()
            .map(|v| v.as_ptr() as *const c_void)
            .collect();
        let devices_sizes: Vec<usize> = devices_cstr
            .as_slice()
            .into_iter()
            .map(|v| v.as_bytes().len())
            .collect();
        let attr_name = CString::new("devices").unwrap();
        tf::TFE_OpSetAttrStringList(
            op,
            attr_name.as_ptr(),
            devices_ptr.as_ptr(),
            devices_sizes.as_ptr(),
            devices.len() as i32,
        );

        let attr_name = CString::new("shared_name").unwrap();
        let shared_name_cstr = shared_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            shared_name_cstr.as_ptr() as *mut c_void,
            shared_name.as_bytes().len() + 1,
        );

        let attr_name = CString::new("container").unwrap();
        let container_cstr = container.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            container_cstr.as_ptr() as *mut c_void,
            container.as_bytes().len() + 1,
        );

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn multi_device_iterator_from_string_handle<T>(
    ctx: &Context,
    string_handle: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("MultiDeviceIteratorFromStringHandle").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, string_handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn multi_device_iterator_get_next_from_shard<T>(
    ctx: &Context,
    multi_device_iterator: T,
    shard_num: T,
    incarnation_id: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("MultiDeviceIteratorGetNextFromShard").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, multi_device_iterator.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, shard_num.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, incarnation_id.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn multi_device_iterator_init<T>(
    ctx: &Context,
    dataset: T,
    multi_device_iterator: T,
    max_buffer_size: T,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("MultiDeviceIteratorInit").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, multi_device_iterator.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, max_buffer_size.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn multi_device_iterator_to_string_handle<T>(
    ctx: &Context,
    multi_device_iterator: T,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("MultiDeviceIteratorToStringHandle").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, multi_device_iterator.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn multinomial<T>(
    ctx: &Context,
    logits: T,
    num_samples: T,
    seed: i64,
    seed2: i64,
    output_dtype_: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Multinomial").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, logits.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, num_samples.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("seed").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), seed);

        let attr_name = CString::new("seed2").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), seed2);

        let attr_name = CString::new("output_dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), output_dtype_.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn mutable_dense_hash_table<T>(
    ctx: &Context,
    empty_key: T,
    key_dtype_: DataType,
    value_dtype_: DataType,
    value_shape: &Vec<i64>,
    container: &String,
    shared_name: &String,
    use_node_name_sharing: bool,
    initial_num_buckets: i64,
    max_load_factor: f32,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("MutableDenseHashTable").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, empty_key.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("key_dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), key_dtype_.to_c());

        let attr_name = CString::new("value_dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), value_dtype_.to_c());

        let attr_name = CString::new("value_shape").unwrap();
        tf::TFE_OpSetAttrShape(
            op,
            attr_name.as_ptr(),
            value_shape.as_ptr(),
            value_shape.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        let attr_name = CString::new("container").unwrap();
        let container_cstr = container.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            container_cstr.as_ptr() as *mut c_void,
            container.as_bytes().len() + 1,
        );

        let attr_name = CString::new("shared_name").unwrap();
        let shared_name_cstr = shared_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            shared_name_cstr.as_ptr() as *mut c_void,
            shared_name.as_bytes().len() + 1,
        );

        let attr_name = CString::new("use_node_name_sharing").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), use_node_name_sharing as u8);

        let attr_name = CString::new("initial_num_buckets").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), initial_num_buckets);

        let attr_name = CString::new("max_load_factor").unwrap();
        tf::TFE_OpSetAttrFloat(op, attr_name.as_ptr(), max_load_factor);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn mutable_dense_hash_table_v2<T>(
    ctx: &Context,
    empty_key: T,
    deleted_key: T,
    key_dtype_: DataType,
    value_dtype_: DataType,
    value_shape: &Vec<i64>,
    container: &String,
    shared_name: &String,
    use_node_name_sharing: bool,
    initial_num_buckets: i64,
    max_load_factor: f32,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("MutableDenseHashTableV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, empty_key.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, deleted_key.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("key_dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), key_dtype_.to_c());

        let attr_name = CString::new("value_dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), value_dtype_.to_c());

        let attr_name = CString::new("value_shape").unwrap();
        tf::TFE_OpSetAttrShape(
            op,
            attr_name.as_ptr(),
            value_shape.as_ptr(),
            value_shape.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        let attr_name = CString::new("container").unwrap();
        let container_cstr = container.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            container_cstr.as_ptr() as *mut c_void,
            container.as_bytes().len() + 1,
        );

        let attr_name = CString::new("shared_name").unwrap();
        let shared_name_cstr = shared_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            shared_name_cstr.as_ptr() as *mut c_void,
            shared_name.as_bytes().len() + 1,
        );

        let attr_name = CString::new("use_node_name_sharing").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), use_node_name_sharing as u8);

        let attr_name = CString::new("initial_num_buckets").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), initial_num_buckets);

        let attr_name = CString::new("max_load_factor").unwrap();
        tf::TFE_OpSetAttrFloat(op, attr_name.as_ptr(), max_load_factor);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn mutable_hash_table<T>(
    ctx: &Context,
    key_dtype_: DataType,
    value_dtype_: DataType,
    container: &String,
    shared_name: &String,
    use_node_name_sharing: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("MutableHashTable").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("key_dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), key_dtype_.to_c());

        let attr_name = CString::new("value_dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), value_dtype_.to_c());

        let attr_name = CString::new("container").unwrap();
        let container_cstr = container.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            container_cstr.as_ptr() as *mut c_void,
            container.as_bytes().len() + 1,
        );

        let attr_name = CString::new("shared_name").unwrap();
        let shared_name_cstr = shared_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            shared_name_cstr.as_ptr() as *mut c_void,
            shared_name.as_bytes().len() + 1,
        );

        let attr_name = CString::new("use_node_name_sharing").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), use_node_name_sharing as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn mutable_hash_table_of_tensors<T>(
    ctx: &Context,
    key_dtype_: DataType,
    value_dtype_: DataType,
    value_shape: &Vec<i64>,
    container: &String,
    shared_name: &String,
    use_node_name_sharing: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("MutableHashTableOfTensors").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("key_dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), key_dtype_.to_c());

        let attr_name = CString::new("value_dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), value_dtype_.to_c());

        let attr_name = CString::new("value_shape").unwrap();
        tf::TFE_OpSetAttrShape(
            op,
            attr_name.as_ptr(),
            value_shape.as_ptr(),
            value_shape.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        let attr_name = CString::new("container").unwrap();
        let container_cstr = container.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            container_cstr.as_ptr() as *mut c_void,
            container.as_bytes().len() + 1,
        );

        let attr_name = CString::new("shared_name").unwrap();
        let shared_name_cstr = shared_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            shared_name_cstr.as_ptr() as *mut c_void,
            shared_name.as_bytes().len() + 1,
        );

        let attr_name = CString::new("use_node_name_sharing").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), use_node_name_sharing as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn mutable_hash_table_of_tensors_v2<T>(
    ctx: &Context,
    key_dtype_: DataType,
    value_dtype_: DataType,
    value_shape: &Vec<i64>,
    container: &String,
    shared_name: &String,
    use_node_name_sharing: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("MutableHashTableOfTensorsV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("key_dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), key_dtype_.to_c());

        let attr_name = CString::new("value_dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), value_dtype_.to_c());

        let attr_name = CString::new("value_shape").unwrap();
        tf::TFE_OpSetAttrShape(
            op,
            attr_name.as_ptr(),
            value_shape.as_ptr(),
            value_shape.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        let attr_name = CString::new("container").unwrap();
        let container_cstr = container.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            container_cstr.as_ptr() as *mut c_void,
            container.as_bytes().len() + 1,
        );

        let attr_name = CString::new("shared_name").unwrap();
        let shared_name_cstr = shared_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            shared_name_cstr.as_ptr() as *mut c_void,
            shared_name.as_bytes().len() + 1,
        );

        let attr_name = CString::new("use_node_name_sharing").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), use_node_name_sharing as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn mutable_hash_table_v2<T>(
    ctx: &Context,
    key_dtype_: DataType,
    value_dtype_: DataType,
    container: &String,
    shared_name: &String,
    use_node_name_sharing: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("MutableHashTableV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("key_dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), key_dtype_.to_c());

        let attr_name = CString::new("value_dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), value_dtype_.to_c());

        let attr_name = CString::new("container").unwrap();
        let container_cstr = container.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            container_cstr.as_ptr() as *mut c_void,
            container.as_bytes().len() + 1,
        );

        let attr_name = CString::new("shared_name").unwrap();
        let shared_name_cstr = shared_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            shared_name_cstr.as_ptr() as *mut c_void,
            shared_name.as_bytes().len() + 1,
        );

        let attr_name = CString::new("use_node_name_sharing").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), use_node_name_sharing as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn mutex_lock<T>(ctx: &Context, mutex: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("MutexLock").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, mutex.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn mutex_v2<T>(ctx: &Context, container: &String, shared_name: &String) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("MutexV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("container").unwrap();
        let container_cstr = container.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            container_cstr.as_ptr() as *mut c_void,
            container.as_bytes().len() + 1,
        );

        let attr_name = CString::new("shared_name").unwrap();
        let shared_name_cstr = shared_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            shared_name_cstr.as_ptr() as *mut c_void,
            shared_name.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn nccl_all_reduce<T>(
    ctx: &Context,
    input: T,
    reduction: &String,
    num_devices: i64,
    shared_name: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("NcclAllReduce").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("reduction").unwrap();
        let reduction_cstr = reduction.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            reduction_cstr.as_ptr() as *mut c_void,
            reduction.as_bytes().len() + 1,
        );

        let attr_name = CString::new("num_devices").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), num_devices);

        let attr_name = CString::new("shared_name").unwrap();
        let shared_name_cstr = shared_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            shared_name_cstr.as_ptr() as *mut c_void,
            shared_name.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn nccl_broadcast<T>(ctx: &Context, input: T, shape: &Vec<i64>) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("NcclBroadcast").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("shape").unwrap();
        tf::TFE_OpSetAttrShape(
            op,
            attr_name.as_ptr(),
            shape.as_ptr(),
            shape.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn nccl_reduce<T>(ctx: &Context, input: &Vec<T>, reduction: &String) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("NcclReduce").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        let mut input_handles: Vec<*mut tf::TFE_TensorHandle> = input
            .into_iter()
            .map(|t| t.to_handle().unwrap().inner)
            .collect();
        tf::TFE_OpAddInputList(
            op,
            input_handles.as_mut_ptr(),
            input.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("reduction").unwrap();
        let reduction_cstr = reduction.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            reduction_cstr.as_ptr() as *mut c_void,
            reduction.as_bytes().len() + 1,
        );

        let attr_name = CString::new("num_devices").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), input.len() as i64);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn ndtri<T>(ctx: &Context, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Ndtri").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn neg<T>(ctx: &Context, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Neg").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn next_after<T>(ctx: &Context, x1: T, x2: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("NextAfter").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x1.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, x2.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn next_iteration<T>(ctx: &Context, data: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("NextIteration").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, data.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn non_deterministic_ints<T>(
    ctx: &Context,
    shape: T,
    dtype_: DataType,
    shape_dtype_: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("NonDeterministicInts").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), dtype_.to_c());

        let attr_name = CString::new("shape_dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), shape_dtype_.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn non_max_suppression<T>(
    ctx: &Context,
    boxes: T,
    scores: T,
    max_output_size: T,
    iou_threshold: f32,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("NonMaxSuppression").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, boxes.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, scores.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, max_output_size.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("iou_threshold").unwrap();
        tf::TFE_OpSetAttrFloat(op, attr_name.as_ptr(), iou_threshold);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn non_max_suppression_v2<T>(
    ctx: &Context,
    boxes: T,
    scores: T,
    max_output_size: T,
    iou_threshold: T,
    T_threshold: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("NonMaxSuppressionV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, boxes.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, scores.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, max_output_size.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, iou_threshold.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("T_threshold").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), T_threshold.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn non_max_suppression_v3<T>(
    ctx: &Context,
    boxes: T,
    scores: T,
    max_output_size: T,
    iou_threshold: T,
    score_threshold: T,
    T_threshold: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("NonMaxSuppressionV3").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, boxes.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, scores.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, max_output_size.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, iou_threshold.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, score_threshold.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("T_threshold").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), T_threshold.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn non_max_suppression_with_overlaps<T>(
    ctx: &Context,
    overlaps: T,
    scores: T,
    max_output_size: T,
    overlap_threshold: T,
    score_threshold: T,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("NonMaxSuppressionWithOverlaps").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, overlaps.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, scores.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, max_output_size.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, overlap_threshold.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, score_threshold.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn non_serializable_dataset<T>(
    ctx: &Context,
    input_dataset: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("NonSerializableDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn not_equal<T>(
    ctx: &Context,
    x: T,
    y: T,
    incompatible_shape_error: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("NotEqual").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, y.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("incompatible_shape_error").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), incompatible_shape_error as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn nth_element<T>(ctx: &Context, input: T, n: T, reverse: bool) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("NthElement").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, n.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("reverse").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), reverse as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn one_hot<T>(
    ctx: &Context,
    indices: T,
    depth: T,
    on_value: T,
    off_value: T,
    axis: i64,
    TI: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("OneHot").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, depth.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, on_value.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, off_value.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("axis").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), axis);

        let attr_name = CString::new("TI").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), TI.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn ones_like<T>(ctx: &Context, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("OnesLike").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn optimize_dataset<T>(
    ctx: &Context,
    input_dataset: T,
    optimizations: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
    optimization_configs: &Vec<String>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("OptimizeDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, optimizations.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        let optimization_configs_cstr: Vec<CString> = optimization_configs
            .into_iter()
            .map(|v| CString::new(v.as_bytes()).unwrap())
            .collect();
        let optimization_configs_ptr: Vec<*const c_void> = optimization_configs_cstr
            .as_slice()
            .into_iter()
            .map(|v| v.as_ptr() as *const c_void)
            .collect();
        let optimization_configs_sizes: Vec<usize> = optimization_configs_cstr
            .as_slice()
            .into_iter()
            .map(|v| v.as_bytes().len())
            .collect();
        let attr_name = CString::new("optimization_configs").unwrap();
        tf::TFE_OpSetAttrStringList(
            op,
            attr_name.as_ptr(),
            optimization_configs_ptr.as_ptr(),
            optimization_configs_sizes.as_ptr(),
            optimization_configs.len() as i32,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn optional_from_value<T>(
    ctx: &Context,
    components: &Vec<T>,
    Toutput_type_s: &Vec<DataType>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("OptionalFromValue").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        let mut components_handles: Vec<*mut tf::TFE_TensorHandle> = components
            .into_iter()
            .map(|t| t.to_handle().unwrap().inner)
            .collect();
        tf::TFE_OpAddInputList(
            op,
            components_handles.as_mut_ptr(),
            components.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Toutput_type_s").unwrap();
        let Toutput_type_s: Vec<tf::TF_DataType> =
            Toutput_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            Toutput_type_s.as_ptr(),
            Toutput_type_s.len() as i32,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn optional_get_value<T>(
    ctx: &Context,
    optional: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("OptionalGetValue").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, optional.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn optional_has_value<T>(ctx: &Context, optional: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("OptionalHasValue").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, optional.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn optional_none<T>(ctx: &Context) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("OptionalNone").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn ordered_map_incomplete_size<T>(
    ctx: &Context,
    dtype_s: &Vec<DataType>,
    capacity: i64,
    memory_limit: i64,
    container: &String,
    shared_name: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("OrderedMapIncompleteSize").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("dtype_s").unwrap();
        let dtype_s: Vec<tf::TF_DataType> = dtype_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            dtype_s.as_ptr(),
            dtype_s.len() as i32,
        );

        let attr_name = CString::new("capacity").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), capacity);

        let attr_name = CString::new("memory_limit").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), memory_limit);

        let attr_name = CString::new("container").unwrap();
        let container_cstr = container.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            container_cstr.as_ptr() as *mut c_void,
            container.as_bytes().len() + 1,
        );

        let attr_name = CString::new("shared_name").unwrap();
        let shared_name_cstr = shared_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            shared_name_cstr.as_ptr() as *mut c_void,
            shared_name.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn ordered_map_peek<T>(
    ctx: &Context,
    key: T,
    indices: T,
    dtype_s: &Vec<DataType>,
    capacity: i64,
    memory_limit: i64,
    container: &String,
    shared_name: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("OrderedMapPeek").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, key.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("dtype_s").unwrap();
        let dtype_s: Vec<tf::TF_DataType> = dtype_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            dtype_s.as_ptr(),
            dtype_s.len() as i32,
        );

        let attr_name = CString::new("capacity").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), capacity);

        let attr_name = CString::new("memory_limit").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), memory_limit);

        let attr_name = CString::new("container").unwrap();
        let container_cstr = container.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            container_cstr.as_ptr() as *mut c_void,
            container.as_bytes().len() + 1,
        );

        let attr_name = CString::new("shared_name").unwrap();
        let shared_name_cstr = shared_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            shared_name_cstr.as_ptr() as *mut c_void,
            shared_name.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn ordered_map_size<T>(
    ctx: &Context,
    dtype_s: &Vec<DataType>,
    capacity: i64,
    memory_limit: i64,
    container: &String,
    shared_name: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("OrderedMapSize").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("dtype_s").unwrap();
        let dtype_s: Vec<tf::TF_DataType> = dtype_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            dtype_s.as_ptr(),
            dtype_s.len() as i32,
        );

        let attr_name = CString::new("capacity").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), capacity);

        let attr_name = CString::new("memory_limit").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), memory_limit);

        let attr_name = CString::new("container").unwrap();
        let container_cstr = container.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            container_cstr.as_ptr() as *mut c_void,
            container.as_bytes().len() + 1,
        );

        let attr_name = CString::new("shared_name").unwrap();
        let shared_name_cstr = shared_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            shared_name_cstr.as_ptr() as *mut c_void,
            shared_name.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn ordered_map_unstage<T>(
    ctx: &Context,
    key: T,
    indices: T,
    dtype_s: &Vec<DataType>,
    capacity: i64,
    memory_limit: i64,
    container: &String,
    shared_name: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("OrderedMapUnstage").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, key.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("dtype_s").unwrap();
        let dtype_s: Vec<tf::TF_DataType> = dtype_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            dtype_s.as_ptr(),
            dtype_s.len() as i32,
        );

        let attr_name = CString::new("capacity").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), capacity);

        let attr_name = CString::new("memory_limit").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), memory_limit);

        let attr_name = CString::new("container").unwrap();
        let container_cstr = container.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            container_cstr.as_ptr() as *mut c_void,
            container.as_bytes().len() + 1,
        );

        let attr_name = CString::new("shared_name").unwrap();
        let shared_name_cstr = shared_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            shared_name_cstr.as_ptr() as *mut c_void,
            shared_name.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn outfeed_dequeue<T>(
    ctx: &Context,
    dtype_: DataType,
    shape: &Vec<i64>,
    device_ordinal: i64,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("OutfeedDequeue").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), dtype_.to_c());

        let attr_name = CString::new("shape").unwrap();
        tf::TFE_OpSetAttrShape(
            op,
            attr_name.as_ptr(),
            shape.as_ptr(),
            shape.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        let attr_name = CString::new("device_ordinal").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), device_ordinal);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn outfeed_dequeue_tuple<T>(
    ctx: &Context,
    dtype_s: &Vec<DataType>,
    shapes: &Vec<Vec<i64>>,
    device_ordinal: i64,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("OutfeedDequeueTuple").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("dtype_s").unwrap();
        let dtype_s: Vec<tf::TF_DataType> = dtype_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            dtype_s.as_ptr(),
            dtype_s.len() as i32,
        );

        let mut shapes_values: Vec<*const i64> = shapes.into_iter().map(|v| v.as_ptr()).collect();
        let shapes_ndims: Vec<i32> = shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            shapes_values.as_mut_ptr(),
            shapes_ndims.as_ptr(),
            shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        let attr_name = CString::new("device_ordinal").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), device_ordinal);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn pack<T>(ctx: &Context, values: &Vec<T>, axis: i64) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Pack").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        let mut values_handles: Vec<*mut tf::TFE_TensorHandle> = values
            .into_iter()
            .map(|t| t.to_handle().unwrap().inner)
            .collect();
        tf::TFE_OpAddInputList(
            op,
            values_handles.as_mut_ptr(),
            values.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("N").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), values.len() as i64);

        let attr_name = CString::new("axis").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), axis);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn pad<T>(ctx: &Context, input: T, paddings: T, Tpaddings: DataType) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Pad").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, paddings.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tpaddings").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tpaddings.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn pad_v2<T>(
    ctx: &Context,
    input: T,
    paddings: T,
    constant_values: T,
    Tpaddings: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("PadV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, paddings.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, constant_values.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tpaddings").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tpaddings.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn padded_batch_dataset<T>(
    ctx: &Context,
    input_dataset: T,
    batch_size: T,
    padded_shapes: &Vec<T>,
    padding_values: &Vec<T>,
    Toutput_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("PaddedBatchDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, batch_size.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        let mut padded_shapes_handles: Vec<*mut tf::TFE_TensorHandle> = padded_shapes
            .into_iter()
            .map(|t| t.to_handle().unwrap().inner)
            .collect();
        tf::TFE_OpAddInputList(
            op,
            padded_shapes_handles.as_mut_ptr(),
            padded_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        let mut padding_values_handles: Vec<*mut tf::TFE_TensorHandle> = padding_values
            .into_iter()
            .map(|t| t.to_handle().unwrap().inner)
            .collect();
        tf::TFE_OpAddInputList(
            op,
            padding_values_handles.as_mut_ptr(),
            padding_values.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Toutput_type_s").unwrap();
        let Toutput_type_s: Vec<tf::TF_DataType> =
            Toutput_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            Toutput_type_s.as_ptr(),
            Toutput_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        let attr_name = CString::new("N").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), padded_shapes.len() as i64);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn padded_batch_dataset_v2<T>(
    ctx: &Context,
    input_dataset: T,
    batch_size: T,
    padded_shapes: &Vec<T>,
    padding_values: &Vec<T>,
    drop_remainder: T,
    Toutput_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
    parallel_copy: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("PaddedBatchDatasetV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, batch_size.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        let mut padded_shapes_handles: Vec<*mut tf::TFE_TensorHandle> = padded_shapes
            .into_iter()
            .map(|t| t.to_handle().unwrap().inner)
            .collect();
        tf::TFE_OpAddInputList(
            op,
            padded_shapes_handles.as_mut_ptr(),
            padded_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        let mut padding_values_handles: Vec<*mut tf::TFE_TensorHandle> = padding_values
            .into_iter()
            .map(|t| t.to_handle().unwrap().inner)
            .collect();
        tf::TFE_OpAddInputList(
            op,
            padding_values_handles.as_mut_ptr(),
            padding_values.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, drop_remainder.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Toutput_type_s").unwrap();
        let Toutput_type_s: Vec<tf::TF_DataType> =
            Toutput_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            Toutput_type_s.as_ptr(),
            Toutput_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        let attr_name = CString::new("N").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), padded_shapes.len() as i64);

        let attr_name = CString::new("parallel_copy").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), parallel_copy as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn padding_f_i_f_o_queue<T>(
    ctx: &Context,
    component_type_s: &Vec<DataType>,
    shapes: &Vec<Vec<i64>>,
    capacity: i64,
    container: &String,
    shared_name: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("PaddingFIFOQueue").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("component_type_s").unwrap();
        let component_type_s: Vec<tf::TF_DataType> =
            component_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            component_type_s.as_ptr(),
            component_type_s.len() as i32,
        );

        let mut shapes_values: Vec<*const i64> = shapes.into_iter().map(|v| v.as_ptr()).collect();
        let shapes_ndims: Vec<i32> = shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            shapes_values.as_mut_ptr(),
            shapes_ndims.as_ptr(),
            shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        let attr_name = CString::new("capacity").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), capacity);

        let attr_name = CString::new("container").unwrap();
        let container_cstr = container.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            container_cstr.as_ptr() as *mut c_void,
            container.as_bytes().len() + 1,
        );

        let attr_name = CString::new("shared_name").unwrap();
        let shared_name_cstr = shared_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            shared_name_cstr.as_ptr() as *mut c_void,
            shared_name.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn padding_f_i_f_o_queue_v2<T>(
    ctx: &Context,
    component_type_s: &Vec<DataType>,
    shapes: &Vec<Vec<i64>>,
    capacity: i64,
    container: &String,
    shared_name: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("PaddingFIFOQueueV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("component_type_s").unwrap();
        let component_type_s: Vec<tf::TF_DataType> =
            component_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            component_type_s.as_ptr(),
            component_type_s.len() as i32,
        );

        let mut shapes_values: Vec<*const i64> = shapes.into_iter().map(|v| v.as_ptr()).collect();
        let shapes_ndims: Vec<i32> = shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            shapes_values.as_mut_ptr(),
            shapes_ndims.as_ptr(),
            shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        let attr_name = CString::new("capacity").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), capacity);

        let attr_name = CString::new("container").unwrap();
        let container_cstr = container.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            container_cstr.as_ptr() as *mut c_void,
            container.as_bytes().len() + 1,
        );

        let attr_name = CString::new("shared_name").unwrap();
        let shared_name_cstr = shared_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            shared_name_cstr.as_ptr() as *mut c_void,
            shared_name.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn parallel_concat<T>(ctx: &Context, values: &Vec<T>, shape: &Vec<i64>) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ParallelConcat").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        let mut values_handles: Vec<*mut tf::TFE_TensorHandle> = values
            .into_iter()
            .map(|t| t.to_handle().unwrap().inner)
            .collect();
        tf::TFE_OpAddInputList(
            op,
            values_handles.as_mut_ptr(),
            values.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("N").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), values.len() as i64);

        let attr_name = CString::new("shape").unwrap();
        tf::TFE_OpSetAttrShape(
            op,
            attr_name.as_ptr(),
            shape.as_ptr(),
            shape.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn parallel_dynamic_stitch<T>(
    ctx: &Context,
    indices: &Vec<T>,
    data: &Vec<T>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ParallelDynamicStitch").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        let mut indices_handles: Vec<*mut tf::TFE_TensorHandle> = indices
            .into_iter()
            .map(|t| t.to_handle().unwrap().inner)
            .collect();
        tf::TFE_OpAddInputList(
            op,
            indices_handles.as_mut_ptr(),
            indices.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        let mut data_handles: Vec<*mut tf::TFE_TensorHandle> = data
            .into_iter()
            .map(|t| t.to_handle().unwrap().inner)
            .collect();
        tf::TFE_OpAddInputList(
            op,
            data_handles.as_mut_ptr(),
            data.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("N").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), indices.len() as i64);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn parameterized_truncated_normal<T>(
    ctx: &Context,
    shape: T,
    means: T,
    stdevs: T,
    minvals: T,
    maxvals: T,
    dtype_: DataType,
    seed: i64,
    seed2: i64,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ParameterizedTruncatedNormal").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, means.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, stdevs.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, minvals.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, maxvals.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), dtype_.to_c());

        let attr_name = CString::new("seed").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), seed);

        let attr_name = CString::new("seed2").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), seed2);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn parse_example_dataset<T>(
    ctx: &Context,
    input_dataset: T,
    num_parallel_calls: T,
    dense_defaults: &Vec<T>,
    sparse_keys: &Vec<String>,
    dense_keys: &Vec<String>,
    sparse_type_s: &Vec<DataType>,
    Tdense: &Vec<DataType>,
    dense_shapes: &Vec<Vec<i64>>,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
    ragged_keys: &Vec<String>,
    ragged_value_type_s: &Vec<DataType>,
    ragged_split_type_s: &Vec<DataType>,
    sloppy: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ParseExampleDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, num_parallel_calls.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        let mut dense_defaults_handles: Vec<*mut tf::TFE_TensorHandle> = dense_defaults
            .into_iter()
            .map(|t| t.to_handle().unwrap().inner)
            .collect();
        tf::TFE_OpAddInputList(
            op,
            dense_defaults_handles.as_mut_ptr(),
            dense_defaults.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Attributes

        let sparse_keys_cstr: Vec<CString> = sparse_keys
            .into_iter()
            .map(|v| CString::new(v.as_bytes()).unwrap())
            .collect();
        let sparse_keys_ptr: Vec<*const c_void> = sparse_keys_cstr
            .as_slice()
            .into_iter()
            .map(|v| v.as_ptr() as *const c_void)
            .collect();
        let sparse_keys_sizes: Vec<usize> = sparse_keys_cstr
            .as_slice()
            .into_iter()
            .map(|v| v.as_bytes().len())
            .collect();
        let attr_name = CString::new("sparse_keys").unwrap();
        tf::TFE_OpSetAttrStringList(
            op,
            attr_name.as_ptr(),
            sparse_keys_ptr.as_ptr(),
            sparse_keys_sizes.as_ptr(),
            sparse_keys.len() as i32,
        );

        let dense_keys_cstr: Vec<CString> = dense_keys
            .into_iter()
            .map(|v| CString::new(v.as_bytes()).unwrap())
            .collect();
        let dense_keys_ptr: Vec<*const c_void> = dense_keys_cstr
            .as_slice()
            .into_iter()
            .map(|v| v.as_ptr() as *const c_void)
            .collect();
        let dense_keys_sizes: Vec<usize> = dense_keys_cstr
            .as_slice()
            .into_iter()
            .map(|v| v.as_bytes().len())
            .collect();
        let attr_name = CString::new("dense_keys").unwrap();
        tf::TFE_OpSetAttrStringList(
            op,
            attr_name.as_ptr(),
            dense_keys_ptr.as_ptr(),
            dense_keys_sizes.as_ptr(),
            dense_keys.len() as i32,
        );

        let attr_name = CString::new("sparse_type_s").unwrap();
        let sparse_type_s: Vec<tf::TF_DataType> =
            sparse_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            sparse_type_s.as_ptr(),
            sparse_type_s.len() as i32,
        );

        let attr_name = CString::new("Tdense").unwrap();
        let Tdense: Vec<tf::TF_DataType> = Tdense.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(op, attr_name.as_ptr(), Tdense.as_ptr(), Tdense.len() as i32);

        let mut dense_shapes_values: Vec<*const i64> =
            dense_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let dense_shapes_ndims: Vec<i32> =
            dense_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("dense_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            dense_shapes_values.as_mut_ptr(),
            dense_shapes_ndims.as_ptr(),
            dense_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        let ragged_keys_cstr: Vec<CString> = ragged_keys
            .into_iter()
            .map(|v| CString::new(v.as_bytes()).unwrap())
            .collect();
        let ragged_keys_ptr: Vec<*const c_void> = ragged_keys_cstr
            .as_slice()
            .into_iter()
            .map(|v| v.as_ptr() as *const c_void)
            .collect();
        let ragged_keys_sizes: Vec<usize> = ragged_keys_cstr
            .as_slice()
            .into_iter()
            .map(|v| v.as_bytes().len())
            .collect();
        let attr_name = CString::new("ragged_keys").unwrap();
        tf::TFE_OpSetAttrStringList(
            op,
            attr_name.as_ptr(),
            ragged_keys_ptr.as_ptr(),
            ragged_keys_sizes.as_ptr(),
            ragged_keys.len() as i32,
        );

        let attr_name = CString::new("ragged_value_type_s").unwrap();
        let ragged_value_type_s: Vec<tf::TF_DataType> =
            ragged_value_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            ragged_value_type_s.as_ptr(),
            ragged_value_type_s.len() as i32,
        );

        let attr_name = CString::new("ragged_split_type_s").unwrap();
        let ragged_split_type_s: Vec<tf::TF_DataType> =
            ragged_split_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            ragged_split_type_s.as_ptr(),
            ragged_split_type_s.len() as i32,
        );

        let attr_name = CString::new("sloppy").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), sloppy as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn parse_example_dataset_v2<T>(
    ctx: &Context,
    input_dataset: T,
    num_parallel_calls: T,
    dense_defaults: &Vec<T>,
    sparse_keys: &Vec<String>,
    dense_keys: &Vec<String>,
    sparse_type_s: &Vec<DataType>,
    Tdense: &Vec<DataType>,
    dense_shapes: &Vec<Vec<i64>>,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
    ragged_keys: &Vec<String>,
    ragged_value_type_s: &Vec<DataType>,
    ragged_split_type_s: &Vec<DataType>,
    deterministic: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ParseExampleDatasetV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, num_parallel_calls.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        let mut dense_defaults_handles: Vec<*mut tf::TFE_TensorHandle> = dense_defaults
            .into_iter()
            .map(|t| t.to_handle().unwrap().inner)
            .collect();
        tf::TFE_OpAddInputList(
            op,
            dense_defaults_handles.as_mut_ptr(),
            dense_defaults.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Attributes

        let sparse_keys_cstr: Vec<CString> = sparse_keys
            .into_iter()
            .map(|v| CString::new(v.as_bytes()).unwrap())
            .collect();
        let sparse_keys_ptr: Vec<*const c_void> = sparse_keys_cstr
            .as_slice()
            .into_iter()
            .map(|v| v.as_ptr() as *const c_void)
            .collect();
        let sparse_keys_sizes: Vec<usize> = sparse_keys_cstr
            .as_slice()
            .into_iter()
            .map(|v| v.as_bytes().len())
            .collect();
        let attr_name = CString::new("sparse_keys").unwrap();
        tf::TFE_OpSetAttrStringList(
            op,
            attr_name.as_ptr(),
            sparse_keys_ptr.as_ptr(),
            sparse_keys_sizes.as_ptr(),
            sparse_keys.len() as i32,
        );

        let dense_keys_cstr: Vec<CString> = dense_keys
            .into_iter()
            .map(|v| CString::new(v.as_bytes()).unwrap())
            .collect();
        let dense_keys_ptr: Vec<*const c_void> = dense_keys_cstr
            .as_slice()
            .into_iter()
            .map(|v| v.as_ptr() as *const c_void)
            .collect();
        let dense_keys_sizes: Vec<usize> = dense_keys_cstr
            .as_slice()
            .into_iter()
            .map(|v| v.as_bytes().len())
            .collect();
        let attr_name = CString::new("dense_keys").unwrap();
        tf::TFE_OpSetAttrStringList(
            op,
            attr_name.as_ptr(),
            dense_keys_ptr.as_ptr(),
            dense_keys_sizes.as_ptr(),
            dense_keys.len() as i32,
        );

        let attr_name = CString::new("sparse_type_s").unwrap();
        let sparse_type_s: Vec<tf::TF_DataType> =
            sparse_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            sparse_type_s.as_ptr(),
            sparse_type_s.len() as i32,
        );

        let attr_name = CString::new("Tdense").unwrap();
        let Tdense: Vec<tf::TF_DataType> = Tdense.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(op, attr_name.as_ptr(), Tdense.as_ptr(), Tdense.len() as i32);

        let mut dense_shapes_values: Vec<*const i64> =
            dense_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let dense_shapes_ndims: Vec<i32> =
            dense_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("dense_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            dense_shapes_values.as_mut_ptr(),
            dense_shapes_ndims.as_ptr(),
            dense_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        let ragged_keys_cstr: Vec<CString> = ragged_keys
            .into_iter()
            .map(|v| CString::new(v.as_bytes()).unwrap())
            .collect();
        let ragged_keys_ptr: Vec<*const c_void> = ragged_keys_cstr
            .as_slice()
            .into_iter()
            .map(|v| v.as_ptr() as *const c_void)
            .collect();
        let ragged_keys_sizes: Vec<usize> = ragged_keys_cstr
            .as_slice()
            .into_iter()
            .map(|v| v.as_bytes().len())
            .collect();
        let attr_name = CString::new("ragged_keys").unwrap();
        tf::TFE_OpSetAttrStringList(
            op,
            attr_name.as_ptr(),
            ragged_keys_ptr.as_ptr(),
            ragged_keys_sizes.as_ptr(),
            ragged_keys.len() as i32,
        );

        let attr_name = CString::new("ragged_value_type_s").unwrap();
        let ragged_value_type_s: Vec<tf::TF_DataType> =
            ragged_value_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            ragged_value_type_s.as_ptr(),
            ragged_value_type_s.len() as i32,
        );

        let attr_name = CString::new("ragged_split_type_s").unwrap();
        let ragged_split_type_s: Vec<tf::TF_DataType> =
            ragged_split_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            ragged_split_type_s.as_ptr(),
            ragged_split_type_s.len() as i32,
        );

        let attr_name = CString::new("deterministic").unwrap();
        let deterministic_cstr = deterministic.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            deterministic_cstr.as_ptr() as *mut c_void,
            deterministic.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn parse_tensor<T>(ctx: &Context, serialized: T, out_type_: DataType) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ParseTensor").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, serialized.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("out_type_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), out_type_.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn placeholder<T>(ctx: &Context, dtype_: DataType, shape: &Vec<i64>) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Placeholder").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), dtype_.to_c());

        let attr_name = CString::new("shape").unwrap();
        tf::TFE_OpSetAttrShape(
            op,
            attr_name.as_ptr(),
            shape.as_ptr(),
            shape.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn placeholder_v2<T>(ctx: &Context, dtype_: DataType, shape: &Vec<i64>) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("PlaceholderV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), dtype_.to_c());

        let attr_name = CString::new("shape").unwrap();
        tf::TFE_OpSetAttrShape(
            op,
            attr_name.as_ptr(),
            shape.as_ptr(),
            shape.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn placeholder_with_default<T>(
    ctx: &Context,
    input: T,
    dtype_: DataType,
    shape: &Vec<i64>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("PlaceholderWithDefault").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), dtype_.to_c());

        let attr_name = CString::new("shape").unwrap();
        tf::TFE_OpSetAttrShape(
            op,
            attr_name.as_ptr(),
            shape.as_ptr(),
            shape.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn polygamma<T>(ctx: &Context, a: T, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Polygamma").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, a.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn population_count<T>(ctx: &Context, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("PopulationCount").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn pow<T>(ctx: &Context, x: T, y: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Pow").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, y.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn prefetch_dataset<T>(
    ctx: &Context,
    input_dataset: T,
    buffer_size: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
    slack_period: i64,
    legacy_autotune: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("PrefetchDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, buffer_size.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        let attr_name = CString::new("slack_period").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), slack_period);

        let attr_name = CString::new("legacy_autotune").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), legacy_autotune as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn prelinearize<T>(
    ctx: &Context,
    input: T,
    dtype_: DataType,
    shape: &Vec<i64>,
    layout: &Vec<i64>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Prelinearize").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), dtype_.to_c());

        let attr_name = CString::new("shape").unwrap();
        tf::TFE_OpSetAttrShape(
            op,
            attr_name.as_ptr(),
            shape.as_ptr(),
            shape.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        let attr_name = CString::new("layout").unwrap();
        tf::TFE_OpSetAttrIntList(op, attr_name.as_ptr(), layout.as_ptr(), layout.len() as i32);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn prelinearize_tuple<T>(
    ctx: &Context,
    inputs: &Vec<T>,
    dtype_s: &Vec<DataType>,
    shapes: &Vec<Vec<i64>>,
    layouts: &Vec<i64>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("PrelinearizeTuple").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        let mut inputs_handles: Vec<*mut tf::TFE_TensorHandle> = inputs
            .into_iter()
            .map(|t| t.to_handle().unwrap().inner)
            .collect();
        tf::TFE_OpAddInputList(
            op,
            inputs_handles.as_mut_ptr(),
            inputs.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("dtype_s").unwrap();
        let dtype_s: Vec<tf::TF_DataType> = dtype_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            dtype_s.as_ptr(),
            dtype_s.len() as i32,
        );

        let mut shapes_values: Vec<*const i64> = shapes.into_iter().map(|v| v.as_ptr()).collect();
        let shapes_ndims: Vec<i32> = shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            shapes_values.as_mut_ptr(),
            shapes_ndims.as_ptr(),
            shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        let attr_name = CString::new("layouts").unwrap();
        tf::TFE_OpSetAttrIntList(
            op,
            attr_name.as_ptr(),
            layouts.as_ptr(),
            layouts.len() as i32,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn prevent_gradient<T>(ctx: &Context, input: T, message: &String) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("PreventGradient").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("message").unwrap();
        let message_cstr = message.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            message_cstr.as_ptr() as *mut c_void,
            message.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn print<T>(
    ctx: &Context,
    input: T,
    data: &Vec<T>,
    U: &Vec<DataType>,
    message: &String,
    first_n: i64,
    summarize: i64,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Print").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        let mut data_handles: Vec<*mut tf::TFE_TensorHandle> = data
            .into_iter()
            .map(|t| t.to_handle().unwrap().inner)
            .collect();
        tf::TFE_OpAddInputList(
            op,
            data_handles.as_mut_ptr(),
            data.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("U").unwrap();
        let U: Vec<tf::TF_DataType> = U.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(op, attr_name.as_ptr(), U.as_ptr(), U.len() as i32);

        let attr_name = CString::new("message").unwrap();
        let message_cstr = message.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            message_cstr.as_ptr() as *mut c_void,
            message.as_bytes().len() + 1,
        );

        let attr_name = CString::new("first_n").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), first_n);

        let attr_name = CString::new("summarize").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), summarize);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn priority_queue<T>(
    ctx: &Context,
    component_type_s: &Vec<DataType>,
    shapes: &Vec<Vec<i64>>,
    capacity: i64,
    container: &String,
    shared_name: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("PriorityQueue").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("component_type_s").unwrap();
        let component_type_s: Vec<tf::TF_DataType> =
            component_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            component_type_s.as_ptr(),
            component_type_s.len() as i32,
        );

        let mut shapes_values: Vec<*const i64> = shapes.into_iter().map(|v| v.as_ptr()).collect();
        let shapes_ndims: Vec<i32> = shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            shapes_values.as_mut_ptr(),
            shapes_ndims.as_ptr(),
            shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        let attr_name = CString::new("capacity").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), capacity);

        let attr_name = CString::new("container").unwrap();
        let container_cstr = container.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            container_cstr.as_ptr() as *mut c_void,
            container.as_bytes().len() + 1,
        );

        let attr_name = CString::new("shared_name").unwrap();
        let shared_name_cstr = shared_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            shared_name_cstr.as_ptr() as *mut c_void,
            shared_name.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn priority_queue_v2<T>(
    ctx: &Context,
    component_type_s: &Vec<DataType>,
    shapes: &Vec<Vec<i64>>,
    capacity: i64,
    container: &String,
    shared_name: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("PriorityQueueV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("component_type_s").unwrap();
        let component_type_s: Vec<tf::TF_DataType> =
            component_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            component_type_s.as_ptr(),
            component_type_s.len() as i32,
        );

        let mut shapes_values: Vec<*const i64> = shapes.into_iter().map(|v| v.as_ptr()).collect();
        let shapes_ndims: Vec<i32> = shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            shapes_values.as_mut_ptr(),
            shapes_ndims.as_ptr(),
            shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        let attr_name = CString::new("capacity").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), capacity);

        let attr_name = CString::new("container").unwrap();
        let container_cstr = container.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            container_cstr.as_ptr() as *mut c_void,
            container.as_bytes().len() + 1,
        );

        let attr_name = CString::new("shared_name").unwrap();
        let shared_name_cstr = shared_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            shared_name_cstr.as_ptr() as *mut c_void,
            shared_name.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn private_thread_pool_dataset<T>(
    ctx: &Context,
    input_dataset: T,
    num_threads: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("PrivateThreadPoolDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, num_threads.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn prod<T>(
    ctx: &Context,
    input: T,
    reduction_indices: T,
    keep_dims: bool,
    Tidx: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Prod").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, reduction_indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("keep_dims").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), keep_dims as u8);

        let attr_name = CString::new("Tidx").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tidx.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn py_func<T>(
    ctx: &Context,
    input: &Vec<T>,
    token: &String,
    Tin: &Vec<DataType>,
    Tout: &Vec<DataType>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("PyFunc").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        let mut input_handles: Vec<*mut tf::TFE_TensorHandle> = input
            .into_iter()
            .map(|t| t.to_handle().unwrap().inner)
            .collect();
        tf::TFE_OpAddInputList(
            op,
            input_handles.as_mut_ptr(),
            input.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("token").unwrap();
        let token_cstr = token.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            token_cstr.as_ptr() as *mut c_void,
            token.as_bytes().len() + 1,
        );

        let attr_name = CString::new("Tin").unwrap();
        let Tin: Vec<tf::TF_DataType> = Tin.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(op, attr_name.as_ptr(), Tin.as_ptr(), Tin.len() as i32);

        let attr_name = CString::new("Tout").unwrap();
        let Tout: Vec<tf::TF_DataType> = Tout.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(op, attr_name.as_ptr(), Tout.as_ptr(), Tout.len() as i32);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn py_func_stateless<T>(
    ctx: &Context,
    input: &Vec<T>,
    token: &String,
    Tin: &Vec<DataType>,
    Tout: &Vec<DataType>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("PyFuncStateless").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        let mut input_handles: Vec<*mut tf::TFE_TensorHandle> = input
            .into_iter()
            .map(|t| t.to_handle().unwrap().inner)
            .collect();
        tf::TFE_OpAddInputList(
            op,
            input_handles.as_mut_ptr(),
            input.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("token").unwrap();
        let token_cstr = token.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            token_cstr.as_ptr() as *mut c_void,
            token.as_bytes().len() + 1,
        );

        let attr_name = CString::new("Tin").unwrap();
        let Tin: Vec<tf::TF_DataType> = Tin.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(op, attr_name.as_ptr(), Tin.as_ptr(), Tin.len() as i32);

        let attr_name = CString::new("Tout").unwrap();
        let Tout: Vec<tf::TF_DataType> = Tout.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(op, attr_name.as_ptr(), Tout.as_ptr(), Tout.len() as i32);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn quantize_and_dequantize<T>(
    ctx: &Context,
    input: T,
    signed_input: bool,
    num_bits: i64,
    range_given: bool,
    input_min: f32,
    input_max: f32,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("QuantizeAndDequantize").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("signed_input").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), signed_input as u8);

        let attr_name = CString::new("num_bits").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), num_bits);

        let attr_name = CString::new("range_given").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), range_given as u8);

        let attr_name = CString::new("input_min").unwrap();
        tf::TFE_OpSetAttrFloat(op, attr_name.as_ptr(), input_min);

        let attr_name = CString::new("input_max").unwrap();
        tf::TFE_OpSetAttrFloat(op, attr_name.as_ptr(), input_max);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn quantize_and_dequantize_v2<T>(
    ctx: &Context,
    input: T,
    input_min: T,
    input_max: T,
    signed_input: bool,
    num_bits: i64,
    range_given: bool,
    round_mode: &String,
    narrow_range: bool,
    axis: i64,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("QuantizeAndDequantizeV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, input_min.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, input_max.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("signed_input").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), signed_input as u8);

        let attr_name = CString::new("num_bits").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), num_bits);

        let attr_name = CString::new("range_given").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), range_given as u8);

        let attr_name = CString::new("round_mode").unwrap();
        let round_mode_cstr = round_mode.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            round_mode_cstr.as_ptr() as *mut c_void,
            round_mode.as_bytes().len() + 1,
        );

        let attr_name = CString::new("narrow_range").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), narrow_range as u8);

        let attr_name = CString::new("axis").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), axis);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn quantize_and_dequantize_v3<T>(
    ctx: &Context,
    input: T,
    input_min: T,
    input_max: T,
    num_bits: T,
    signed_input: bool,
    range_given: bool,
    narrow_range: bool,
    axis: i64,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("QuantizeAndDequantizeV3").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, input_min.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, input_max.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, num_bits.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("signed_input").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), signed_input as u8);

        let attr_name = CString::new("range_given").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), range_given as u8);

        let attr_name = CString::new("narrow_range").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), narrow_range as u8);

        let attr_name = CString::new("axis").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), axis);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn quantized_mat_mul_with_bias_and_dequantize<T>(
    ctx: &Context,
    a: T,
    b: T,
    bias: T,
    min_a: T,
    max_a: T,
    min_b: T,
    max_b: T,
    min_freezed_output: T,
    max_freezed_output: T,
    T1: DataType,
    T2: DataType,
    Tbias: DataType,
    Toutput: DataType,
    transpose_a: bool,
    transpose_b: bool,
    input_quant_mode: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("QuantizedMatMulWithBiasAndDequantize").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, a.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, b.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, bias.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, min_a.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, max_a.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, min_b.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, max_b.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, min_freezed_output.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, max_freezed_output.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("T1").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), T1.to_c());

        let attr_name = CString::new("T2").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), T2.to_c());

        let attr_name = CString::new("Tbias").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tbias.to_c());

        let attr_name = CString::new("Toutput").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Toutput.to_c());

        let attr_name = CString::new("transpose_a").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), transpose_a as u8);

        let attr_name = CString::new("transpose_b").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), transpose_b as u8);

        let attr_name = CString::new("input_quant_mode").unwrap();
        let input_quant_mode_cstr = input_quant_mode.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            input_quant_mode_cstr.as_ptr() as *mut c_void,
            input_quant_mode.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn queue_dequeue<T>(
    ctx: &Context,
    handle: T,
    component_type_s: &Vec<DataType>,
    timeout_ms: i64,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("QueueDequeue").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("component_type_s").unwrap();
        let component_type_s: Vec<tf::TF_DataType> =
            component_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            component_type_s.as_ptr(),
            component_type_s.len() as i32,
        );

        let attr_name = CString::new("timeout_ms").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), timeout_ms);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn queue_dequeue_many<T>(
    ctx: &Context,
    handle: T,
    n: T,
    component_type_s: &Vec<DataType>,
    timeout_ms: i64,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("QueueDequeueMany").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, n.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("component_type_s").unwrap();
        let component_type_s: Vec<tf::TF_DataType> =
            component_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            component_type_s.as_ptr(),
            component_type_s.len() as i32,
        );

        let attr_name = CString::new("timeout_ms").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), timeout_ms);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn queue_dequeue_many_v2<T>(
    ctx: &Context,
    handle: T,
    n: T,
    component_type_s: &Vec<DataType>,
    timeout_ms: i64,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("QueueDequeueManyV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, n.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("component_type_s").unwrap();
        let component_type_s: Vec<tf::TF_DataType> =
            component_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            component_type_s.as_ptr(),
            component_type_s.len() as i32,
        );

        let attr_name = CString::new("timeout_ms").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), timeout_ms);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn queue_dequeue_up_to<T>(
    ctx: &Context,
    handle: T,
    n: T,
    component_type_s: &Vec<DataType>,
    timeout_ms: i64,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("QueueDequeueUpTo").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, n.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("component_type_s").unwrap();
        let component_type_s: Vec<tf::TF_DataType> =
            component_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            component_type_s.as_ptr(),
            component_type_s.len() as i32,
        );

        let attr_name = CString::new("timeout_ms").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), timeout_ms);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn queue_dequeue_up_to_v2<T>(
    ctx: &Context,
    handle: T,
    n: T,
    component_type_s: &Vec<DataType>,
    timeout_ms: i64,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("QueueDequeueUpToV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, n.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("component_type_s").unwrap();
        let component_type_s: Vec<tf::TF_DataType> =
            component_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            component_type_s.as_ptr(),
            component_type_s.len() as i32,
        );

        let attr_name = CString::new("timeout_ms").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), timeout_ms);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn queue_dequeue_v2<T>(
    ctx: &Context,
    handle: T,
    component_type_s: &Vec<DataType>,
    timeout_ms: i64,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("QueueDequeueV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("component_type_s").unwrap();
        let component_type_s: Vec<tf::TF_DataType> =
            component_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            component_type_s.as_ptr(),
            component_type_s.len() as i32,
        );

        let attr_name = CString::new("timeout_ms").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), timeout_ms);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn queue_is_closed<T>(ctx: &Context, handle: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("QueueIsClosed").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn queue_is_closed_v2<T>(ctx: &Context, handle: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("QueueIsClosedV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn queue_size<T>(ctx: &Context, handle: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("QueueSize").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn queue_size_v2<T>(ctx: &Context, handle: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("QueueSizeV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn r_f_f_t<T>(
    ctx: &Context,
    input: T,
    fft_length: T,
    Treal: DataType,
    Tcomplex: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("RFFT").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, fft_length.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Treal").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Treal.to_c());

        let attr_name = CString::new("Tcomplex").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tcomplex.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn r_f_f_t2_d<T>(
    ctx: &Context,
    input: T,
    fft_length: T,
    Treal: DataType,
    Tcomplex: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("RFFT2D").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, fft_length.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Treal").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Treal.to_c());

        let attr_name = CString::new("Tcomplex").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tcomplex.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn r_f_f_t3_d<T>(
    ctx: &Context,
    input: T,
    fft_length: T,
    Treal: DataType,
    Tcomplex: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("RFFT3D").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, fft_length.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Treal").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Treal.to_c());

        let attr_name = CString::new("Tcomplex").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tcomplex.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn r_g_b_to_h_s_v<T>(ctx: &Context, images: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("RGBToHSV").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, images.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn ragged_bincount<T>(
    ctx: &Context,
    splits: T,
    values: T,
    size: T,
    weights: T,
    Tidx: DataType,
    binary_output: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("RaggedBincount").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, splits.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, values.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, size.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, weights.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tidx").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tidx.to_c());

        let attr_name = CString::new("binary_output").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), binary_output as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn ragged_tensor_to_tensor<T>(
    ctx: &Context,
    shape: T,
    values: T,
    default_value: T,
    row_partition_tensors: &Vec<T>,
    Tindex: DataType,
    Tshape: DataType,
    row_partition_type_s: &Vec<String>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("RaggedTensorToTensor").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, values.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, default_value.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        let mut row_partition_tensors_handles: Vec<*mut tf::TFE_TensorHandle> =
            row_partition_tensors
                .into_iter()
                .map(|t| t.to_handle().unwrap().inner)
                .collect();
        tf::TFE_OpAddInputList(
            op,
            row_partition_tensors_handles.as_mut_ptr(),
            row_partition_tensors.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tindex").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tindex.to_c());

        let attr_name = CString::new("Tshape").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tshape.to_c());

        let attr_name = CString::new("num_row_partition_tensors").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), row_partition_tensors.len() as i64);

        let row_partition_type_s_cstr: Vec<CString> = row_partition_type_s
            .into_iter()
            .map(|v| CString::new(v.as_bytes()).unwrap())
            .collect();
        let row_partition_type_s_ptr: Vec<*const c_void> = row_partition_type_s_cstr
            .as_slice()
            .into_iter()
            .map(|v| v.as_ptr() as *const c_void)
            .collect();
        let row_partition_type_s_sizes: Vec<usize> = row_partition_type_s_cstr
            .as_slice()
            .into_iter()
            .map(|v| v.as_bytes().len())
            .collect();
        let attr_name = CString::new("row_partition_type_s").unwrap();
        tf::TFE_OpSetAttrStringList(
            op,
            attr_name.as_ptr(),
            row_partition_type_s_ptr.as_ptr(),
            row_partition_type_s_sizes.as_ptr(),
            row_partition_type_s.len() as i32,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn ragged_tensor_to_variant<T>(
    ctx: &Context,
    rt_nested_splits: &Vec<T>,
    rt_dense_values: T,
    Tvalues: DataType,
    batched_input: bool,
    Tsplits: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("RaggedTensorToVariant").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        let mut rt_nested_splits_handles: Vec<*mut tf::TFE_TensorHandle> = rt_nested_splits
            .into_iter()
            .map(|t| t.to_handle().unwrap().inner)
            .collect();
        tf::TFE_OpAddInputList(
            op,
            rt_nested_splits_handles.as_mut_ptr(),
            rt_nested_splits.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, rt_dense_values.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("RAGGED_RANK").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), rt_nested_splits.len() as i64);

        let attr_name = CString::new("Tvalues").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tvalues.to_c());

        let attr_name = CString::new("batched_input").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), batched_input as u8);

        let attr_name = CString::new("Tsplits").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tsplits.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn random_crop<T>(
    ctx: &Context,
    image: T,
    size: T,
    seed: i64,
    seed2: i64,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("RandomCrop").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, image.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, size.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("seed").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), seed);

        let attr_name = CString::new("seed2").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), seed2);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn random_dataset<T>(
    ctx: &Context,
    seed: T,
    seed2: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("RandomDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, seed.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, seed2.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn random_gamma<T>(
    ctx: &Context,
    shape: T,
    alpha: T,
    S: DataType,
    seed: i64,
    seed2: i64,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("RandomGamma").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, alpha.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("S").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), S.to_c());

        let attr_name = CString::new("seed").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), seed);

        let attr_name = CString::new("seed2").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), seed2);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn random_gamma_grad<T>(ctx: &Context, alpha: T, sample: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("RandomGammaGrad").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, alpha.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, sample.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn random_poisson<T>(
    ctx: &Context,
    shape: T,
    rate: T,
    S: DataType,
    dtype_: DataType,
    seed: i64,
    seed2: i64,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("RandomPoisson").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, rate.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("S").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), S.to_c());

        let attr_name = CString::new("dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), dtype_.to_c());

        let attr_name = CString::new("seed").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), seed);

        let attr_name = CString::new("seed2").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), seed2);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn random_poisson_v2<T>(
    ctx: &Context,
    shape: T,
    rate: T,
    S: DataType,
    seed: i64,
    seed2: i64,
    R: DataType,
    dtype_: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("RandomPoissonV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, rate.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("S").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), S.to_c());

        let attr_name = CString::new("seed").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), seed);

        let attr_name = CString::new("seed2").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), seed2);

        let attr_name = CString::new("R").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), R.to_c());

        let attr_name = CString::new("dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), dtype_.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn random_shuffle<T>(ctx: &Context, value: T, seed: i64, seed2: i64) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("RandomShuffle").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, value.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("seed").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), seed);

        let attr_name = CString::new("seed2").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), seed2);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn random_shuffle_queue<T>(
    ctx: &Context,
    component_type_s: &Vec<DataType>,
    shapes: &Vec<Vec<i64>>,
    capacity: i64,
    min_after_dequeue: i64,
    seed: i64,
    seed2: i64,
    container: &String,
    shared_name: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("RandomShuffleQueue").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("component_type_s").unwrap();
        let component_type_s: Vec<tf::TF_DataType> =
            component_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            component_type_s.as_ptr(),
            component_type_s.len() as i32,
        );

        let mut shapes_values: Vec<*const i64> = shapes.into_iter().map(|v| v.as_ptr()).collect();
        let shapes_ndims: Vec<i32> = shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            shapes_values.as_mut_ptr(),
            shapes_ndims.as_ptr(),
            shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        let attr_name = CString::new("capacity").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), capacity);

        let attr_name = CString::new("min_after_dequeue").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), min_after_dequeue);

        let attr_name = CString::new("seed").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), seed);

        let attr_name = CString::new("seed2").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), seed2);

        let attr_name = CString::new("container").unwrap();
        let container_cstr = container.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            container_cstr.as_ptr() as *mut c_void,
            container.as_bytes().len() + 1,
        );

        let attr_name = CString::new("shared_name").unwrap();
        let shared_name_cstr = shared_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            shared_name_cstr.as_ptr() as *mut c_void,
            shared_name.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn random_shuffle_queue_v2<T>(
    ctx: &Context,
    component_type_s: &Vec<DataType>,
    shapes: &Vec<Vec<i64>>,
    capacity: i64,
    min_after_dequeue: i64,
    seed: i64,
    seed2: i64,
    container: &String,
    shared_name: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("RandomShuffleQueueV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("component_type_s").unwrap();
        let component_type_s: Vec<tf::TF_DataType> =
            component_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            component_type_s.as_ptr(),
            component_type_s.len() as i32,
        );

        let mut shapes_values: Vec<*const i64> = shapes.into_iter().map(|v| v.as_ptr()).collect();
        let shapes_ndims: Vec<i32> = shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            shapes_values.as_mut_ptr(),
            shapes_ndims.as_ptr(),
            shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        let attr_name = CString::new("capacity").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), capacity);

        let attr_name = CString::new("min_after_dequeue").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), min_after_dequeue);

        let attr_name = CString::new("seed").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), seed);

        let attr_name = CString::new("seed2").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), seed2);

        let attr_name = CString::new("container").unwrap();
        let container_cstr = container.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            container_cstr.as_ptr() as *mut c_void,
            container.as_bytes().len() + 1,
        );

        let attr_name = CString::new("shared_name").unwrap();
        let shared_name_cstr = shared_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            shared_name_cstr.as_ptr() as *mut c_void,
            shared_name.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn random_standard_normal<T>(
    ctx: &Context,
    shape: T,
    dtype_: DataType,
    seed: i64,
    seed2: i64,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("RandomStandardNormal").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), dtype_.to_c());

        let attr_name = CString::new("seed").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), seed);

        let attr_name = CString::new("seed2").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), seed2);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn random_uniform<T>(
    ctx: &Context,
    shape: T,
    dtype_: DataType,
    seed: i64,
    seed2: i64,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("RandomUniform").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), dtype_.to_c());

        let attr_name = CString::new("seed").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), seed);

        let attr_name = CString::new("seed2").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), seed2);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn random_uniform_int<T>(
    ctx: &Context,
    shape: T,
    minval: T,
    maxval: T,
    Tout: DataType,
    seed: i64,
    seed2: i64,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("RandomUniformInt").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, minval.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, maxval.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tout").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tout.to_c());

        let attr_name = CString::new("seed").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), seed);

        let attr_name = CString::new("seed2").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), seed2);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn range<T>(ctx: &Context, start: T, limit: T, delta: T, Tidx: DataType) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Range").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, start.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, limit.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, delta.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tidx").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tidx.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn range_dataset<T>(
    ctx: &Context,
    start: T,
    stop: T,
    step: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("RangeDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, start.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, stop.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, step.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn rank<T>(ctx: &Context, input: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Rank").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn read_file<T>(ctx: &Context, filename: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ReadFile").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, filename.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn read_variable_op<T>(ctx: &Context, resource: T, dtype_: DataType) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ReadVariableOp").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, resource.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), dtype_.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn reader_num_records_produced<T>(ctx: &Context, reader_handle: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ReaderNumRecordsProduced").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, reader_handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn reader_num_records_produced_v2<T>(ctx: &Context, reader_handle: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ReaderNumRecordsProducedV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, reader_handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn reader_num_work_units_completed<T>(ctx: &Context, reader_handle: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ReaderNumWorkUnitsCompleted").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, reader_handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn reader_num_work_units_completed_v2<T>(
    ctx: &Context,
    reader_handle: T,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ReaderNumWorkUnitsCompletedV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, reader_handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn reader_serialize_state<T>(ctx: &Context, reader_handle: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ReaderSerializeState").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, reader_handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn reader_serialize_state_v2<T>(ctx: &Context, reader_handle: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ReaderSerializeStateV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, reader_handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn real<T>(ctx: &Context, input: T, Tout: DataType) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Real").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tout").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tout.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn real_div<T>(ctx: &Context, x: T, y: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("RealDiv").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, y.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn rebatch_dataset<T>(
    ctx: &Context,
    input_dataset: T,
    num_replicas: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
    use_fallback: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("RebatchDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, num_replicas.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        let attr_name = CString::new("use_fallback").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), use_fallback as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn reciprocal<T>(ctx: &Context, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Reciprocal").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn reciprocal_grad<T>(ctx: &Context, y: T, dy: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ReciprocalGrad").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, y.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, dy.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn record_input<T>(
    ctx: &Context,
    file_pattern: &String,
    file_random_seed: i64,
    file_shuffle_shift_ratio: f32,
    file_buffer_size: i64,
    file_parallelism: i64,
    batch_size: i64,
    compression_type_: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("RecordInput").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("file_pattern").unwrap();
        let file_pattern_cstr = file_pattern.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            file_pattern_cstr.as_ptr() as *mut c_void,
            file_pattern.as_bytes().len() + 1,
        );

        let attr_name = CString::new("file_random_seed").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), file_random_seed);

        let attr_name = CString::new("file_shuffle_shift_ratio").unwrap();
        tf::TFE_OpSetAttrFloat(op, attr_name.as_ptr(), file_shuffle_shift_ratio);

        let attr_name = CString::new("file_buffer_size").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), file_buffer_size);

        let attr_name = CString::new("file_parallelism").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), file_parallelism);

        let attr_name = CString::new("batch_size").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), batch_size);

        let attr_name = CString::new("compression_type_").unwrap();
        let compression_type__cstr = compression_type_.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            compression_type__cstr.as_ptr() as *mut c_void,
            compression_type_.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn recv<T>(
    ctx: &Context,
    tensor_type_: DataType,
    tensor_name: &String,
    send_device: &String,
    send_device_incarnation: i64,
    recv_device: &String,
    client_terminated: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Recv").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("tensor_type_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), tensor_type_.to_c());

        let attr_name = CString::new("tensor_name").unwrap();
        let tensor_name_cstr = tensor_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            tensor_name_cstr.as_ptr() as *mut c_void,
            tensor_name.as_bytes().len() + 1,
        );

        let attr_name = CString::new("send_device").unwrap();
        let send_device_cstr = send_device.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            send_device_cstr.as_ptr() as *mut c_void,
            send_device.as_bytes().len() + 1,
        );

        let attr_name = CString::new("send_device_incarnation").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), send_device_incarnation);

        let attr_name = CString::new("recv_device").unwrap();
        let recv_device_cstr = recv_device.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            recv_device_cstr.as_ptr() as *mut c_void,
            recv_device.as_bytes().len() + 1,
        );

        let attr_name = CString::new("client_terminated").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), client_terminated as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn recv_t_p_u_embedding_activations<T>(
    ctx: &Context,
    num_outputs: i64,
    config: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("RecvTPUEmbeddingActivations").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("num_outputs").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), num_outputs);

        let attr_name = CString::new("config").unwrap();
        let config_cstr = config.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            config_cstr.as_ptr() as *mut c_void,
            config.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn reduce_join<T>(
    ctx: &Context,
    inputs: T,
    reduction_indices: T,
    keep_dims: bool,
    separator: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ReduceJoin").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, inputs.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, reduction_indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("keep_dims").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), keep_dims as u8);

        let attr_name = CString::new("separator").unwrap();
        let separator_cstr = separator.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            separator_cstr.as_ptr() as *mut c_void,
            separator.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn ref_enter<T>(
    ctx: &Context,
    data: T,
    frame_name: &String,
    is_constant: bool,
    parallel_iterations: i64,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("RefEnter").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, data.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("frame_name").unwrap();
        let frame_name_cstr = frame_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            frame_name_cstr.as_ptr() as *mut c_void,
            frame_name.as_bytes().len() + 1,
        );

        let attr_name = CString::new("is_constant").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), is_constant as u8);

        let attr_name = CString::new("parallel_iterations").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), parallel_iterations);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn ref_exit<T>(ctx: &Context, data: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("RefExit").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, data.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn ref_identity<T>(ctx: &Context, input: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("RefIdentity").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn ref_next_iteration<T>(ctx: &Context, data: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("RefNextIteration").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, data.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn ref_select<T>(ctx: &Context, index: T, inputs: &Vec<T>) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("RefSelect").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, index.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        let mut inputs_handles: Vec<*mut tf::TFE_TensorHandle> = inputs
            .into_iter()
            .map(|t| t.to_handle().unwrap().inner)
            .collect();
        tf::TFE_OpAddInputList(
            op,
            inputs_handles.as_mut_ptr(),
            inputs.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("N").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), inputs.len() as i64);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn regex_full_match<T>(ctx: &Context, input: T, pattern: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("RegexFullMatch").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, pattern.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn regex_replace<T>(
    ctx: &Context,
    input: T,
    pattern: T,
    rewrite: T,
    replace_global: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("RegexReplace").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, pattern.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, rewrite.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("replace_global").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), replace_global as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn register_dataset<T>(
    ctx: &Context,
    dataset: T,
    address: T,
    protocol: T,
    external_state_policy: i64,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("RegisterDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, address.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, protocol.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("external_state_policy").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), external_state_policy);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn relu<T>(ctx: &Context, features: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Relu").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, features.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn relu6<T>(ctx: &Context, features: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Relu6").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, features.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn relu6_grad<T>(ctx: &Context, gradients: T, features: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Relu6Grad").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, gradients.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, features.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn relu_grad<T>(ctx: &Context, gradients: T, features: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ReluGrad").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, gradients.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, features.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn repeat_dataset<T>(
    ctx: &Context,
    input_dataset: T,
    count: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("RepeatDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, count.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn reshape<T>(ctx: &Context, tensor: T, shape: T, Tshape: DataType) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Reshape").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, tensor.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tshape").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tshape.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn resize_area<T>(
    ctx: &Context,
    images: T,
    size: T,
    align_corners: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ResizeArea").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, images.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, size.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("align_corners").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), align_corners as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn resize_bicubic<T>(
    ctx: &Context,
    images: T,
    size: T,
    align_corners: bool,
    half_pixel_centers: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ResizeBicubic").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, images.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, size.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("align_corners").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), align_corners as u8);

        let attr_name = CString::new("half_pixel_centers").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), half_pixel_centers as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn resize_bicubic_grad<T>(
    ctx: &Context,
    grads: T,
    original_image: T,
    align_corners: bool,
    half_pixel_centers: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ResizeBicubicGrad").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, grads.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, original_image.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("align_corners").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), align_corners as u8);

        let attr_name = CString::new("half_pixel_centers").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), half_pixel_centers as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn resize_bilinear<T>(
    ctx: &Context,
    images: T,
    size: T,
    align_corners: bool,
    half_pixel_centers: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ResizeBilinear").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, images.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, size.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("align_corners").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), align_corners as u8);

        let attr_name = CString::new("half_pixel_centers").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), half_pixel_centers as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn resize_bilinear_grad<T>(
    ctx: &Context,
    grads: T,
    original_image: T,
    align_corners: bool,
    half_pixel_centers: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ResizeBilinearGrad").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, grads.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, original_image.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("align_corners").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), align_corners as u8);

        let attr_name = CString::new("half_pixel_centers").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), half_pixel_centers as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn resize_nearest_neighbor<T>(
    ctx: &Context,
    images: T,
    size: T,
    align_corners: bool,
    half_pixel_centers: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ResizeNearestNeighbor").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, images.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, size.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("align_corners").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), align_corners as u8);

        let attr_name = CString::new("half_pixel_centers").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), half_pixel_centers as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn resize_nearest_neighbor_grad<T>(
    ctx: &Context,
    grads: T,
    size: T,
    align_corners: bool,
    half_pixel_centers: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ResizeNearestNeighborGrad").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, grads.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, size.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("align_corners").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), align_corners as u8);

        let attr_name = CString::new("half_pixel_centers").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), half_pixel_centers as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn resource_accumulator_num_accumulated<T>(ctx: &Context, handle: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ResourceAccumulatorNumAccumulated").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn resource_accumulator_take_gradient<T>(
    ctx: &Context,
    handle: T,
    num_required: T,
    dtype_: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ResourceAccumulatorTakeGradient").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, num_required.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), dtype_.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn resource_conditional_accumulator<T>(
    ctx: &Context,
    dtype_: DataType,
    shape: &Vec<i64>,
    container: &String,
    shared_name: &String,
    reduction_type_: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ResourceConditionalAccumulator").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), dtype_.to_c());

        let attr_name = CString::new("shape").unwrap();
        tf::TFE_OpSetAttrShape(
            op,
            attr_name.as_ptr(),
            shape.as_ptr(),
            shape.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        let attr_name = CString::new("container").unwrap();
        let container_cstr = container.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            container_cstr.as_ptr() as *mut c_void,
            container.as_bytes().len() + 1,
        );

        let attr_name = CString::new("shared_name").unwrap();
        let shared_name_cstr = shared_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            shared_name_cstr.as_ptr() as *mut c_void,
            shared_name.as_bytes().len() + 1,
        );

        let attr_name = CString::new("reduction_type_").unwrap();
        let reduction_type__cstr = reduction_type_.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            reduction_type__cstr.as_ptr() as *mut c_void,
            reduction_type_.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn resource_count_up_to<T>(ctx: &Context, resource: T, limit: i64) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ResourceCountUpTo").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, resource.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("limit").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), limit);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn resource_gather<T>(
    ctx: &Context,
    resource: T,
    indices: T,
    dtype_: DataType,
    Tindices: DataType,
    batch_dims: i64,
    validate_indices: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ResourceGather").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, resource.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), dtype_.to_c());

        let attr_name = CString::new("Tindices").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tindices.to_c());

        let attr_name = CString::new("batch_dims").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), batch_dims);

        let attr_name = CString::new("validate_indices").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), validate_indices as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn resource_gather_nd<T>(
    ctx: &Context,
    resource: T,
    indices: T,
    dtype_: DataType,
    Tindices: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ResourceGatherNd").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, resource.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), dtype_.to_c());

        let attr_name = CString::new("Tindices").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tindices.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn restore<T>(
    ctx: &Context,
    file_pattern: T,
    tensor_name: T,
    dt: DataType,
    preferred_shard: i64,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Restore").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, file_pattern.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, tensor_name.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("dt").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), dt.to_c());

        let attr_name = CString::new("preferred_shard").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), preferred_shard);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn restore_slice<T>(
    ctx: &Context,
    file_pattern: T,
    tensor_name: T,
    shape_and_slice: T,
    dt: DataType,
    preferred_shard: i64,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("RestoreSlice").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, file_pattern.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, tensor_name.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, shape_and_slice.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("dt").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), dt.to_c());

        let attr_name = CString::new("preferred_shard").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), preferred_shard);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn restore_v2<T>(
    ctx: &Context,
    pref_ix: T,
    tensor_names: T,
    shape_and_slices: T,
    dtype_s: &Vec<DataType>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("RestoreV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, pref_ix.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, tensor_names.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, shape_and_slices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("dtype_s").unwrap();
        let dtype_s: Vec<tf::TF_DataType> = dtype_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            dtype_s.as_ptr(),
            dtype_s.len() as i32,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn retrieve_t_p_u_embedding_stochastic_gradient_descent_parameters<T>(
    ctx: &Context,
    num_shards: i64,
    shard_id: i64,
    table_id: i64,
    table_name: &String,
    config: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name =
            CString::new("RetrieveTPUEmbeddingStochasticGradientDescentParameters").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("num_shards").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), num_shards);

        let attr_name = CString::new("shard_id").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), shard_id);

        let attr_name = CString::new("table_id").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), table_id);

        let attr_name = CString::new("table_name").unwrap();
        let table_name_cstr = table_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            table_name_cstr.as_ptr() as *mut c_void,
            table_name.as_bytes().len() + 1,
        );

        let attr_name = CString::new("config").unwrap();
        let config_cstr = config.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            config_cstr.as_ptr() as *mut c_void,
            config.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn reverse<T>(ctx: &Context, tensor: T, dims: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Reverse").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, tensor.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, dims.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn reverse_sequence<T>(
    ctx: &Context,
    input: T,
    seq_lengths: T,
    seq_dim: i64,
    batch_dim: i64,
    Tlen: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ReverseSequence").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, seq_lengths.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("seq_dim").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), seq_dim);

        let attr_name = CString::new("batch_dim").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), batch_dim);

        let attr_name = CString::new("Tlen").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tlen.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn reverse_v2<T>(ctx: &Context, tensor: T, axis: T, Tidx: DataType) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ReverseV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, tensor.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, axis.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tidx").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tidx.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn right_shift<T>(ctx: &Context, x: T, y: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("RightShift").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, y.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn rint<T>(ctx: &Context, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Rint").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn roll<T>(
    ctx: &Context,
    input: T,
    shift: T,
    axis: T,
    Tshift: DataType,
    Taxis: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Roll").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, shift.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, axis.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tshift").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tshift.to_c());

        let attr_name = CString::new("Taxis").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Taxis.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn round<T>(ctx: &Context, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Round").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn rsqrt<T>(ctx: &Context, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Rsqrt").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn rsqrt_grad<T>(ctx: &Context, y: T, dy: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("RsqrtGrad").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, y.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, dy.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn sampling_dataset<T>(
    ctx: &Context,
    input_dataset: T,
    rate: T,
    seed: T,
    seed2: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SamplingDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, rate.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, seed.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, seed2.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn scalar_summary<T>(ctx: &Context, tags: T, values: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ScalarSummary").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, tags.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, values.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn scale_and_translate<T>(
    ctx: &Context,
    images: T,
    size: T,
    scale: T,
    translation: T,
    kernel_type_: &String,
    antialias: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ScaleAndTranslate").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, images.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, size.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, scale.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, translation.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("kernel_type_").unwrap();
        let kernel_type__cstr = kernel_type_.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            kernel_type__cstr.as_ptr() as *mut c_void,
            kernel_type_.as_bytes().len() + 1,
        );

        let attr_name = CString::new("antialias").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), antialias as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn scale_and_translate_grad<T>(
    ctx: &Context,
    grads: T,
    original_image: T,
    scale: T,
    translation: T,
    kernel_type_: &String,
    antialias: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ScaleAndTranslateGrad").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, grads.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, original_image.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, scale.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, translation.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("kernel_type_").unwrap();
        let kernel_type__cstr = kernel_type_.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            kernel_type__cstr.as_ptr() as *mut c_void,
            kernel_type_.as_bytes().len() + 1,
        );

        let attr_name = CString::new("antialias").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), antialias as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn scatter_add<T>(
    ctx: &Context,
    ref_: T,
    indices: T,
    updates: T,
    Tindices: DataType,
    use_locking: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ScatterAdd").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, ref_.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, updates.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tindices").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tindices.to_c());

        let attr_name = CString::new("use_locking").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), use_locking as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn scatter_div<T>(
    ctx: &Context,
    ref_: T,
    indices: T,
    updates: T,
    Tindices: DataType,
    use_locking: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ScatterDiv").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, ref_.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, updates.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tindices").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tindices.to_c());

        let attr_name = CString::new("use_locking").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), use_locking as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn scatter_max<T>(
    ctx: &Context,
    ref_: T,
    indices: T,
    updates: T,
    Tindices: DataType,
    use_locking: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ScatterMax").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, ref_.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, updates.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tindices").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tindices.to_c());

        let attr_name = CString::new("use_locking").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), use_locking as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn scatter_min<T>(
    ctx: &Context,
    ref_: T,
    indices: T,
    updates: T,
    Tindices: DataType,
    use_locking: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ScatterMin").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, ref_.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, updates.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tindices").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tindices.to_c());

        let attr_name = CString::new("use_locking").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), use_locking as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn scatter_mul<T>(
    ctx: &Context,
    ref_: T,
    indices: T,
    updates: T,
    Tindices: DataType,
    use_locking: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ScatterMul").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, ref_.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, updates.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tindices").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tindices.to_c());

        let attr_name = CString::new("use_locking").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), use_locking as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn scatter_nd<T>(
    ctx: &Context,
    indices: T,
    updates: T,
    shape: T,
    Tindices: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ScatterNd").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, updates.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tindices").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tindices.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn scatter_nd_add<T>(
    ctx: &Context,
    ref_: T,
    indices: T,
    updates: T,
    Tindices: DataType,
    use_locking: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ScatterNdAdd").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, ref_.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, updates.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tindices").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tindices.to_c());

        let attr_name = CString::new("use_locking").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), use_locking as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn scatter_nd_max<T>(
    ctx: &Context,
    ref_: T,
    indices: T,
    updates: T,
    Tindices: DataType,
    use_locking: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ScatterNdMax").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, ref_.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, updates.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tindices").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tindices.to_c());

        let attr_name = CString::new("use_locking").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), use_locking as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn scatter_nd_min<T>(
    ctx: &Context,
    ref_: T,
    indices: T,
    updates: T,
    Tindices: DataType,
    use_locking: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ScatterNdMin").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, ref_.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, updates.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tindices").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tindices.to_c());

        let attr_name = CString::new("use_locking").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), use_locking as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn scatter_nd_non_aliasing_add<T>(
    ctx: &Context,
    input: T,
    indices: T,
    updates: T,
    Tindices: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ScatterNdNonAliasingAdd").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, updates.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tindices").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tindices.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn scatter_nd_sub<T>(
    ctx: &Context,
    ref_: T,
    indices: T,
    updates: T,
    Tindices: DataType,
    use_locking: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ScatterNdSub").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, ref_.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, updates.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tindices").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tindices.to_c());

        let attr_name = CString::new("use_locking").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), use_locking as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn scatter_nd_update<T>(
    ctx: &Context,
    ref_: T,
    indices: T,
    updates: T,
    Tindices: DataType,
    use_locking: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ScatterNdUpdate").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, ref_.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, updates.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tindices").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tindices.to_c());

        let attr_name = CString::new("use_locking").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), use_locking as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn scatter_sub<T>(
    ctx: &Context,
    ref_: T,
    indices: T,
    updates: T,
    Tindices: DataType,
    use_locking: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ScatterSub").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, ref_.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, updates.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tindices").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tindices.to_c());

        let attr_name = CString::new("use_locking").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), use_locking as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn scatter_update<T>(
    ctx: &Context,
    ref_: T,
    indices: T,
    updates: T,
    Tindices: DataType,
    use_locking: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ScatterUpdate").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, ref_.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, updates.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tindices").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tindices.to_c());

        let attr_name = CString::new("use_locking").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), use_locking as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn sdca_fprint<T>(ctx: &Context, input: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SdcaFprint").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn segment_max<T>(
    ctx: &Context,
    data: T,
    segment_ids: T,
    Tindices: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SegmentMax").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, data.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, segment_ids.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tindices").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tindices.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn segment_mean<T>(
    ctx: &Context,
    data: T,
    segment_ids: T,
    Tindices: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SegmentMean").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, data.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, segment_ids.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tindices").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tindices.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn segment_min<T>(
    ctx: &Context,
    data: T,
    segment_ids: T,
    Tindices: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SegmentMin").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, data.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, segment_ids.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tindices").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tindices.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn segment_prod<T>(
    ctx: &Context,
    data: T,
    segment_ids: T,
    Tindices: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SegmentProd").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, data.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, segment_ids.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tindices").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tindices.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn segment_sum<T>(
    ctx: &Context,
    data: T,
    segment_ids: T,
    Tindices: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SegmentSum").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, data.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, segment_ids.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tindices").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tindices.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn select<T>(ctx: &Context, condition: T, t: T, e: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Select").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, condition.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, t.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, e.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn select_v2<T>(ctx: &Context, condition: T, t: T, e: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SelectV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, condition.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, t.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, e.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn self_adjoint_eig<T>(ctx: &Context, input: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SelfAdjointEig").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn selu<T>(ctx: &Context, features: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Selu").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, features.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn selu_grad<T>(ctx: &Context, gradients: T, outputs: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SeluGrad").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, gradients.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, outputs.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn serialize_iterator<T>(
    ctx: &Context,
    resource_handle: T,
    external_state_policy: i64,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SerializeIterator").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, resource_handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("external_state_policy").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), external_state_policy);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn serialize_many_sparse<T>(
    ctx: &Context,
    sparse_indices: T,
    sparse_values: T,
    sparse_shape: T,
    out_type_: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SerializeManySparse").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, sparse_indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, sparse_values.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, sparse_shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("out_type_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), out_type_.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn serialize_sparse<T>(
    ctx: &Context,
    sparse_indices: T,
    sparse_values: T,
    sparse_shape: T,
    out_type_: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SerializeSparse").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, sparse_indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, sparse_values.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, sparse_shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("out_type_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), out_type_.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn serialize_tensor<T>(ctx: &Context, tensor: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SerializeTensor").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, tensor.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn set_size<T>(
    ctx: &Context,
    set_indices: T,
    set_values: T,
    set_shape: T,
    validate_indices: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SetSize").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, set_indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, set_values.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, set_shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("validate_indices").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), validate_indices as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn set_stats_aggregator_dataset<T>(
    ctx: &Context,
    input_dataset: T,
    stats_aggregator: T,
    tag: T,
    counter_pref_ix: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SetStatsAggregatorDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, stats_aggregator.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, tag.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, counter_pref_ix.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn shape<T>(ctx: &Context, input: T, out_type_: DataType) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Shape").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("out_type_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), out_type_.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn shape_n<T>(ctx: &Context, input: &Vec<T>, out_type_: DataType) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ShapeN").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        let mut input_handles: Vec<*mut tf::TFE_TensorHandle> = input
            .into_iter()
            .map(|t| t.to_handle().unwrap().inner)
            .collect();
        tf::TFE_OpAddInputList(
            op,
            input_handles.as_mut_ptr(),
            input.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("N").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), input.len() as i64);

        let attr_name = CString::new("out_type_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), out_type_.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn shard_dataset<T>(
    ctx: &Context,
    input_dataset: T,
    num_shards: T,
    index: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
    require_non_empty: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ShardDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, num_shards.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, index.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        let attr_name = CString::new("require_non_empty").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), require_non_empty as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn sharded_filename<T>(
    ctx: &Context,
    basename: T,
    shard: T,
    num_shards: T,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ShardedFilename").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, basename.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, shard.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, num_shards.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn sharded_filespec<T>(ctx: &Context, basename: T, num_shards: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ShardedFilespec").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, basename.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, num_shards.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn shuffle_and_repeat_dataset<T>(
    ctx: &Context,
    input_dataset: T,
    buffer_size: T,
    seed: T,
    seed2: T,
    count: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
    reshuffle_each_iteration: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ShuffleAndRepeatDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, buffer_size.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, seed.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, seed2.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, count.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        let attr_name = CString::new("reshuffle_each_iteration").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), reshuffle_each_iteration as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn shuffle_and_repeat_dataset_v2<T>(
    ctx: &Context,
    input_dataset: T,
    buffer_size: T,
    seed: T,
    seed2: T,
    count: T,
    seed_generator: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
    reshuffle_each_iteration: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ShuffleAndRepeatDatasetV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, buffer_size.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, seed.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, seed2.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, count.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, seed_generator.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        let attr_name = CString::new("reshuffle_each_iteration").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), reshuffle_each_iteration as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn shuffle_dataset<T>(
    ctx: &Context,
    input_dataset: T,
    buffer_size: T,
    seed: T,
    seed2: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
    reshuffle_each_iteration: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ShuffleDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, buffer_size.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, seed.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, seed2.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        let attr_name = CString::new("reshuffle_each_iteration").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), reshuffle_each_iteration as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn shuffle_dataset_v2<T>(
    ctx: &Context,
    input_dataset: T,
    buffer_size: T,
    seed_generator: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ShuffleDatasetV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, buffer_size.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, seed_generator.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn shuffle_dataset_v3<T>(
    ctx: &Context,
    input_dataset: T,
    buffer_size: T,
    seed: T,
    seed2: T,
    seed_generator: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
    reshuffle_each_iteration: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ShuffleDatasetV3").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, buffer_size.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, seed.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, seed2.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, seed_generator.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        let attr_name = CString::new("reshuffle_each_iteration").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), reshuffle_each_iteration as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn sigmoid<T>(ctx: &Context, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Sigmoid").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn sigmoid_grad<T>(ctx: &Context, y: T, dy: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SigmoidGrad").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, y.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, dy.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn sign<T>(ctx: &Context, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Sign").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn sin<T>(ctx: &Context, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Sin").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn sinh<T>(ctx: &Context, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Sinh").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn size<T>(ctx: &Context, input: T, out_type_: DataType) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Size").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("out_type_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), out_type_.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn skip_dataset<T>(
    ctx: &Context,
    input_dataset: T,
    count: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SkipDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, count.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn sleep_dataset<T>(
    ctx: &Context,
    input_dataset: T,
    sleep_microseconds: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SleepDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, sleep_microseconds.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn slice<T>(ctx: &Context, input: T, begin: T, size: T, Index: DataType) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Slice").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, begin.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, size.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Index").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Index.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn sliding_window_dataset<T>(
    ctx: &Context,
    input_dataset: T,
    window_size: T,
    window_shift: T,
    window_stride: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SlidingWindowDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, window_size.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, window_shift.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, window_stride.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn snapshot<T>(ctx: &Context, input: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Snapshot").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn snapshot_dataset<T>(
    ctx: &Context,
    input_dataset: T,
    path: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
    compression: &String,
    reader_path_prefix: &String,
    writer_path_prefix: &String,
    shard_size_bytes: i64,
    pending_snapshot_expiry_seconds: i64,
    num_reader_threads: i64,
    reader_buffer_size: i64,
    num_writer_threads: i64,
    writer_buffer_size: i64,
    shuffle_on_read: bool,
    seed: i64,
    seed2: i64,
    mode: &String,
    snapshot_name: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SnapshotDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, path.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        let attr_name = CString::new("compression").unwrap();
        let compression_cstr = compression.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            compression_cstr.as_ptr() as *mut c_void,
            compression.as_bytes().len() + 1,
        );

        let attr_name = CString::new("reader_path_prefix").unwrap();
        let reader_path_prefix_cstr = reader_path_prefix.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            reader_path_prefix_cstr.as_ptr() as *mut c_void,
            reader_path_prefix.as_bytes().len() + 1,
        );

        let attr_name = CString::new("writer_path_prefix").unwrap();
        let writer_path_prefix_cstr = writer_path_prefix.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            writer_path_prefix_cstr.as_ptr() as *mut c_void,
            writer_path_prefix.as_bytes().len() + 1,
        );

        let attr_name = CString::new("shard_size_bytes").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), shard_size_bytes);

        let attr_name = CString::new("pending_snapshot_expiry_seconds").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), pending_snapshot_expiry_seconds);

        let attr_name = CString::new("num_reader_threads").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), num_reader_threads);

        let attr_name = CString::new("reader_buffer_size").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), reader_buffer_size);

        let attr_name = CString::new("num_writer_threads").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), num_writer_threads);

        let attr_name = CString::new("writer_buffer_size").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), writer_buffer_size);

        let attr_name = CString::new("shuffle_on_read").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), shuffle_on_read as u8);

        let attr_name = CString::new("seed").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), seed);

        let attr_name = CString::new("seed2").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), seed2);

        let attr_name = CString::new("mode").unwrap();
        let mode_cstr = mode.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            mode_cstr.as_ptr() as *mut c_void,
            mode.as_bytes().len() + 1,
        );

        let attr_name = CString::new("snapshot_name").unwrap();
        let snapshot_name_cstr = snapshot_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            snapshot_name_cstr.as_ptr() as *mut c_void,
            snapshot_name.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn sobol_sample<T>(
    ctx: &Context,
    dim: T,
    num_results: T,
    skip: T,
    dtype_: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SobolSample").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, dim.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, num_results.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, skip.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), dtype_.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn softmax<T>(ctx: &Context, logits: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Softmax").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, logits.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn softplus<T>(ctx: &Context, features: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Softplus").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, features.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn softplus_grad<T>(ctx: &Context, gradients: T, features: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SoftplusGrad").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, gradients.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, features.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn softsign<T>(ctx: &Context, features: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Softsign").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, features.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn softsign_grad<T>(ctx: &Context, gradients: T, features: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SoftsignGrad").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, gradients.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, features.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn space_to_batch<T>(
    ctx: &Context,
    input: T,
    paddings: T,
    block_size: i64,
    Tpaddings: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SpaceToBatch").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, paddings.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("block_size").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), block_size);

        let attr_name = CString::new("Tpaddings").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tpaddings.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn space_to_batch_n_d<T>(
    ctx: &Context,
    input: T,
    block_shape: T,
    paddings: T,
    Tblock_shape: DataType,
    Tpaddings: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SpaceToBatchND").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, block_shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, paddings.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tblock_shape").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tblock_shape.to_c());

        let attr_name = CString::new("Tpaddings").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tpaddings.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn space_to_depth<T>(
    ctx: &Context,
    input: T,
    block_size: i64,
    data_format: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SpaceToDepth").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("block_size").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), block_size);

        let attr_name = CString::new("data_format").unwrap();
        let data_format_cstr = data_format.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            data_format_cstr.as_ptr() as *mut c_void,
            data_format.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn sparse_apply_adadelta<T>(
    ctx: &Context,
    var: T,
    accum: T,
    accum_update: T,
    lr: T,
    rho: T,
    epsilon: T,
    grad: T,
    indices: T,
    Tindices: DataType,
    use_locking: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SparseApplyAdadelta").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, var.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, accum.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, accum_update.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, lr.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, rho.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, epsilon.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, grad.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tindices").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tindices.to_c());

        let attr_name = CString::new("use_locking").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), use_locking as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn sparse_apply_adagrad<T>(
    ctx: &Context,
    var: T,
    accum: T,
    lr: T,
    grad: T,
    indices: T,
    Tindices: DataType,
    use_locking: bool,
    update_slots: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SparseApplyAdagrad").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, var.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, accum.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, lr.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, grad.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tindices").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tindices.to_c());

        let attr_name = CString::new("use_locking").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), use_locking as u8);

        let attr_name = CString::new("update_slots").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), update_slots as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn sparse_apply_adagrad_d_a<T>(
    ctx: &Context,
    var: T,
    gradient_accumulator: T,
    gradient_squared_accumulator: T,
    grad: T,
    indices: T,
    lr: T,
    l1: T,
    l2: T,
    global_step: T,
    Tindices: DataType,
    use_locking: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SparseApplyAdagradDA").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, var.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, gradient_accumulator.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(
            op,
            gradient_squared_accumulator.to_handle()?.inner,
            status.inner,
        );
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, grad.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, lr.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, l1.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, l2.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, global_step.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tindices").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tindices.to_c());

        let attr_name = CString::new("use_locking").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), use_locking as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn sparse_apply_adagrad_v2<T>(
    ctx: &Context,
    var: T,
    accum: T,
    lr: T,
    epsilon: T,
    grad: T,
    indices: T,
    Tindices: DataType,
    use_locking: bool,
    update_slots: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SparseApplyAdagradV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, var.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, accum.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, lr.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, epsilon.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, grad.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tindices").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tindices.to_c());

        let attr_name = CString::new("use_locking").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), use_locking as u8);

        let attr_name = CString::new("update_slots").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), update_slots as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn sparse_apply_centered_r_m_s_prop<T>(
    ctx: &Context,
    var: T,
    mg: T,
    ms: T,
    mom: T,
    lr: T,
    rho: T,
    momentum: T,
    epsilon: T,
    grad: T,
    indices: T,
    Tindices: DataType,
    use_locking: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SparseApplyCenteredRMSProp").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, var.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, mg.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, ms.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, mom.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, lr.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, rho.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, momentum.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, epsilon.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, grad.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tindices").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tindices.to_c());

        let attr_name = CString::new("use_locking").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), use_locking as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn sparse_apply_ftrl<T>(
    ctx: &Context,
    var: T,
    accum: T,
    linear: T,
    grad: T,
    indices: T,
    lr: T,
    l1: T,
    l2: T,
    lr_power: T,
    Tindices: DataType,
    use_locking: bool,
    multiply_linear_by_lr: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SparseApplyFtrl").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, var.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, accum.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, linear.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, grad.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, lr.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, l1.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, l2.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, lr_power.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tindices").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tindices.to_c());

        let attr_name = CString::new("use_locking").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), use_locking as u8);

        let attr_name = CString::new("multiply_linear_by_lr").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), multiply_linear_by_lr as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn sparse_apply_ftrl_v2<T>(
    ctx: &Context,
    var: T,
    accum: T,
    linear: T,
    grad: T,
    indices: T,
    lr: T,
    l1: T,
    l2: T,
    l2_shrinkage: T,
    lr_power: T,
    Tindices: DataType,
    use_locking: bool,
    multiply_linear_by_lr: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SparseApplyFtrlV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, var.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, accum.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, linear.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, grad.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, lr.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, l1.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, l2.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, l2_shrinkage.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, lr_power.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tindices").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tindices.to_c());

        let attr_name = CString::new("use_locking").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), use_locking as u8);

        let attr_name = CString::new("multiply_linear_by_lr").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), multiply_linear_by_lr as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn sparse_apply_momentum<T>(
    ctx: &Context,
    var: T,
    accum: T,
    lr: T,
    grad: T,
    indices: T,
    momentum: T,
    Tindices: DataType,
    use_locking: bool,
    use_nesterov: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SparseApplyMomentum").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, var.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, accum.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, lr.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, grad.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, momentum.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tindices").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tindices.to_c());

        let attr_name = CString::new("use_locking").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), use_locking as u8);

        let attr_name = CString::new("use_nesterov").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), use_nesterov as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn sparse_apply_proximal_adagrad<T>(
    ctx: &Context,
    var: T,
    accum: T,
    lr: T,
    l1: T,
    l2: T,
    grad: T,
    indices: T,
    Tindices: DataType,
    use_locking: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SparseApplyProximalAdagrad").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, var.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, accum.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, lr.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, l1.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, l2.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, grad.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tindices").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tindices.to_c());

        let attr_name = CString::new("use_locking").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), use_locking as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn sparse_apply_proximal_gradient_descent<T>(
    ctx: &Context,
    var: T,
    alpha: T,
    l1: T,
    l2: T,
    grad: T,
    indices: T,
    Tindices: DataType,
    use_locking: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SparseApplyProximalGradientDescent").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, var.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, alpha.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, l1.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, l2.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, grad.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tindices").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tindices.to_c());

        let attr_name = CString::new("use_locking").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), use_locking as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn sparse_apply_r_m_s_prop<T>(
    ctx: &Context,
    var: T,
    ms: T,
    mom: T,
    lr: T,
    rho: T,
    momentum: T,
    epsilon: T,
    grad: T,
    indices: T,
    Tindices: DataType,
    use_locking: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SparseApplyRMSProp").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, var.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, ms.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, mom.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, lr.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, rho.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, momentum.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, epsilon.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, grad.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tindices").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tindices.to_c());

        let attr_name = CString::new("use_locking").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), use_locking as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn sparse_bincount<T>(
    ctx: &Context,
    indices: T,
    values: T,
    dense_shape: T,
    size: T,
    weights: T,
    Tidx: DataType,
    binary_output: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SparseBincount").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, values.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, dense_shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, size.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, weights.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tidx").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tidx.to_c());

        let attr_name = CString::new("binary_output").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), binary_output as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn sparse_conditional_accumulator<T>(
    ctx: &Context,
    dtype_: DataType,
    shape: &Vec<i64>,
    container: &String,
    shared_name: &String,
    reduction_type_: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SparseConditionalAccumulator").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), dtype_.to_c());

        let attr_name = CString::new("shape").unwrap();
        tf::TFE_OpSetAttrShape(
            op,
            attr_name.as_ptr(),
            shape.as_ptr(),
            shape.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        let attr_name = CString::new("container").unwrap();
        let container_cstr = container.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            container_cstr.as_ptr() as *mut c_void,
            container.as_bytes().len() + 1,
        );

        let attr_name = CString::new("shared_name").unwrap();
        let shared_name_cstr = shared_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            shared_name_cstr.as_ptr() as *mut c_void,
            shared_name.as_bytes().len() + 1,
        );

        let attr_name = CString::new("reduction_type_").unwrap();
        let reduction_type__cstr = reduction_type_.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            reduction_type__cstr.as_ptr() as *mut c_void,
            reduction_type_.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn sparse_dense_cwise_add<T>(
    ctx: &Context,
    sp_indices: T,
    sp_values: T,
    sp_shape: T,
    dense: T,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SparseDenseCwiseAdd").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, sp_indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, sp_values.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, sp_shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, dense.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn sparse_dense_cwise_div<T>(
    ctx: &Context,
    sp_indices: T,
    sp_values: T,
    sp_shape: T,
    dense: T,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SparseDenseCwiseDiv").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, sp_indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, sp_values.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, sp_shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, dense.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn sparse_dense_cwise_mul<T>(
    ctx: &Context,
    sp_indices: T,
    sp_values: T,
    sp_shape: T,
    dense: T,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SparseDenseCwiseMul").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, sp_indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, sp_values.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, sp_shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, dense.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn sparse_mat_mul<T>(
    ctx: &Context,
    a: T,
    b: T,
    transpose_a: bool,
    transpose_b: bool,
    a_is_sparse: bool,
    b_is_sparse: bool,
    Ta: DataType,
    Tb: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SparseMatMul").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, a.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, b.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("transpose_a").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), transpose_a as u8);

        let attr_name = CString::new("transpose_b").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), transpose_b as u8);

        let attr_name = CString::new("a_is_sparse").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), a_is_sparse as u8);

        let attr_name = CString::new("b_is_sparse").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), b_is_sparse as u8);

        let attr_name = CString::new("Ta").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Ta.to_c());

        let attr_name = CString::new("Tb").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tb.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn sparse_matrix_add<T>(ctx: &Context, a: T, b: T, alpha: T, beta: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SparseMatrixAdd").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, a.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, b.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, alpha.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, beta.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn sparse_matrix_mat_mul<T>(
    ctx: &Context,
    a: T,
    b: T,
    transpose_a: bool,
    transpose_b: bool,
    adjoint_a: bool,
    adjoint_b: bool,
    transpose_output: bool,
    conjugate_output: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SparseMatrixMatMul").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, a.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, b.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("transpose_a").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), transpose_a as u8);

        let attr_name = CString::new("transpose_b").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), transpose_b as u8);

        let attr_name = CString::new("adjoint_a").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), adjoint_a as u8);

        let attr_name = CString::new("adjoint_b").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), adjoint_b as u8);

        let attr_name = CString::new("transpose_output").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), transpose_output as u8);

        let attr_name = CString::new("conjugate_output").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), conjugate_output as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn sparse_matrix_mul<T>(ctx: &Context, a: T, b: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SparseMatrixMul").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, a.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, b.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn sparse_matrix_n_n_z<T>(ctx: &Context, sparse_matrix: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SparseMatrixNNZ").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, sparse_matrix.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn sparse_matrix_ordering_a_m_d<T>(ctx: &Context, input: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SparseMatrixOrderingAMD").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn sparse_matrix_softmax<T>(ctx: &Context, logits: T, type_: DataType) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SparseMatrixSoftmax").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, logits.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("type_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), type_.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn sparse_matrix_softmax_grad<T>(
    ctx: &Context,
    softmax: T,
    grad_softmax: T,
    type_: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SparseMatrixSoftmaxGrad").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, softmax.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, grad_softmax.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("type_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), type_.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn sparse_matrix_sparse_cholesky<T>(
    ctx: &Context,
    input: T,
    permutation: T,
    type_: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SparseMatrixSparseCholesky").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, permutation.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("type_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), type_.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn sparse_matrix_sparse_mat_mul<T>(
    ctx: &Context,
    a: T,
    b: T,
    type_: DataType,
    transpose_a: bool,
    transpose_b: bool,
    adjoint_a: bool,
    adjoint_b: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SparseMatrixSparseMatMul").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, a.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, b.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("type_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), type_.to_c());

        let attr_name = CString::new("transpose_a").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), transpose_a as u8);

        let attr_name = CString::new("transpose_b").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), transpose_b as u8);

        let attr_name = CString::new("adjoint_a").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), adjoint_a as u8);

        let attr_name = CString::new("adjoint_b").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), adjoint_b as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn sparse_matrix_transpose<T>(
    ctx: &Context,
    input: T,
    type_: DataType,
    conjugate: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SparseMatrixTranspose").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("type_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), type_.to_c());

        let attr_name = CString::new("conjugate").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), conjugate as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn sparse_matrix_zeros<T>(
    ctx: &Context,
    dense_shape: T,
    type_: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SparseMatrixZeros").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, dense_shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("type_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), type_.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn sparse_reduce_max<T>(
    ctx: &Context,
    input_indices: T,
    input_values: T,
    input_shape: T,
    reduction_axes: T,
    keep_dims: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SparseReduceMax").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, input_values.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, input_shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, reduction_axes.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("keep_dims").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), keep_dims as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn sparse_reduce_sum<T>(
    ctx: &Context,
    input_indices: T,
    input_values: T,
    input_shape: T,
    reduction_axes: T,
    keep_dims: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SparseReduceSum").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, input_values.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, input_shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, reduction_axes.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("keep_dims").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), keep_dims as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn sparse_segment_mean<T>(
    ctx: &Context,
    data: T,
    indices: T,
    segment_ids: T,
    Tidx: DataType,
    Tsegmentids: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SparseSegmentMean").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, data.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, segment_ids.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tidx").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tidx.to_c());

        let attr_name = CString::new("Tsegmentids").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tsegmentids.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn sparse_segment_mean_grad<T>(
    ctx: &Context,
    grad: T,
    indices: T,
    segment_ids: T,
    output_dim0: T,
    Tidx: DataType,
    Tsegmentids: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SparseSegmentMeanGrad").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, grad.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, segment_ids.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, output_dim0.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tidx").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tidx.to_c());

        let attr_name = CString::new("Tsegmentids").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tsegmentids.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn sparse_segment_mean_with_num_segments<T>(
    ctx: &Context,
    data: T,
    indices: T,
    segment_ids: T,
    num_segments: T,
    Tidx: DataType,
    Tnumsegments: DataType,
    Tsegmentids: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SparseSegmentMeanWithNumSegments").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, data.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, segment_ids.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, num_segments.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tidx").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tidx.to_c());

        let attr_name = CString::new("Tnumsegments").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tnumsegments.to_c());

        let attr_name = CString::new("Tsegmentids").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tsegmentids.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn sparse_segment_sqrt_n<T>(
    ctx: &Context,
    data: T,
    indices: T,
    segment_ids: T,
    Tidx: DataType,
    Tsegmentids: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SparseSegmentSqrtN").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, data.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, segment_ids.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tidx").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tidx.to_c());

        let attr_name = CString::new("Tsegmentids").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tsegmentids.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn sparse_segment_sqrt_n_grad<T>(
    ctx: &Context,
    grad: T,
    indices: T,
    segment_ids: T,
    output_dim0: T,
    Tidx: DataType,
    Tsegmentids: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SparseSegmentSqrtNGrad").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, grad.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, segment_ids.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, output_dim0.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tidx").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tidx.to_c());

        let attr_name = CString::new("Tsegmentids").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tsegmentids.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn sparse_segment_sqrt_n_with_num_segments<T>(
    ctx: &Context,
    data: T,
    indices: T,
    segment_ids: T,
    num_segments: T,
    Tidx: DataType,
    Tnumsegments: DataType,
    Tsegmentids: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SparseSegmentSqrtNWithNumSegments").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, data.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, segment_ids.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, num_segments.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tidx").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tidx.to_c());

        let attr_name = CString::new("Tnumsegments").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tnumsegments.to_c());

        let attr_name = CString::new("Tsegmentids").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tsegmentids.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn sparse_segment_sum<T>(
    ctx: &Context,
    data: T,
    indices: T,
    segment_ids: T,
    Tidx: DataType,
    Tsegmentids: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SparseSegmentSum").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, data.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, segment_ids.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tidx").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tidx.to_c());

        let attr_name = CString::new("Tsegmentids").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tsegmentids.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn sparse_segment_sum_with_num_segments<T>(
    ctx: &Context,
    data: T,
    indices: T,
    segment_ids: T,
    num_segments: T,
    Tidx: DataType,
    Tnumsegments: DataType,
    Tsegmentids: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SparseSegmentSumWithNumSegments").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, data.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, segment_ids.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, num_segments.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tidx").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tidx.to_c());

        let attr_name = CString::new("Tnumsegments").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tnumsegments.to_c());

        let attr_name = CString::new("Tsegmentids").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tsegmentids.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn sparse_slice_grad<T>(
    ctx: &Context,
    backprop_val_grad: T,
    input_indices: T,
    input_start: T,
    output_indices: T,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SparseSliceGrad").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, backprop_val_grad.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, input_indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, input_start.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, output_indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn sparse_softmax<T>(
    ctx: &Context,
    sp_indices: T,
    sp_values: T,
    sp_shape: T,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SparseSoftmax").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, sp_indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, sp_values.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, sp_shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn sparse_tensor_dense_add<T>(
    ctx: &Context,
    a_indices: T,
    a_values: T,
    a_shape: T,
    b: T,
    Tindices: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SparseTensorDenseAdd").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, a_indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, a_values.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, a_shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, b.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tindices").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tindices.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn sparse_tensor_dense_mat_mul<T>(
    ctx: &Context,
    a_indices: T,
    a_values: T,
    a_shape: T,
    b: T,
    Tindices: DataType,
    adjoint_a: bool,
    adjoint_b: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SparseTensorDenseMatMul").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, a_indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, a_values.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, a_shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, b.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tindices").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tindices.to_c());

        let attr_name = CString::new("adjoint_a").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), adjoint_a as u8);

        let attr_name = CString::new("adjoint_b").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), adjoint_b as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn sparse_tensor_slice_dataset<T>(
    ctx: &Context,
    indices: T,
    values: T,
    dense_shape: T,
    Tvalues: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SparseTensorSliceDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, values.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, dense_shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tvalues").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tvalues.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn sparse_tensor_to_c_s_r_sparse_matrix<T>(
    ctx: &Context,
    indices: T,
    values: T,
    dense_shape: T,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SparseTensorToCSRSparseMatrix").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, values.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, dense_shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn sparse_to_dense<T>(
    ctx: &Context,
    sparse_indices: T,
    output_shape: T,
    sparse_values: T,
    default_value: T,
    Tindices: DataType,
    validate_indices: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SparseToDense").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, sparse_indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, output_shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, sparse_values.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, default_value.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tindices").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tindices.to_c());

        let attr_name = CString::new("validate_indices").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), validate_indices as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn spence<T>(ctx: &Context, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Spence").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn split<T>(ctx: &Context, split_dim: T, value: T, num_split: i64) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Split").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, split_dim.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, value.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("num_split").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), num_split);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn split_v<T>(
    ctx: &Context,
    value: T,
    size_splits: T,
    split_dim: T,
    num_split: i64,
    Tlen: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SplitV").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, value.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, size_splits.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, split_dim.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("num_split").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), num_split);

        let attr_name = CString::new("Tlen").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tlen.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn sql_dataset<T>(
    ctx: &Context,
    driver_name: T,
    data_source_name: T,
    query: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SqlDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, driver_name.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, data_source_name.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, query.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn sqrt<T>(ctx: &Context, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Sqrt").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn sqrt_grad<T>(ctx: &Context, y: T, dy: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SqrtGrad").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, y.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, dy.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn square<T>(ctx: &Context, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Square").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn squared_difference<T>(ctx: &Context, x: T, y: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SquaredDifference").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, y.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn squeeze<T>(ctx: &Context, input: T, squeeze_dims: &Vec<i64>) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Squeeze").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("squeeze_dims").unwrap();
        tf::TFE_OpSetAttrIntList(
            op,
            attr_name.as_ptr(),
            squeeze_dims.as_ptr(),
            squeeze_dims.len() as i32,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn stack<T>(ctx: &Context, elem_type_: DataType, stack_name: &String) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Stack").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("elem_type_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), elem_type_.to_c());

        let attr_name = CString::new("stack_name").unwrap();
        let stack_name_cstr = stack_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            stack_name_cstr.as_ptr() as *mut c_void,
            stack_name.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn stack_pop<T>(ctx: &Context, handle: T, elem_type_: DataType) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("StackPop").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("elem_type_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), elem_type_.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn stack_pop_v2<T>(ctx: &Context, handle: T, elem_type_: DataType) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("StackPopV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("elem_type_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), elem_type_.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn stack_push<T>(ctx: &Context, handle: T, elem: T, swap_memory: bool) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("StackPush").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, elem.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("swap_memory").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), swap_memory as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn stack_push_v2<T>(
    ctx: &Context,
    handle: T,
    elem: T,
    swap_memory: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("StackPushV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, elem.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("swap_memory").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), swap_memory as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn stack_v2<T>(
    ctx: &Context,
    max_size: T,
    elem_type_: DataType,
    stack_name: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("StackV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, max_size.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("elem_type_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), elem_type_.to_c());

        let attr_name = CString::new("stack_name").unwrap();
        let stack_name_cstr = stack_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            stack_name_cstr.as_ptr() as *mut c_void,
            stack_name.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn stage_peek<T>(
    ctx: &Context,
    index: T,
    dtype_s: &Vec<DataType>,
    capacity: i64,
    memory_limit: i64,
    container: &String,
    shared_name: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("StagePeek").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, index.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("dtype_s").unwrap();
        let dtype_s: Vec<tf::TF_DataType> = dtype_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            dtype_s.as_ptr(),
            dtype_s.len() as i32,
        );

        let attr_name = CString::new("capacity").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), capacity);

        let attr_name = CString::new("memory_limit").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), memory_limit);

        let attr_name = CString::new("container").unwrap();
        let container_cstr = container.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            container_cstr.as_ptr() as *mut c_void,
            container.as_bytes().len() + 1,
        );

        let attr_name = CString::new("shared_name").unwrap();
        let shared_name_cstr = shared_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            shared_name_cstr.as_ptr() as *mut c_void,
            shared_name.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn stage_size<T>(
    ctx: &Context,
    dtype_s: &Vec<DataType>,
    capacity: i64,
    memory_limit: i64,
    container: &String,
    shared_name: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("StageSize").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("dtype_s").unwrap();
        let dtype_s: Vec<tf::TF_DataType> = dtype_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            dtype_s.as_ptr(),
            dtype_s.len() as i32,
        );

        let attr_name = CString::new("capacity").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), capacity);

        let attr_name = CString::new("memory_limit").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), memory_limit);

        let attr_name = CString::new("container").unwrap();
        let container_cstr = container.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            container_cstr.as_ptr() as *mut c_void,
            container.as_bytes().len() + 1,
        );

        let attr_name = CString::new("shared_name").unwrap();
        let shared_name_cstr = shared_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            shared_name_cstr.as_ptr() as *mut c_void,
            shared_name.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn stateful_random_binomial<T>(
    ctx: &Context,
    resource: T,
    algorithm: T,
    shape: T,
    counts: T,
    probs: T,
    S: DataType,
    dtype_: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("StatefulRandomBinomial").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, resource.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, algorithm.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, counts.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, probs.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("S").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), S.to_c());

        let attr_name = CString::new("dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), dtype_.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn stateful_standard_normal<T>(
    ctx: &Context,
    resource: T,
    shape: T,
    dtype_: DataType,
    shape_dtype_: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("StatefulStandardNormal").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, resource.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), dtype_.to_c());

        let attr_name = CString::new("shape_dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), shape_dtype_.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn stateful_standard_normal_v2<T>(
    ctx: &Context,
    resource: T,
    algorithm: T,
    shape: T,
    dtype_: DataType,
    shape_dtype_: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("StatefulStandardNormalV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, resource.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, algorithm.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), dtype_.to_c());

        let attr_name = CString::new("shape_dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), shape_dtype_.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn stateful_truncated_normal<T>(
    ctx: &Context,
    resource: T,
    algorithm: T,
    shape: T,
    dtype_: DataType,
    shape_dtype_: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("StatefulTruncatedNormal").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, resource.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, algorithm.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), dtype_.to_c());

        let attr_name = CString::new("shape_dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), shape_dtype_.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn stateful_uniform<T>(
    ctx: &Context,
    resource: T,
    algorithm: T,
    shape: T,
    dtype_: DataType,
    shape_dtype_: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("StatefulUniform").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, resource.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, algorithm.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), dtype_.to_c());

        let attr_name = CString::new("shape_dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), shape_dtype_.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn stateful_uniform_full_int<T>(
    ctx: &Context,
    resource: T,
    algorithm: T,
    shape: T,
    dtype_: DataType,
    shape_dtype_: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("StatefulUniformFullInt").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, resource.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, algorithm.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), dtype_.to_c());

        let attr_name = CString::new("shape_dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), shape_dtype_.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn stateful_uniform_int<T>(
    ctx: &Context,
    resource: T,
    algorithm: T,
    shape: T,
    minval: T,
    maxval: T,
    dtype_: DataType,
    shape_dtype_: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("StatefulUniformInt").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, resource.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, algorithm.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, minval.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, maxval.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), dtype_.to_c());

        let attr_name = CString::new("shape_dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), shape_dtype_.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn stateless_multinomial<T>(
    ctx: &Context,
    logits: T,
    num_samples: T,
    seed: T,
    Tseed: DataType,
    output_dtype_: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("StatelessMultinomial").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, logits.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, num_samples.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, seed.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tseed").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tseed.to_c());

        let attr_name = CString::new("output_dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), output_dtype_.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn stateless_parameterized_truncated_normal<T>(
    ctx: &Context,
    shape: T,
    seed: T,
    means: T,
    stddevs: T,
    minvals: T,
    maxvals: T,
    S: DataType,
    dtype_: DataType,
    Tseed: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("StatelessParameterizedTruncatedNormal").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, seed.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, means.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, stddevs.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, minvals.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, maxvals.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("S").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), S.to_c());

        let attr_name = CString::new("dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), dtype_.to_c());

        let attr_name = CString::new("Tseed").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tseed.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn stateless_random_binomial<T>(
    ctx: &Context,
    shape: T,
    seed: T,
    counts: T,
    probs: T,
    S: DataType,
    Tseed: DataType,
    dtype_: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("StatelessRandomBinomial").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, seed.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, counts.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, probs.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("S").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), S.to_c());

        let attr_name = CString::new("Tseed").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tseed.to_c());

        let attr_name = CString::new("dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), dtype_.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn stateless_random_gamma_v2<T>(
    ctx: &Context,
    shape: T,
    seed: T,
    alpha: T,
    dtype_: DataType,
    Tseed: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("StatelessRandomGammaV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, seed.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, alpha.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), dtype_.to_c());

        let attr_name = CString::new("Tseed").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tseed.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn stateless_random_normal<T>(
    ctx: &Context,
    shape: T,
    seed: T,
    dtype_: DataType,
    Tseed: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("StatelessRandomNormal").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, seed.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), dtype_.to_c());

        let attr_name = CString::new("Tseed").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tseed.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn stateless_random_poisson<T>(
    ctx: &Context,
    shape: T,
    seed: T,
    lam: T,
    Rtype_: DataType,
    dtype_: DataType,
    Tseed: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("StatelessRandomPoisson").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, seed.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, lam.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Rtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Rtype_.to_c());

        let attr_name = CString::new("dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), dtype_.to_c());

        let attr_name = CString::new("Tseed").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tseed.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn stateless_random_uniform<T>(
    ctx: &Context,
    shape: T,
    seed: T,
    dtype_: DataType,
    Tseed: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("StatelessRandomUniform").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, seed.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), dtype_.to_c());

        let attr_name = CString::new("Tseed").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tseed.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn stateless_random_uniform_full_int<T>(
    ctx: &Context,
    shape: T,
    seed: T,
    dtype_: DataType,
    Tseed: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("StatelessRandomUniformFullInt").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, seed.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), dtype_.to_c());

        let attr_name = CString::new("Tseed").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tseed.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn stateless_random_uniform_int<T>(
    ctx: &Context,
    shape: T,
    seed: T,
    minval: T,
    maxval: T,
    dtype_: DataType,
    Tseed: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("StatelessRandomUniformInt").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, seed.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, minval.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, maxval.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), dtype_.to_c());

        let attr_name = CString::new("Tseed").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tseed.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn stateless_truncated_normal<T>(
    ctx: &Context,
    shape: T,
    seed: T,
    dtype_: DataType,
    Tseed: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("StatelessTruncatedNormal").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, seed.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), dtype_.to_c());

        let attr_name = CString::new("Tseed").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tseed.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn static_regex_full_match<T>(ctx: &Context, input: T, pattern: &String) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("StaticRegexFullMatch").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("pattern").unwrap();
        let pattern_cstr = pattern.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            pattern_cstr.as_ptr() as *mut c_void,
            pattern.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn static_regex_replace<T>(
    ctx: &Context,
    input: T,
    pattern: &String,
    rewrite: &String,
    replace_global: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("StaticRegexReplace").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("pattern").unwrap();
        let pattern_cstr = pattern.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            pattern_cstr.as_ptr() as *mut c_void,
            pattern.as_bytes().len() + 1,
        );

        let attr_name = CString::new("rewrite").unwrap();
        let rewrite_cstr = rewrite.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            rewrite_cstr.as_ptr() as *mut c_void,
            rewrite.as_bytes().len() + 1,
        );

        let attr_name = CString::new("replace_global").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), replace_global as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn stats_aggregator_handle<T>(
    ctx: &Context,
    container: &String,
    shared_name: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("StatsAggregatorHandle").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("container").unwrap();
        let container_cstr = container.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            container_cstr.as_ptr() as *mut c_void,
            container.as_bytes().len() + 1,
        );

        let attr_name = CString::new("shared_name").unwrap();
        let shared_name_cstr = shared_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            shared_name_cstr.as_ptr() as *mut c_void,
            shared_name.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn stats_aggregator_handle_v2<T>(
    ctx: &Context,
    container: &String,
    shared_name: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("StatsAggregatorHandleV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("container").unwrap();
        let container_cstr = container.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            container_cstr.as_ptr() as *mut c_void,
            container.as_bytes().len() + 1,
        );

        let attr_name = CString::new("shared_name").unwrap();
        let shared_name_cstr = shared_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            shared_name_cstr.as_ptr() as *mut c_void,
            shared_name.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn stats_aggregator_summary<T>(ctx: &Context, iterator: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("StatsAggregatorSummary").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, iterator.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn stop_gradient<T>(ctx: &Context, input: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("StopGradient").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn strided_slice<T>(
    ctx: &Context,
    input: T,
    begin: T,
    end: T,
    strides: T,
    Index: DataType,
    begin_mask: i64,
    end_mask: i64,
    ellipsis_mask: i64,
    new_axis_mask: i64,
    shrink_axis_mask: i64,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("StridedSlice").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, begin.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, end.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, strides.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Index").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Index.to_c());

        let attr_name = CString::new("begin_mask").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), begin_mask);

        let attr_name = CString::new("end_mask").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), end_mask);

        let attr_name = CString::new("ellipsis_mask").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), ellipsis_mask);

        let attr_name = CString::new("new_axis_mask").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), new_axis_mask);

        let attr_name = CString::new("shrink_axis_mask").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), shrink_axis_mask);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn strided_slice_assign<T>(
    ctx: &Context,
    ref_: T,
    begin: T,
    end: T,
    strides: T,
    value: T,
    Index: DataType,
    begin_mask: i64,
    end_mask: i64,
    ellipsis_mask: i64,
    new_axis_mask: i64,
    shrink_axis_mask: i64,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("StridedSliceAssign").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, ref_.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, begin.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, end.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, strides.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, value.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Index").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Index.to_c());

        let attr_name = CString::new("begin_mask").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), begin_mask);

        let attr_name = CString::new("end_mask").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), end_mask);

        let attr_name = CString::new("ellipsis_mask").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), ellipsis_mask);

        let attr_name = CString::new("new_axis_mask").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), new_axis_mask);

        let attr_name = CString::new("shrink_axis_mask").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), shrink_axis_mask);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn strided_slice_grad<T>(
    ctx: &Context,
    shape: T,
    begin: T,
    end: T,
    strides: T,
    dy: T,
    Index: DataType,
    begin_mask: i64,
    end_mask: i64,
    ellipsis_mask: i64,
    new_axis_mask: i64,
    shrink_axis_mask: i64,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("StridedSliceGrad").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, begin.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, end.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, strides.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, dy.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Index").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Index.to_c());

        let attr_name = CString::new("begin_mask").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), begin_mask);

        let attr_name = CString::new("end_mask").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), end_mask);

        let attr_name = CString::new("ellipsis_mask").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), ellipsis_mask);

        let attr_name = CString::new("new_axis_mask").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), new_axis_mask);

        let attr_name = CString::new("shrink_axis_mask").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), shrink_axis_mask);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn string_format<T>(
    ctx: &Context,
    inputs: &Vec<T>,
    template_arg: &String,
    placeholder: &String,
    summarize: i64,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("StringFormat").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        let mut inputs_handles: Vec<*mut tf::TFE_TensorHandle> = inputs
            .into_iter()
            .map(|t| t.to_handle().unwrap().inner)
            .collect();
        tf::TFE_OpAddInputList(
            op,
            inputs_handles.as_mut_ptr(),
            inputs.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("template").unwrap();
        let template_arg_cstr = template_arg.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            template_arg_cstr.as_ptr() as *mut c_void,
            template_arg.as_bytes().len() + 1,
        );

        let attr_name = CString::new("placeholder").unwrap();
        let placeholder_cstr = placeholder.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            placeholder_cstr.as_ptr() as *mut c_void,
            placeholder.as_bytes().len() + 1,
        );

        let attr_name = CString::new("summarize").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), summarize);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn string_join<T>(ctx: &Context, inputs: &Vec<T>, separator: &String) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("StringJoin").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        let mut inputs_handles: Vec<*mut tf::TFE_TensorHandle> = inputs
            .into_iter()
            .map(|t| t.to_handle().unwrap().inner)
            .collect();
        tf::TFE_OpAddInputList(
            op,
            inputs_handles.as_mut_ptr(),
            inputs.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("N").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), inputs.len() as i64);

        let attr_name = CString::new("separator").unwrap();
        let separator_cstr = separator.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            separator_cstr.as_ptr() as *mut c_void,
            separator.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn string_length<T>(ctx: &Context, input: T, unit: &String) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("StringLength").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("unit").unwrap();
        let unit_cstr = unit.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            unit_cstr.as_ptr() as *mut c_void,
            unit.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn string_lower<T>(ctx: &Context, input: T, encoding: &String) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("StringLower").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("encoding").unwrap();
        let encoding_cstr = encoding.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            encoding_cstr.as_ptr() as *mut c_void,
            encoding.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn string_strip<T>(ctx: &Context, input: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("StringStrip").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn string_to_hash_bucket<T>(
    ctx: &Context,
    string_tensor: T,
    num_buckets: i64,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("StringToHashBucket").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, string_tensor.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("num_buckets").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), num_buckets);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn string_to_hash_bucket_fast<T>(
    ctx: &Context,
    input: T,
    num_buckets: i64,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("StringToHashBucketFast").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("num_buckets").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), num_buckets);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn string_to_hash_bucket_strong<T>(
    ctx: &Context,
    input: T,
    num_buckets: i64,
    key: &Vec<i64>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("StringToHashBucketStrong").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("num_buckets").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), num_buckets);

        let attr_name = CString::new("key").unwrap();
        tf::TFE_OpSetAttrIntList(op, attr_name.as_ptr(), key.as_ptr(), key.len() as i32);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn string_to_number<T>(
    ctx: &Context,
    string_tensor: T,
    out_type_: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("StringToNumber").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, string_tensor.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("out_type_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), out_type_.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn string_upper<T>(ctx: &Context, input: T, encoding: &String) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("StringUpper").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("encoding").unwrap();
        let encoding_cstr = encoding.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            encoding_cstr.as_ptr() as *mut c_void,
            encoding.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn sub<T>(ctx: &Context, x: T, y: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Sub").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, y.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn substr<T>(ctx: &Context, input: T, pos: T, len: T, unit: &String) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Substr").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, pos.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, len.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("unit").unwrap();
        let unit_cstr = unit.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            unit_cstr.as_ptr() as *mut c_void,
            unit.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn sum<T>(
    ctx: &Context,
    input: T,
    reduction_indices: T,
    keep_dims: bool,
    Tidx: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Sum").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, reduction_indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("keep_dims").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), keep_dims as u8);

        let attr_name = CString::new("Tidx").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tidx.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn summary_writer<T>(
    ctx: &Context,
    shared_name: &String,
    container: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("SummaryWriter").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("shared_name").unwrap();
        let shared_name_cstr = shared_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            shared_name_cstr.as_ptr() as *mut c_void,
            shared_name.as_bytes().len() + 1,
        );

        let attr_name = CString::new("container").unwrap();
        let container_cstr = container.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            container_cstr.as_ptr() as *mut c_void,
            container.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn t_f_record_dataset<T>(
    ctx: &Context,
    filenames: T,
    compression_type: T,
    buffer_size: T,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TFRecordDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, filenames.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, compression_type.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, buffer_size.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn t_f_record_reader<T>(
    ctx: &Context,
    container: &String,
    shared_name: &String,
    compression_type_: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TFRecordReader").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("container").unwrap();
        let container_cstr = container.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            container_cstr.as_ptr() as *mut c_void,
            container.as_bytes().len() + 1,
        );

        let attr_name = CString::new("shared_name").unwrap();
        let shared_name_cstr = shared_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            shared_name_cstr.as_ptr() as *mut c_void,
            shared_name.as_bytes().len() + 1,
        );

        let attr_name = CString::new("compression_type_").unwrap();
        let compression_type__cstr = compression_type_.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            compression_type__cstr.as_ptr() as *mut c_void,
            compression_type_.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn t_f_record_reader_v2<T>(
    ctx: &Context,
    container: &String,
    shared_name: &String,
    compression_type_: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TFRecordReaderV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("container").unwrap();
        let container_cstr = container.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            container_cstr.as_ptr() as *mut c_void,
            container.as_bytes().len() + 1,
        );

        let attr_name = CString::new("shared_name").unwrap();
        let shared_name_cstr = shared_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            shared_name_cstr.as_ptr() as *mut c_void,
            shared_name.as_bytes().len() + 1,
        );

        let attr_name = CString::new("compression_type_").unwrap();
        let compression_type__cstr = compression_type_.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            compression_type__cstr.as_ptr() as *mut c_void,
            compression_type_.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn t_p_u_compilation_result<T>(ctx: &Context) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TPUCompilationResult").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn t_p_u_embedding_activations<T>(
    ctx: &Context,
    embedding_variable: T,
    sliced_activations: T,
    table_id: i64,
    lookup_id: i64,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TPUEmbeddingActivations").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, embedding_variable.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, sliced_activations.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("table_id").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), table_id);

        let attr_name = CString::new("lookup_id").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), lookup_id);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn t_p_u_ordinal_selector<T>(ctx: &Context) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TPUOrdinalSelector").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn t_p_u_replicated_input<T>(
    ctx: &Context,
    inputs: &Vec<T>,
    is_mirrored_variable: bool,
    index: i64,
    is_packed: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TPUReplicatedInput").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        let mut inputs_handles: Vec<*mut tf::TFE_TensorHandle> = inputs
            .into_iter()
            .map(|t| t.to_handle().unwrap().inner)
            .collect();
        tf::TFE_OpAddInputList(
            op,
            inputs_handles.as_mut_ptr(),
            inputs.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("N").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), inputs.len() as i64);

        let attr_name = CString::new("is_mirrored_variable").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), is_mirrored_variable as u8);

        let attr_name = CString::new("index").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), index);

        let attr_name = CString::new("is_packed").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), is_packed as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn t_p_u_replicated_output<T>(
    ctx: &Context,
    input: T,
    num_replicas: i64,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TPUReplicatedOutput").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("num_replicas").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), num_replicas);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn take_dataset<T>(
    ctx: &Context,
    input_dataset: T,
    count: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TakeDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, count.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn tan<T>(ctx: &Context, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Tan").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn tanh<T>(ctx: &Context, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Tanh").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn tanh_grad<T>(ctx: &Context, y: T, dy: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TanhGrad").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, y.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, dy.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn temporary_variable<T>(
    ctx: &Context,
    shape: &Vec<i64>,
    dtype_: DataType,
    var_name: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TemporaryVariable").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("shape").unwrap();
        tf::TFE_OpSetAttrShape(
            op,
            attr_name.as_ptr(),
            shape.as_ptr(),
            shape.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        let attr_name = CString::new("dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), dtype_.to_c());

        let attr_name = CString::new("var_name").unwrap();
        let var_name_cstr = var_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            var_name_cstr.as_ptr() as *mut c_void,
            var_name.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn tensor_array<T>(
    ctx: &Context,
    size: T,
    dtype_: DataType,
    element_shape: &Vec<i64>,
    dynamic_size: bool,
    clear_after_read: bool,
    tensor_array_name: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TensorArray").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, size.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), dtype_.to_c());

        let attr_name = CString::new("element_shape").unwrap();
        tf::TFE_OpSetAttrShape(
            op,
            attr_name.as_ptr(),
            element_shape.as_ptr(),
            element_shape.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        let attr_name = CString::new("dynamic_size").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), dynamic_size as u8);

        let attr_name = CString::new("clear_after_read").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), clear_after_read as u8);

        let attr_name = CString::new("tensor_array_name").unwrap();
        let tensor_array_name_cstr = tensor_array_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            tensor_array_name_cstr.as_ptr() as *mut c_void,
            tensor_array_name.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn tensor_array_gather<T>(
    ctx: &Context,
    handle: T,
    indices: T,
    flow_in: T,
    dtype_: DataType,
    element_shape: &Vec<i64>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TensorArrayGather").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, flow_in.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), dtype_.to_c());

        let attr_name = CString::new("element_shape").unwrap();
        tf::TFE_OpSetAttrShape(
            op,
            attr_name.as_ptr(),
            element_shape.as_ptr(),
            element_shape.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn tensor_array_gather_v2<T>(
    ctx: &Context,
    handle: T,
    indices: T,
    flow_in: T,
    dtype_: DataType,
    element_shape: &Vec<i64>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TensorArrayGatherV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, flow_in.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), dtype_.to_c());

        let attr_name = CString::new("element_shape").unwrap();
        tf::TFE_OpSetAttrShape(
            op,
            attr_name.as_ptr(),
            element_shape.as_ptr(),
            element_shape.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn tensor_array_gather_v3<T>(
    ctx: &Context,
    handle: T,
    indices: T,
    flow_in: T,
    dtype_: DataType,
    element_shape: &Vec<i64>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TensorArrayGatherV3").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, flow_in.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), dtype_.to_c());

        let attr_name = CString::new("element_shape").unwrap();
        tf::TFE_OpSetAttrShape(
            op,
            attr_name.as_ptr(),
            element_shape.as_ptr(),
            element_shape.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn tensor_array_grad<T>(
    ctx: &Context,
    handle: T,
    flow_in: T,
    source: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TensorArrayGrad").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, flow_in.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("source").unwrap();
        let source_cstr = source.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            source_cstr.as_ptr() as *mut c_void,
            source.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn tensor_array_grad_v2<T>(
    ctx: &Context,
    handle: T,
    flow_in: T,
    source: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TensorArrayGradV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, flow_in.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("source").unwrap();
        let source_cstr = source.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            source_cstr.as_ptr() as *mut c_void,
            source.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn tensor_array_pack<T>(
    ctx: &Context,
    handle: T,
    flow_in: T,
    dtype_: DataType,
    element_shape: &Vec<i64>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TensorArrayPack").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, flow_in.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), dtype_.to_c());

        let attr_name = CString::new("element_shape").unwrap();
        tf::TFE_OpSetAttrShape(
            op,
            attr_name.as_ptr(),
            element_shape.as_ptr(),
            element_shape.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn tensor_array_read<T>(
    ctx: &Context,
    handle: T,
    index: T,
    flow_in: T,
    dtype_: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TensorArrayRead").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, index.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, flow_in.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), dtype_.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn tensor_array_read_v2<T>(
    ctx: &Context,
    handle: T,
    index: T,
    flow_in: T,
    dtype_: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TensorArrayReadV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, index.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, flow_in.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), dtype_.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn tensor_array_read_v3<T>(
    ctx: &Context,
    handle: T,
    index: T,
    flow_in: T,
    dtype_: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TensorArrayReadV3").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, index.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, flow_in.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), dtype_.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn tensor_array_scatter<T>(
    ctx: &Context,
    handle: T,
    indices: T,
    value: T,
    flow_in: T,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TensorArrayScatter").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, value.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, flow_in.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn tensor_array_scatter_v2<T>(
    ctx: &Context,
    handle: T,
    indices: T,
    value: T,
    flow_in: T,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TensorArrayScatterV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, value.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, flow_in.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn tensor_array_scatter_v3<T>(
    ctx: &Context,
    handle: T,
    indices: T,
    value: T,
    flow_in: T,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TensorArrayScatterV3").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, value.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, flow_in.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn tensor_array_size<T>(ctx: &Context, handle: T, flow_in: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TensorArraySize").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, flow_in.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn tensor_array_size_v2<T>(ctx: &Context, handle: T, flow_in: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TensorArraySizeV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, flow_in.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn tensor_array_size_v3<T>(ctx: &Context, handle: T, flow_in: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TensorArraySizeV3").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, flow_in.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn tensor_array_split<T>(
    ctx: &Context,
    handle: T,
    value: T,
    lengths: T,
    flow_in: T,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TensorArraySplit").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, value.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, lengths.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, flow_in.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn tensor_array_split_v2<T>(
    ctx: &Context,
    handle: T,
    value: T,
    lengths: T,
    flow_in: T,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TensorArraySplitV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, value.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, lengths.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, flow_in.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn tensor_array_split_v3<T>(
    ctx: &Context,
    handle: T,
    value: T,
    lengths: T,
    flow_in: T,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TensorArraySplitV3").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, value.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, lengths.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, flow_in.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn tensor_array_unpack<T>(
    ctx: &Context,
    handle: T,
    value: T,
    flow_in: T,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TensorArrayUnpack").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, value.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, flow_in.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn tensor_array_v2<T>(
    ctx: &Context,
    size: T,
    dtype_: DataType,
    element_shape: &Vec<i64>,
    dynamic_size: bool,
    clear_after_read: bool,
    tensor_array_name: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TensorArrayV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, size.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), dtype_.to_c());

        let attr_name = CString::new("element_shape").unwrap();
        tf::TFE_OpSetAttrShape(
            op,
            attr_name.as_ptr(),
            element_shape.as_ptr(),
            element_shape.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        let attr_name = CString::new("dynamic_size").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), dynamic_size as u8);

        let attr_name = CString::new("clear_after_read").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), clear_after_read as u8);

        let attr_name = CString::new("tensor_array_name").unwrap();
        let tensor_array_name_cstr = tensor_array_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            tensor_array_name_cstr.as_ptr() as *mut c_void,
            tensor_array_name.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn tensor_array_write<T>(
    ctx: &Context,
    handle: T,
    index: T,
    value: T,
    flow_in: T,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TensorArrayWrite").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, index.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, value.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, flow_in.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn tensor_array_write_v2<T>(
    ctx: &Context,
    handle: T,
    index: T,
    value: T,
    flow_in: T,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TensorArrayWriteV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, index.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, value.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, flow_in.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn tensor_array_write_v3<T>(
    ctx: &Context,
    handle: T,
    index: T,
    value: T,
    flow_in: T,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TensorArrayWriteV3").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, index.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, value.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, flow_in.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn tensor_dataset<T>(
    ctx: &Context,
    components: &Vec<T>,
    Toutput_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TensorDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        let mut components_handles: Vec<*mut tf::TFE_TensorHandle> = components
            .into_iter()
            .map(|t| t.to_handle().unwrap().inner)
            .collect();
        tf::TFE_OpAddInputList(
            op,
            components_handles.as_mut_ptr(),
            components.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Toutput_type_s").unwrap();
        let Toutput_type_s: Vec<tf::TF_DataType> =
            Toutput_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            Toutput_type_s.as_ptr(),
            Toutput_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn tensor_list_concat_lists<T>(
    ctx: &Context,
    input_a: T,
    input_b: T,
    element_dtype_: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TensorListConcatLists").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_a.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, input_b.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("element_dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), element_dtype_.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn tensor_list_element_shape<T>(
    ctx: &Context,
    input_handle: T,
    shape_type_: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TensorListElementShape").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("shape_type_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), shape_type_.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn tensor_list_from_tensor<T>(
    ctx: &Context,
    tensor: T,
    element_shape: T,
    element_dtype_: DataType,
    shape_type_: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TensorListFromTensor").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, tensor.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, element_shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("element_dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), element_dtype_.to_c());

        let attr_name = CString::new("shape_type_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), shape_type_.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn tensor_list_gather<T>(
    ctx: &Context,
    input_handle: T,
    indices: T,
    element_shape: T,
    element_dtype_: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TensorListGather").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, element_shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("element_dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), element_dtype_.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn tensor_list_get_item<T>(
    ctx: &Context,
    input_handle: T,
    index: T,
    element_shape: T,
    element_dtype_: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TensorListGetItem").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, index.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, element_shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("element_dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), element_dtype_.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn tensor_list_length<T>(ctx: &Context, input_handle: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TensorListLength").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn tensor_list_push_back<T>(
    ctx: &Context,
    input_handle: T,
    tensor: T,
    element_dtype_: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TensorListPushBack").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, tensor.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("element_dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), element_dtype_.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn tensor_list_push_back_batch<T>(
    ctx: &Context,
    input_handles: T,
    tensor: T,
    element_dtype_: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TensorListPushBackBatch").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_handles.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, tensor.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("element_dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), element_dtype_.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn tensor_list_reserve<T>(
    ctx: &Context,
    element_shape: T,
    num_elements: T,
    element_dtype_: DataType,
    shape_type_: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TensorListReserve").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, element_shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, num_elements.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("element_dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), element_dtype_.to_c());

        let attr_name = CString::new("shape_type_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), shape_type_.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn tensor_list_resize<T>(ctx: &Context, input_handle: T, size: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TensorListResize").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, size.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn tensor_list_scatter<T>(
    ctx: &Context,
    tensor: T,
    indices: T,
    element_shape: T,
    element_dtype_: DataType,
    shape_type_: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TensorListScatter").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, tensor.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, element_shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("element_dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), element_dtype_.to_c());

        let attr_name = CString::new("shape_type_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), shape_type_.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn tensor_list_scatter_into_existing_list<T>(
    ctx: &Context,
    input_handle: T,
    tensor: T,
    indices: T,
    element_dtype_: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TensorListScatterIntoExistingList").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, tensor.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("element_dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), element_dtype_.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn tensor_list_scatter_v2<T>(
    ctx: &Context,
    tensor: T,
    indices: T,
    element_shape: T,
    num_elements: T,
    element_dtype_: DataType,
    shape_type_: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TensorListScatterV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, tensor.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, element_shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, num_elements.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("element_dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), element_dtype_.to_c());

        let attr_name = CString::new("shape_type_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), shape_type_.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn tensor_list_set_item<T>(
    ctx: &Context,
    input_handle: T,
    index: T,
    item: T,
    element_dtype_: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TensorListSetItem").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, index.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, item.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("element_dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), element_dtype_.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn tensor_list_split<T>(
    ctx: &Context,
    tensor: T,
    element_shape: T,
    lengths: T,
    element_dtype_: DataType,
    shape_type_: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TensorListSplit").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, tensor.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, element_shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, lengths.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("element_dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), element_dtype_.to_c());

        let attr_name = CString::new("shape_type_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), shape_type_.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn tensor_list_stack<T>(
    ctx: &Context,
    input_handle: T,
    element_shape: T,
    element_dtype_: DataType,
    num_elements: i64,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TensorListStack").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, element_shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("element_dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), element_dtype_.to_c());

        let attr_name = CString::new("num_elements").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), num_elements);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn tensor_scatter_add<T>(
    ctx: &Context,
    tensor: T,
    indices: T,
    updates: T,
    Tindices: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TensorScatterAdd").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, tensor.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, updates.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tindices").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tindices.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn tensor_scatter_max<T>(
    ctx: &Context,
    tensor: T,
    indices: T,
    updates: T,
    Tindices: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TensorScatterMax").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, tensor.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, updates.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tindices").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tindices.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn tensor_scatter_min<T>(
    ctx: &Context,
    tensor: T,
    indices: T,
    updates: T,
    Tindices: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TensorScatterMin").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, tensor.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, updates.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tindices").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tindices.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn tensor_scatter_sub<T>(
    ctx: &Context,
    tensor: T,
    indices: T,
    updates: T,
    Tindices: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TensorScatterSub").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, tensor.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, updates.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tindices").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tindices.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn tensor_scatter_update<T>(
    ctx: &Context,
    tensor: T,
    indices: T,
    updates: T,
    Tindices: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TensorScatterUpdate").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, tensor.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, updates.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tindices").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tindices.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn tensor_slice_dataset<T>(
    ctx: &Context,
    components: &Vec<T>,
    Toutput_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TensorSliceDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        let mut components_handles: Vec<*mut tf::TFE_TensorHandle> = components
            .into_iter()
            .map(|t| t.to_handle().unwrap().inner)
            .collect();
        tf::TFE_OpAddInputList(
            op,
            components_handles.as_mut_ptr(),
            components.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Toutput_type_s").unwrap();
        let Toutput_type_s: Vec<tf::TF_DataType> =
            Toutput_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            Toutput_type_s.as_ptr(),
            Toutput_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn tensor_strided_slice_update<T>(
    ctx: &Context,
    input: T,
    begin: T,
    end: T,
    strides: T,
    value: T,
    Index: DataType,
    begin_mask: i64,
    end_mask: i64,
    ellipsis_mask: i64,
    new_axis_mask: i64,
    shrink_axis_mask: i64,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TensorStridedSliceUpdate").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, begin.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, end.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, strides.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, value.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Index").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Index.to_c());

        let attr_name = CString::new("begin_mask").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), begin_mask);

        let attr_name = CString::new("end_mask").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), end_mask);

        let attr_name = CString::new("ellipsis_mask").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), ellipsis_mask);

        let attr_name = CString::new("new_axis_mask").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), new_axis_mask);

        let attr_name = CString::new("shrink_axis_mask").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), shrink_axis_mask);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn tensor_summary<T>(
    ctx: &Context,
    tensor: T,
    labels: &Vec<String>,
    description: &String,
    display_name: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TensorSummary").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, tensor.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let labels_cstr: Vec<CString> = labels
            .into_iter()
            .map(|v| CString::new(v.as_bytes()).unwrap())
            .collect();
        let labels_ptr: Vec<*const c_void> = labels_cstr
            .as_slice()
            .into_iter()
            .map(|v| v.as_ptr() as *const c_void)
            .collect();
        let labels_sizes: Vec<usize> = labels_cstr
            .as_slice()
            .into_iter()
            .map(|v| v.as_bytes().len())
            .collect();
        let attr_name = CString::new("labels").unwrap();
        tf::TFE_OpSetAttrStringList(
            op,
            attr_name.as_ptr(),
            labels_ptr.as_ptr(),
            labels_sizes.as_ptr(),
            labels.len() as i32,
        );

        let attr_name = CString::new("description").unwrap();
        let description_cstr = description.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            description_cstr.as_ptr() as *mut c_void,
            description.as_bytes().len() + 1,
        );

        let attr_name = CString::new("display_name").unwrap();
        let display_name_cstr = display_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            display_name_cstr.as_ptr() as *mut c_void,
            display_name.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn tensor_summary_v2<T>(
    ctx: &Context,
    tag: T,
    tensor: T,
    serialized_summary_metadata: T,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TensorSummaryV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, tag.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, tensor.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(
            op,
            serialized_summary_metadata.to_handle()?.inner,
            status.inner,
        );
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn text_line_dataset<T>(
    ctx: &Context,
    filenames: T,
    compression_type: T,
    buffer_size: T,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TextLineDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, filenames.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, compression_type.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, buffer_size.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn text_line_reader<T>(
    ctx: &Context,
    skip_header_lines: i64,
    container: &String,
    shared_name: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TextLineReader").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("skip_header_lines").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), skip_header_lines);

        let attr_name = CString::new("container").unwrap();
        let container_cstr = container.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            container_cstr.as_ptr() as *mut c_void,
            container.as_bytes().len() + 1,
        );

        let attr_name = CString::new("shared_name").unwrap();
        let shared_name_cstr = shared_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            shared_name_cstr.as_ptr() as *mut c_void,
            shared_name.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn text_line_reader_v2<T>(
    ctx: &Context,
    skip_header_lines: i64,
    container: &String,
    shared_name: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TextLineReaderV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("skip_header_lines").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), skip_header_lines);

        let attr_name = CString::new("container").unwrap();
        let container_cstr = container.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            container_cstr.as_ptr() as *mut c_void,
            container.as_bytes().len() + 1,
        );

        let attr_name = CString::new("shared_name").unwrap();
        let shared_name_cstr = shared_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            shared_name_cstr.as_ptr() as *mut c_void,
            shared_name.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn thread_pool_dataset<T>(
    ctx: &Context,
    input_dataset: T,
    thread_pool: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ThreadPoolDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, thread_pool.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn thread_pool_handle<T>(
    ctx: &Context,
    num_threads: i64,
    display_name: &String,
    max_intra_op_parallelism: i64,
    container: &String,
    shared_name: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ThreadPoolHandle").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("num_threads").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), num_threads);

        let attr_name = CString::new("display_name").unwrap();
        let display_name_cstr = display_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            display_name_cstr.as_ptr() as *mut c_void,
            display_name.as_bytes().len() + 1,
        );

        let attr_name = CString::new("max_intra_op_parallelism").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), max_intra_op_parallelism);

        let attr_name = CString::new("container").unwrap();
        let container_cstr = container.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            container_cstr.as_ptr() as *mut c_void,
            container.as_bytes().len() + 1,
        );

        let attr_name = CString::new("shared_name").unwrap();
        let shared_name_cstr = shared_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            shared_name_cstr.as_ptr() as *mut c_void,
            shared_name.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn tile<T>(ctx: &Context, input: T, multiples: T, Tmultiples: DataType) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Tile").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, multiples.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tmultiples").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tmultiples.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn tile_grad<T>(ctx: &Context, input: T, multiples: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TileGrad").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, multiples.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn timestamp<T>(ctx: &Context) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Timestamp").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn to_bool<T>(ctx: &Context, input: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ToBool").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn transpose<T>(ctx: &Context, x: T, perm: T, Tperm: DataType) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Transpose").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, perm.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tperm").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tperm.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn tridiagonal_mat_mul<T>(
    ctx: &Context,
    superdiag: T,
    maindiag: T,
    subdiag: T,
    rhs: T,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TridiagonalMatMul").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, superdiag.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, maindiag.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, subdiag.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, rhs.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn tridiagonal_solve<T>(
    ctx: &Context,
    diagonals: T,
    rhs: T,
    partial_pivoting: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TridiagonalSolve").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, diagonals.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, rhs.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("partial_pivoting").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), partial_pivoting as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn truncate_div<T>(ctx: &Context, x: T, y: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TruncateDiv").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, y.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn truncate_mod_<T>(ctx: &Context, x: T, y: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TruncateMod").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, y.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn truncated_normal<T>(
    ctx: &Context,
    shape: T,
    dtype_: DataType,
    seed: i64,
    seed2: i64,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("TruncatedNormal").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, shape.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), dtype_.to_c());

        let attr_name = CString::new("seed").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), seed);

        let attr_name = CString::new("seed2").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), seed2);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn unbatch<T>(
    ctx: &Context,
    batched_tensor: T,
    batch_index: T,
    id: T,
    timeout_micros: i64,
    container: &String,
    shared_name: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Unbatch").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, batched_tensor.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, batch_index.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, id.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("timeout_micros").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), timeout_micros);

        let attr_name = CString::new("container").unwrap();
        let container_cstr = container.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            container_cstr.as_ptr() as *mut c_void,
            container.as_bytes().len() + 1,
        );

        let attr_name = CString::new("shared_name").unwrap();
        let shared_name_cstr = shared_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            shared_name_cstr.as_ptr() as *mut c_void,
            shared_name.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn unbatch_dataset<T>(
    ctx: &Context,
    input_dataset: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("UnbatchDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn unbatch_grad<T>(
    ctx: &Context,
    original_input: T,
    batch_index: T,
    grad: T,
    id: T,
    container: &String,
    shared_name: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("UnbatchGrad").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, original_input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, batch_index.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, grad.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, id.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("container").unwrap();
        let container_cstr = container.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            container_cstr.as_ptr() as *mut c_void,
            container.as_bytes().len() + 1,
        );

        let attr_name = CString::new("shared_name").unwrap();
        let shared_name_cstr = shared_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            shared_name_cstr.as_ptr() as *mut c_void,
            shared_name.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn uncompress_element<T>(
    ctx: &Context,
    compressed: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("UncompressElement").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, compressed.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn unicode_encode<T>(
    ctx: &Context,
    input_values: T,
    input_splits: T,
    output_encoding: &String,
    errors: &String,
    replacement_char: i64,
    Tsplits: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("UnicodeEncode").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_values.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, input_splits.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_encoding").unwrap();
        let output_encoding_cstr = output_encoding.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            output_encoding_cstr.as_ptr() as *mut c_void,
            output_encoding.as_bytes().len() + 1,
        );

        let attr_name = CString::new("errors").unwrap();
        let errors_cstr = errors.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            errors_cstr.as_ptr() as *mut c_void,
            errors.as_bytes().len() + 1,
        );

        let attr_name = CString::new("replacement_char").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), replacement_char);

        let attr_name = CString::new("Tsplits").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tsplits.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn unicode_script<T>(ctx: &Context, input: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("UnicodeScript").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn unicode_transcode<T>(
    ctx: &Context,
    input: T,
    input_encoding: &String,
    output_encoding: &String,
    errors: &String,
    replacement_char: i64,
    replace_control_characters: bool,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("UnicodeTranscode").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("input_encoding").unwrap();
        let input_encoding_cstr = input_encoding.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            input_encoding_cstr.as_ptr() as *mut c_void,
            input_encoding.as_bytes().len() + 1,
        );

        let attr_name = CString::new("output_encoding").unwrap();
        let output_encoding_cstr = output_encoding.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            output_encoding_cstr.as_ptr() as *mut c_void,
            output_encoding.as_bytes().len() + 1,
        );

        let attr_name = CString::new("errors").unwrap();
        let errors_cstr = errors.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            errors_cstr.as_ptr() as *mut c_void,
            errors.as_bytes().len() + 1,
        );

        let attr_name = CString::new("replacement_char").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), replacement_char);

        let attr_name = CString::new("replace_control_characters").unwrap();
        tf::TFE_OpSetAttrBool(op, attr_name.as_ptr(), replace_control_characters as u8);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn unique_dataset<T>(
    ctx: &Context,
    input_dataset: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("UniqueDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn unpack<T>(ctx: &Context, value: T, num: i64, axis: i64) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Unpack").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, value.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("num").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), num);

        let attr_name = CString::new("axis").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), axis);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn unravel_index<T>(ctx: &Context, indices: T, dims: T, Tidx: DataType) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("UnravelIndex").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, indices.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, dims.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tidx").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tidx.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn unsorted_segment_join<T>(
    ctx: &Context,
    inputs: T,
    segment_ids: T,
    num_segments: T,
    Tindices: DataType,
    separator: &String,
    Tnumsegments: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("UnsortedSegmentJoin").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, inputs.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, segment_ids.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, num_segments.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tindices").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tindices.to_c());

        let attr_name = CString::new("separator").unwrap();
        let separator_cstr = separator.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            separator_cstr.as_ptr() as *mut c_void,
            separator.as_bytes().len() + 1,
        );

        let attr_name = CString::new("Tnumsegments").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tnumsegments.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn unsorted_segment_max<T>(
    ctx: &Context,
    data: T,
    segment_ids: T,
    num_segments: T,
    Tindices: DataType,
    Tnumsegments: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("UnsortedSegmentMax").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, data.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, segment_ids.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, num_segments.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tindices").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tindices.to_c());

        let attr_name = CString::new("Tnumsegments").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tnumsegments.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn unsorted_segment_min<T>(
    ctx: &Context,
    data: T,
    segment_ids: T,
    num_segments: T,
    Tindices: DataType,
    Tnumsegments: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("UnsortedSegmentMin").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, data.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, segment_ids.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, num_segments.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tindices").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tindices.to_c());

        let attr_name = CString::new("Tnumsegments").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tnumsegments.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn unsorted_segment_prod<T>(
    ctx: &Context,
    data: T,
    segment_ids: T,
    num_segments: T,
    Tindices: DataType,
    Tnumsegments: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("UnsortedSegmentProd").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, data.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, segment_ids.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, num_segments.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tindices").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tindices.to_c());

        let attr_name = CString::new("Tnumsegments").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tnumsegments.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn unsorted_segment_sum<T>(
    ctx: &Context,
    data: T,
    segment_ids: T,
    num_segments: T,
    Tindices: DataType,
    Tnumsegments: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("UnsortedSegmentSum").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, data.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, segment_ids.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, num_segments.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("Tindices").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tindices.to_c());

        let attr_name = CString::new("Tnumsegments").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), Tnumsegments.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn unstage<T>(
    ctx: &Context,
    dtype_s: &Vec<DataType>,
    capacity: i64,
    memory_limit: i64,
    container: &String,
    shared_name: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Unstage").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("dtype_s").unwrap();
        let dtype_s: Vec<tf::TF_DataType> = dtype_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            dtype_s.as_ptr(),
            dtype_s.len() as i32,
        );

        let attr_name = CString::new("capacity").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), capacity);

        let attr_name = CString::new("memory_limit").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), memory_limit);

        let attr_name = CString::new("container").unwrap();
        let container_cstr = container.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            container_cstr.as_ptr() as *mut c_void,
            container.as_bytes().len() + 1,
        );

        let attr_name = CString::new("shared_name").unwrap();
        let shared_name_cstr = shared_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            shared_name_cstr.as_ptr() as *mut c_void,
            shared_name.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn unwrap_dataset_variant<T>(ctx: &Context, input_handle: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("UnwrapDatasetVariant").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn upper_bound<T>(
    ctx: &Context,
    sorted_inputs: T,
    values: T,
    out_type_: DataType,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("UpperBound").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, sorted_inputs.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, values.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("out_type_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), out_type_.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn var_handle_op<T>(
    ctx: &Context,
    dtype_: DataType,
    shape: &Vec<i64>,
    allowed_devices: &Vec<String>,
    container: &String,
    shared_name: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("VarHandleOp").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), dtype_.to_c());

        let attr_name = CString::new("shape").unwrap();
        tf::TFE_OpSetAttrShape(
            op,
            attr_name.as_ptr(),
            shape.as_ptr(),
            shape.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        let allowed_devices_cstr: Vec<CString> = allowed_devices
            .into_iter()
            .map(|v| CString::new(v.as_bytes()).unwrap())
            .collect();
        let allowed_devices_ptr: Vec<*const c_void> = allowed_devices_cstr
            .as_slice()
            .into_iter()
            .map(|v| v.as_ptr() as *const c_void)
            .collect();
        let allowed_devices_sizes: Vec<usize> = allowed_devices_cstr
            .as_slice()
            .into_iter()
            .map(|v| v.as_bytes().len())
            .collect();
        let attr_name = CString::new("allowed_devices").unwrap();
        tf::TFE_OpSetAttrStringList(
            op,
            attr_name.as_ptr(),
            allowed_devices_ptr.as_ptr(),
            allowed_devices_sizes.as_ptr(),
            allowed_devices.len() as i32,
        );

        let attr_name = CString::new("container").unwrap();
        let container_cstr = container.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            container_cstr.as_ptr() as *mut c_void,
            container.as_bytes().len() + 1,
        );

        let attr_name = CString::new("shared_name").unwrap();
        let shared_name_cstr = shared_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            shared_name_cstr.as_ptr() as *mut c_void,
            shared_name.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn var_is_initialized_op<T>(ctx: &Context, resource: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("VarIsInitializedOp").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, resource.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn variable<T>(
    ctx: &Context,
    shape: &Vec<i64>,
    dtype_: DataType,
    container: &String,
    shared_name: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Variable").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("shape").unwrap();
        tf::TFE_OpSetAttrShape(
            op,
            attr_name.as_ptr(),
            shape.as_ptr(),
            shape.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        let attr_name = CString::new("dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), dtype_.to_c());

        let attr_name = CString::new("container").unwrap();
        let container_cstr = container.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            container_cstr.as_ptr() as *mut c_void,
            container.as_bytes().len() + 1,
        );

        let attr_name = CString::new("shared_name").unwrap();
        let shared_name_cstr = shared_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            shared_name_cstr.as_ptr() as *mut c_void,
            shared_name.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn variable_shape<T>(ctx: &Context, input: T, out_type_: DataType) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("VariableShape").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("out_type_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), out_type_.to_c());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn variable_v2<T>(
    ctx: &Context,
    shape: &Vec<i64>,
    dtype_: DataType,
    container: &String,
    shared_name: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("VariableV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("shape").unwrap();
        tf::TFE_OpSetAttrShape(
            op,
            attr_name.as_ptr(),
            shape.as_ptr(),
            shape.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        let attr_name = CString::new("dtype_").unwrap();
        tf::TFE_OpSetAttrType(op, attr_name.as_ptr(), dtype_.to_c());

        let attr_name = CString::new("container").unwrap();
        let container_cstr = container.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            container_cstr.as_ptr() as *mut c_void,
            container.as_bytes().len() + 1,
        );

        let attr_name = CString::new("shared_name").unwrap();
        let shared_name_cstr = shared_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            shared_name_cstr.as_ptr() as *mut c_void,
            shared_name.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn where_<T>(ctx: &Context, input: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Where").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn whole_file_reader<T>(
    ctx: &Context,
    container: &String,
    shared_name: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("WholeFileReader").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("container").unwrap();
        let container_cstr = container.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            container_cstr.as_ptr() as *mut c_void,
            container.as_bytes().len() + 1,
        );

        let attr_name = CString::new("shared_name").unwrap();
        let shared_name_cstr = shared_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            shared_name_cstr.as_ptr() as *mut c_void,
            shared_name.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn whole_file_reader_v2<T>(
    ctx: &Context,
    container: &String,
    shared_name: &String,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("WholeFileReaderV2").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        // Attributes

        let attr_name = CString::new("container").unwrap();
        let container_cstr = container.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            container_cstr.as_ptr() as *mut c_void,
            container.as_bytes().len() + 1,
        );

        let attr_name = CString::new("shared_name").unwrap();
        let shared_name_cstr = shared_name.as_bytes();
        tf::TFE_OpSetAttrString(
            op,
            attr_name.as_ptr(),
            shared_name_cstr.as_ptr() as *mut c_void,
            shared_name.as_bytes().len() + 1,
        );

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn window_dataset<T>(
    ctx: &Context,
    input_dataset: T,
    size: T,
    shift: T,
    stride: T,
    drop_remainder: T,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("WindowDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_dataset.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, size.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, shift.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, stride.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, drop_remainder.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn worker_heartbeat<T>(ctx: &Context, request: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("WorkerHeartbeat").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, request.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn wrap_dataset_variant<T>(ctx: &Context, input_handle: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("WrapDatasetVariant").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, input_handle.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn xdivy<T>(ctx: &Context, x: T, y: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Xdivy").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, y.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn xlog1py<T>(ctx: &Context, x: T, y: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Xlog1py").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, y.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn xlogy<T>(ctx: &Context, x: T, y: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Xlogy").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, y.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn zeros_like<T>(ctx: &Context, x: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ZerosLike").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn zeta<T>(ctx: &Context, x: T, q: T) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("Zeta").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        tf::TFE_OpAddInput(op, x.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        tf::TFE_OpAddInput(op, q.to_handle()?.inner, status.inner);
        // status_check(context::get_status());

        // Attributes

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}

pub fn zip_dataset<T>(
    ctx: &Context,
    input_datasets: &Vec<T>,
    output_type_s: &Vec<DataType>,
    output_shapes: &Vec<Vec<i64>>,
) -> Result<TensorHandle>
where
    T: ToHandle,
{
    let status = Status::new();

    unsafe {
        // Define Op
        let op_name = CString::new("ZipDataset").unwrap();
        let op = tf::TFE_NewOp(ctx.inner, op_name.as_ptr(), status.inner);

        // Required input arguments

        let mut input_datasets_handles: Vec<*mut tf::TFE_TensorHandle> = input_datasets
            .into_iter()
            .map(|t| t.to_handle().unwrap().inner)
            .collect();
        tf::TFE_OpAddInputList(
            op,
            input_datasets_handles.as_mut_ptr(),
            input_datasets.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        // Attributes

        let attr_name = CString::new("output_type_s").unwrap();
        let output_type_s: Vec<tf::TF_DataType> =
            output_type_s.into_iter().map(|v| v.to_c()).collect();
        tf::TFE_OpSetAttrTypeList(
            op,
            attr_name.as_ptr(),
            output_type_s.as_ptr(),
            output_type_s.len() as i32,
        );

        let mut output_shapes_values: Vec<*const i64> =
            output_shapes.into_iter().map(|v| v.as_ptr()).collect();
        let output_shapes_ndims: Vec<i32> =
            output_shapes.into_iter().map(|v| v.len() as i32).collect();
        let attr_name = CString::new("output_shapes").unwrap();
        tf::TFE_OpSetAttrShapeList(
            op,
            attr_name.as_ptr(),
            output_shapes_values.as_mut_ptr(),
            output_shapes_ndims.as_ptr(),
            output_shapes.len() as i32,
            status.inner,
        );
        // status_check(context::get_status());

        let attr_name = CString::new("N").unwrap();
        tf::TFE_OpSetAttrInt(op, attr_name.as_ptr(), input_datasets.len() as i64);

        // Execute Op
        let mut num_output = 1;
        let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>()];
        tf::TFE_Execute(
            op,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
        Ok(TensorHandle { inner: res[0] })
    }
}
